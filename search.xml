<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ArrayList一些注意事项</title>
    <url>/ArrayList-Cautions/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ArrayList 是 java 中最常用的也是最基本的集合类，但是其中一部分函数如果不注意就会很容易出错。</p>
<span id="more"></span>

<h1 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h1><p>java5 后引入了自动封箱和自动拆箱的语法糖，一方面简化了程序，但是另一方面，在对支持<code>remove(int index)</code>又支持<code>remove(Object o)</code>的 ArrayList 类的方法调用上，就很容易疑惑，也很容易出错。如果调用<code>remove</code>函数时传入的是数字 1 ，那调用的是 <code>remove(int index)</code>函数还是<code>remove(Object o)</code>函数呢？答案可以从下面的程序及输出结果中得知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRemove</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    nums.add(<span class="number">1</span>);</span><br><span class="line">    nums.add(<span class="number">2</span>);</span><br><span class="line">    nums.add(<span class="number">3</span>);</span><br><span class="line">    nums.add(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;----before remove----&quot;</span>);</span><br><span class="line">    System.out.println(nums.toString());</span><br><span class="line"></span><br><span class="line">    nums.remove(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;----after remove(1)&quot;</span>);</span><br><span class="line">    System.out.println(nums.toString());</span><br><span class="line"></span><br><span class="line">    nums.remove((Integer) <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;----after remove((Integer) 1)----&quot;</span>);</span><br><span class="line">    System.out.println(nums.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----before remove----</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">----after remove(1)----</span><br><span class="line">[1, 3, 4]</span><br><span class="line">----after remove((Integer) 1)----</span><br><span class="line">[3, 4]</span><br></pre></td></tr></table></figure>

<p>从上述程序输出可以得知，当调用 remove 函数时，如果输入的是数字或 int 类型，则调用 <code>remove(int index)</code>函数，而如果传入的是  Integer 类型或将数字强制转换为 Integer 类型，则调用的是<code>remove(Object o)</code>函数。</p>
<p>更近一步，推而广之，如果一个类中存在重载函数，既有基本类型的函数，也有封装类型的函数，当传入数字或基本类型变量时，优先调用的基本类型的函数，而不是封装类型的函数，只有明确将传入的基本类型转换成封装类型或传入封装类型的参数变量，才会调用封装类型的函数。</p>
<h1 id="subList"><a href="#subList" class="headerlink" title="subList"></a>subList</h1><p>subList 函数是返回 ArrayList 集合中的一个子序列，但是需要注意以下几点：</p>
<ul>
<li>subList 是原有 ArrayList 集合中的一个”指针”的集合，对 subList 做出的改动会同步反映到原有的 ArrayList 集合中，同时对原有的 ArrayList 集合的非改变集合大小的操作也都会直接同步反映到 subList 集合中</li>
<li>对原有的 ArrayList 集合的add、remove等改变集合大小的操作，会使原有的 subList 失效，即再调用 subList 的操作会抛出<code>ConcurrentModificationException</code>异常</li>
</ul>
<p>如下程序及其输出证明了上述特点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSubList</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    nums.add(<span class="number">1</span>);</span><br><span class="line">    nums.add(<span class="number">2</span>);</span><br><span class="line">    nums.add(<span class="number">3</span>);</span><br><span class="line">    nums.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// subList is [2, 3]</span></span><br><span class="line">    List&lt;Integer&gt; subList = nums.subList(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;----init-----&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;nums: &quot;</span> + nums.toString());</span><br><span class="line">    System.out.println(<span class="string">&quot;subList: &quot;</span> + subList.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对subList的remove操作会反映到原有的集合中</span></span><br><span class="line">    subList.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;----after subList.remove(0)----&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;nums: &quot;</span> + nums.toString());</span><br><span class="line">    System.out.println(<span class="string">&quot;subList: &quot;</span> + subList.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对subList的add操作会反映到原有的集合中</span></span><br><span class="line">    subList.add(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;----after subList.add(2)----&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;nums: &quot;</span> + nums.toString());</span><br><span class="line">    System.out.println(<span class="string">&quot;subList: &quot;</span> + subList.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对subList的remove操作会反映到原有的集合中</span></span><br><span class="line">    subList.remove((Integer) <span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;----after subList.remove((Integer) 2)----&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;nums: &quot;</span> + nums.toString());</span><br><span class="line">    System.out.println(<span class="string">&quot;subList: &quot;</span> + subList.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对subList的set操作会反映到原有的集合中</span></span><br><span class="line">    subList.set(<span class="number">0</span>, <span class="number">333</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;----after subList.set(0, 333)----&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;nums: &quot;</span> + nums.toString());</span><br><span class="line">    System.out.println(<span class="string">&quot;subList: &quot;</span> + subList.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对原有集合的set操作会反映到subList集合中</span></span><br><span class="line">    nums.set(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;----after nums.set(1, 3)----&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;nums: &quot;</span> + nums.toString());</span><br><span class="line">    System.out.println(<span class="string">&quot;subList: &quot;</span> + subList.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能对原有的集合进行add或remove等会改变集合大小的操作</span></span><br><span class="line">    <span class="comment">// 否则再次对subList集合进行操作时会抛 ConcurrentModificationException 异常</span></span><br><span class="line">    <span class="comment">// nums.remove(0);</span></span><br><span class="line">    <span class="comment">// System.out.println(subList.toString());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----init-----</span><br><span class="line">nums: [1, 2, 3, 4]</span><br><span class="line">subList: [2, 3]</span><br><span class="line">----after subList.remove(0)----</span><br><span class="line">nums: [1, 3, 4]</span><br><span class="line">subList: [3]</span><br><span class="line">----after subList.add(2)----</span><br><span class="line">nums: [1, 3, 2, 4]</span><br><span class="line">subList: [3, 2]</span><br><span class="line">----after subList.remove((Integer) 2)----</span><br><span class="line">nums: [1, 3, 4]</span><br><span class="line">subList: [3]</span><br><span class="line">----after subList.set(0, 333)----</span><br><span class="line">nums: [1, 333, 4]</span><br><span class="line">subList: [333]</span><br><span class="line">----after nums.set(1, 3)----</span><br><span class="line">nums: [1, 3, 4]</span><br><span class="line">subList: [3]</span><br></pre></td></tr></table></figure>

<p>至于 subList 为什么有以上的特点，这可以从 ArrayList 的源码中得知答案。</p>
<p>ArrayList 中 subList 返回的是一个内部类<code>SubList</code>，从内部类的构造函数可以看出，当创建一个 SubList 时，会将 ArrayList 对象及其部分参数传入构造函数中。当调用 subList 中的 set、get、add、remove 操作都是直接操作原有的 ArrayList 集合，所以修改 subList 对象会导致原有的 ArrayList 对象。</p>
<p>而对于修改原有的 ArrayList 对象的情况，则需要分两种情况考虑，一种是不修改集合大小的操作（即不改变 modCount 的操作，如 get、set 函数），这种情况由于没有修改 modCount 变量的值，所以下次调用 subList 对象的函数进行校验时仍然满足 modCount 变量值相等的条件，不会抛出 ConcurrentModificationException 异常。另一种是会修改集合大小的操作（即改变 modCount 的操作，如 add、remove 函数），这种情况由于修改了原有的 ArrayList 对象中的 modCount 变量值而没有修改 subList 变量中的 modCount 变量值，所以下次再调用 subList 对象的函数时，由于两者的 modCount 变量不相等，会抛出ConcurrentModificationException 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubList</span>(<span class="built_in">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SubList 内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SubList</span> <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他代码 ...</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">            <span class="type">int</span> offset, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex) &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        <span class="built_in">this</span>.parentOffset = fromIndex;</span><br><span class="line">        <span class="built_in">this</span>.offset = offset + fromIndex;</span><br><span class="line">        <span class="built_in">this</span>.size = toIndex - fromIndex;</span><br><span class="line">        <span class="comment">// 此参数用于记录改变集合大小的操作次数，</span></span><br><span class="line">        <span class="comment">// 当 SubList 中的参数与原有的 ArrayList 集合中的参数不相等时，</span></span><br><span class="line">        <span class="comment">// 再次对 SubList 操作会抛出 ConcurrentModificationException 异常</span></span><br><span class="line">        <span class="built_in">this</span>.modCount = ArrayList.<span class="built_in">this</span>.modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E e)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">// 校验 SubList 和原有 ArrayList 集合中的 modCount 变量是否相等，</span></span><br><span class="line">        <span class="comment">// 不相等则抛出 ConcurrentModificationException 异常</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// 直接操作的是原有的 ArrayList 集合中对应的变量</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.elementData(offset + index);</span><br><span class="line">        ArrayList.<span class="built_in">this</span>.elementData[offset + index] = e;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">// 校验 SubList 和原有 ArrayList 集合中的 modCount 变量是否相等，</span></span><br><span class="line">        <span class="comment">// 不相等则抛出 ConcurrentModificationException 异常</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// 直接返回原有的 ArrayList 集合中对应的变量</span></span><br><span class="line">        <span class="keyword">return</span> ArrayList.<span class="built_in">this</span>.elementData(offset + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E e)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="comment">// 校验 SubList 和原有 ArrayList 集合中的 modCount 变量是否相等，</span></span><br><span class="line">        <span class="comment">// 不相等则抛出 ConcurrentModificationException 异常</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// 直接在原有的 ArrayList 集合中对应的位置中增加元素</span></span><br><span class="line">        parent.add(parentOffset + index, e);</span><br><span class="line">        <span class="comment">// 修改 modCount 的值，避免在下次对 SubList 进行操作时抛出异常</span></span><br><span class="line">        <span class="built_in">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="built_in">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">// 校验 SubList 和原有 ArrayList 集合中的 modCount 变量是否相等，</span></span><br><span class="line">        <span class="comment">// 不相等则抛出 ConcurrentModificationException 异常</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// 直接删除原有的 ArrayList 集合中对应的位置的元素</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> parent.remove(parentOffset + index);</span><br><span class="line">        <span class="comment">// 修改 modCount 的值，避免在下次对 SubList 进行操作时抛出异常</span></span><br><span class="line">        <span class="built_in">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="built_in">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ArrayList.<span class="built_in">this</span>.modCount != <span class="built_in">this</span>.modCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java8中ArrayList实现原理</title>
    <url>/ArrayList/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ArrayList是常用的数据结构，在java8中，其主要是通过数组来实现的。在插入一个元素时会先判断数组容量是否还能放置元素，如果不能，则进行扩容。本文主要分析add、get、set、remove方法。</p>
<span id="more"></span>

<h1 id="一些成员变量"><a href="#一些成员变量" class="headerlink" title="一些成员变量"></a>一些成员变量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的初始化数组大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空数组，主要用于new ArrayList&lt;&gt;()的情况 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组数据结构，用于存放ArrayList的元素</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前ArrayList的元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>

<h1 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h1><h2 id="add-E-e-方法"><a href="#add-E-e-方法" class="headerlink" title="add(E e)方法"></a>add(E e)方法</h2><h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start=&gt;start: Start</span><br><span class="line">isArrayEmpty=&gt;condition: 数组是否为空</span><br><span class="line">reCalcMinCapacity=&gt;operation: 重新计算minCapacity</span><br><span class="line">						    大小,取</span><br><span class="line">                              DEFAULT_CAPACITY</span><br><span class="line">                              和minCapacity</span><br><span class="line">                              的最大值</span><br><span class="line">isResize=&gt;condition: minCapacity大于</span><br><span class="line">				    当前数组大小</span><br><span class="line">resize=&gt;operation: 扩容数组为原先的1.5倍</span><br><span class="line">addObj=&gt;operation: 往数组末尾中加入元素</span><br><span class="line">end=&gt;end: End</span><br><span class="line"></span><br><span class="line">start-&gt;isArrayEmpty(yes)-&gt;reCalcMinCapacity-&gt;isResize(yes)-&gt;resize-&gt;addObj-&gt;end</span><br><span class="line">isArrayEmpty(no)-&gt;isResize(no)-&gt;addObj</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 保证数组大小能够放置新元素，必要时进行扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 在数组末端增加新元素</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果数组是空数组，第一次增加元素时取默认初始大小</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前数组已经满了，要增加新元素，只能扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组扩容的函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 新的数组大小为原先数组大小的 1.5 倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 拷贝原先数组元素</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="add-int-index-E-e-方法"><a href="#add-int-index-E-e-方法" class="headerlink" title="add(int index, E e)方法"></a>add(int index, E e)方法</h2><p>这个方法与<code>add(E e)</code>方法类似，只不过在函数刚开始的地方多了个边界检查，在确保数组能够放置新元素后面增加了下标元素及其后面的元素向后移动一位的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 确保数组能够放置新元素，必要时进行 1.5 倍大小的扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 从下标开始的元素均向后移动一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    <span class="comment">// 在下标的位置放置新元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h1><p>get方法很简单，就是检查下标的边界，然后直接取数组下标的元素返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">	<span class="comment">// 返回数组下标所对应元素的值</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组下标所对应元素的值</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h1><p>set方法也很简单，也是先检查下标的边界，然后先取出原有下标的元素，再直接替换新的元素，最后将原先的元素返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">	<span class="comment">// 取出下标对应的老元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="comment">// 替换下标元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h1><h2 id="remove-int-index-方法"><a href="#remove-int-index-方法" class="headerlink" title="remove(int index)方法"></a>remove(int index)方法</h2><p>根据下标删除元素，首先进行边界检查，然后取出下标对应的元素，再将这个元素后面的元素都向前移动一位，接着将数组最后一个元素置空以便垃圾回收器能够回收该对象，最后将下标指向的原先的对象返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 取出原先下标对应的值</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将下标后面的元素向前移动一位</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    <span class="comment">// 将数组最后一个元素置空，以便垃圾回收器进行回收</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="remove-Object-o-方法"><a href="#remove-Object-o-方法" class="headerlink" title="remove(Object o)方法"></a>remove(Object o)方法</h2><p>根据对象删除对象的方法主要是根据对象是否是空的进行分别处理。</p>
<ul>
<li>删除的对象是<code>null</code>，则查找数组中的元素，如果有<code>null</code>元素，则将第一个<code>null</code>元素删除</li>
<li>删除的对象不是null，则根据<code>equals</code>方法将对象与数组中的元素进行比较，将第一个相等的元素删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 查找数组的null元素，找到时将第一个null元素删除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 根据equals方法将对象与数组元素进行比较，将第一个相等的元素删除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标后面的元素向前移动一位，将数组最后一个元素置空，以便垃圾回收器进行回收</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将下标后面的元素向前移动一位</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    <span class="comment">// 将数组最后一个元素置空，以便垃圾回收器进行回收</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>ArrayList允许增加<code>null</code>对象</li>
<li>ArrayList允许添加重复对象</li>
<li>ArrayList对象是有序的，新增的对象在尾部</li>
<li>ArrayList不是线程安全的，需要在外部调用的地方手动保证线程安全。因为在add函数中有size++的操作，当有两个线程同时调用add函数时，假设A线程已经在对应的位置上放置了元素，但是size还未加一，此时切换到B线程执行add函数直到结束，size加一了，切回A线程执行size++，此时A线程中的size值还是原先的没有经过B线程加一的值，在A线程执行完size++后，此时size只会加一而不会加二，从而导致数据丢失。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java8中HashSet实现原理</title>
    <url>/HashSet/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HashSet是一种比较常见的数据结构，经常用它来进行一些重复数据的过滤。在java8中，其主要是通过HashMap来实现的。在放置数据时，将数据作为HashMap的key进行保存，相比其他数据结构（如HashMap, ArrayList）而言，这是一种比较简单的数据结构，因为其方法均委托给HashMap数据结构来实现了。本文主要分析HashSet常用的几个方法。</p>
<span id="more"></span>

<h1 id="一些成员变量"><a href="#一些成员变量" class="headerlink" title="一些成员变量"></a>一些成员变量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用HashMap数据结构来实现HashSet</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap中value的值，是固定的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h1 id="size函数"><a href="#size函数" class="headerlink" title="size函数"></a>size函数</h1><p>直接调用map数据结构的size()函数获得结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="isEmpty函数"><a href="#isEmpty函数" class="headerlink" title="isEmpty函数"></a>isEmpty函数</h1><p>直接调用HashMap数据结构的isEmpty函数获取结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="contains函数"><a href="#contains函数" class="headerlink" title="contains函数"></a>contains函数</h1><p>直接调用HashMap数据结构的containsKey函数获取结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h1><p>将要新增的元素作为HashMap的key值，将常量<code>PRESENT</code>作为value值，往map中插入数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h1><p>直接调用HashMap数据结构的remove函数进行删除元素操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="clear函数"><a href="#clear函数" class="headerlink" title="clear函数"></a>clear函数</h1><p>直接调用HashMap数据结构的clear函数得到结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>由于HashSet使用HashMap来实现的，所以HashSet也具有HashMap的一些特点。</p>
<ul>
<li>元素是无序的</li>
<li>允许有且仅有一个<code>null</code>元素</li>
<li>非线程安全。HashSet的add函数调用了HashMap的put方法，而在HashMap的 put 方法中，查找链表到尾部时，如果仍然找不到 key 值相同的元素，则在尾部插入新节点。假设线程A要插入（a, a）的键值对，线程B要插入（b, b）的键值对，再假设 a、b 这两个 key 会映射到同一个 table[i] 上，并且原先都没有插入过 key 为 a 或 b 的键值对；当线程A遍历到链表尾部时，在准备（下一步）插入新节点的时候，线程切换到B执行，B也遍历到链表尾部，并插入新节点（b, b），然后线程切换到A，A插入新节点（a, a），此时会造成插入的（b, b）节点被覆盖丢失。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>一个偶现问题的分析</title>
    <url>/a-occasional-problem-analysis/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几天遇到一个偶现问题，比较奇怪，经过几轮分析定位后终于解决。现在记录一下。</p>
<p>由于信息安全，本文无法提供问题相关的现象截图及代码截图。只能文字描述。</p>
<span id="more"></span>

<h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>系统运行一段时间后，进入页面报错，后台只有简单的 <code>serialize error</code>，除此之外，并无其他异常信息。在重启服务器后，此问题消失，但是运行一段时间（具体多长时间未知）问题又出现。</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>首先，根据日志找到打印日志的地方，发现异常被吞了（因为安全问题，堆栈中可能存在敏感信息，故没有打印），导致无法定位问题。修改代码，让其能够打印堆栈，以便定位问题。</p>
<p>加上打印堆栈的日志后，换到环境上重启，等待一段时间，环境终于报错了。不过，这异常堆栈还是无法定位，查看代码发现初始异常还是被吞掉了（还是因为安全原因，没把异常堆栈打出来）</p>
<p>再次修改代码，加上打印异常堆栈的日志，换到环境上，又经过一段时间等待，环境终于又报错了，此时终于答应出了原始异常。异常显示转 json 失败：<code>com.fasterxml.jackson.core.JsonParseException: Illegal creater ((CTRL-CHAR, code 0)): only regular white space (\r, \n, \t) is allowed between tokens\n at [Source: (String)&quot;&quot;;line 1, column: 2]</code></p>
<p>这日志还是不够分析问题，决定额外增加入参的日志，同时断点调试。经过一段时间等待，问题复现，断点看到函数的入参为空字符串，根据调用堆栈，找到入口，请求的参数为空字符串（<code>RequestParam</code> 接收的 <code>String</code> 参数）。但是查看前台发送的请求，是有参数的。</p>
<p>至此，常用的定位问题的步骤已经走完了，没找到问题原因，同时陷入困境：为什么前台请求有参数，但是后台接收的是空字符串，同时打印出来的值又是一连串的 <code>\u0000</code></p>
<p>同事提醒，可能是前阵子安全整改，在请求处理完成后，把字符串的 value 都值为 <code>00</code> 了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">valueField</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">valueField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">char</span>[] value = (<span class="type">char</span>[]) valueField.get(strObject);</span><br><span class="line">Arrays.fill(value, (<span class="type">char</span>) <span class="number">0x00</span>);</span><br></pre></td></tr></table></figure>

<p>虽然说字符串是在常量池里面的，改变其 <code>value</code> 的值会影响到其他相同的 <code>String</code> 对象，但是这无法解释一下问题：</p>
<ul>
<li>环境刚重启，对于同个请求（参数一样），触发多次，也不会报错，但是运行一段时间后，可能就会报错（如果是常量池的值改变的话，应该第一次不会报错，第二次开始就会报错，与现象不符）</li>
<li>报错的请求，也不是全部报错，而是部分报错，即使同样是 <code>get</code> 请求，也是部分成功部分失败（如果是常量池的话，应该是全部报错，而不是部分请求报错）</li>
</ul>
<p>但是，从日志输出、调试输出以及其他版本的环境现象来看，极有可能就是因为字符串清零的动作引起的。</p>
<p>去除字符串清零的代码，换到环境上，运行一段时间，观察环境并无报错。</p>
<p>至此，陷入困境，疑惑重重，虽然怀疑是这段代码引起，但是并没有找到问题原因，也无法解释上面两个问题。在网上搜了大量字符串常量池的文章，仍然无法解释问题。因此，决定查看 <code>spring</code> 源码对请求参数的解析，分析其是否在解析过程中做了特殊处理。</p>
<p>首先，<code>RequestParam</code> 参数的解析在 <code>org.springframework.web.method.annotation.RequestParamMethodArgumentResolver</code> 类中，找到继承类的 <code>resolveArgument</code> 方法，主要看 <code>resolveName</code> 方法，这是一个抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer, NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    AbstractNamedValueMethodArgumentResolver.<span class="type">NamedValueInfo</span> <span class="variable">namedValueInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.getNamedValueInfo(parameter);</span><br><span class="line">    <span class="type">MethodParameter</span> <span class="variable">nestedParameter</span> <span class="operator">=</span> parameter.nestedIfOptional();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">resolvedName</span> <span class="operator">=</span> <span class="built_in">this</span>.resolveStringValue(namedValueInfo.name);</span><br><span class="line">    <span class="keyword">if</span> (resolvedName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Specified name must not resolve to null: [&quot;</span> + namedValueInfo.name + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 主要是这里解析的</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> <span class="built_in">this</span>.resolveName(resolvedName.toString(), nestedParameter, webRequest);</span><br><span class="line">        <span class="keyword">if</span> (arg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (namedValueInfo.defaultValue != <span class="literal">null</span>) &#123;</span><br><span class="line">                arg = <span class="built_in">this</span>.resolveStringValue(namedValueInfo.defaultValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            arg = <span class="built_in">this</span>.handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(arg) &amp;&amp; namedValueInfo.defaultValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            arg = <span class="built_in">this</span>.resolveStringValue(namedValueInfo.defaultValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (binderFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">WebDataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(webRequest, (Object)<span class="literal">null</span>, namedValueInfo.name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ConversionNotSupportedException var11) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentConversionNotSupportedException</span>(arg, var11.getRequiredType(), namedValueInfo.name, parameter, var11.getCause());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TypeMismatchException var12) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentTypeMismatchException</span>(arg, var12.getRequiredType(), namedValueInfo.name, parameter, var12.getCause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);</span><br><span class="line">        <span class="keyword">return</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 <code>RequestParamMethodArgumentResolver</code> 看 <code>resolveName</code>，参数值解析在 <code>request.getParameterValues</code> 这里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">resolveName</span><span class="params">(String name, MethodParameter parameter, NativeWebRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> (HttpServletRequest)request.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">    Object arg;</span><br><span class="line">    <span class="keyword">if</span> (servletRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">        arg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);</span><br><span class="line">        <span class="keyword">if</span> (arg != MultipartResolutionDelegate.UNRESOLVABLE) &#123;</span><br><span class="line">            <span class="keyword">return</span> arg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arg = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">MultipartRequest</span> <span class="variable">multipartRequest</span> <span class="operator">=</span> (MultipartRequest)request.getNativeRequest(MultipartRequest.class);</span><br><span class="line">    <span class="keyword">if</span> (multipartRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">        List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);</span><br><span class="line">        <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">            arg = files.size() == <span class="number">1</span> ? files.get(<span class="number">0</span>) : files;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 参数值解析在这里</span></span><br><span class="line">        String[] paramValues = request.getParameterValues(name);</span><br><span class="line">        <span class="keyword">if</span> (paramValues != <span class="literal">null</span>) &#123;</span><br><span class="line">            arg = paramValues.length == <span class="number">1</span> ? paramValues[<span class="number">0</span>] : paramValues;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入函数，到 <code>org.springframework.web.context.request.ServletWebRequest</code> 类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> String[] getParameterValues(String paramName) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getRequest().getParameterValues(paramName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟踪，到 <code>org.apache.catalina.connector.RequestFacade#getParameterValues</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.request == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(sm.getString(<span class="string">&quot;requestFacade.nullRequest&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String[] ret = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (SecurityUtil.isPackageProtectionEnabled()) &#123;</span><br><span class="line">            ret = (String[])AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">RequestFacade</span>.GetParameterValuePrivilegedAction(name));</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="literal">null</span>) &#123;</span><br><span class="line">                ret = (String[])ret.clone();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 主要看这里</span></span><br><span class="line">            ret = <span class="built_in">this</span>.request.getParameterValues(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 <code>getParameterValues</code> 函数，这里面的  <code>parseParameters</code> 和 <code>getParameterValues</code> 都调用了 <code>handleQueryParameters</code> 这个函数，这个函数是处理参数值的主要逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.parametersParsed) &#123;</span><br><span class="line">        <span class="comment">// 这个函数里面调用了 handleQueryParameters，是处理参数的主要逻辑</span></span><br><span class="line">        <span class="built_in">this</span>.parseParameters();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个函数里面也调用了 handleQueryParameters，是处理参数的主要逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.coyoteRequest.getParameters().getParameterValues(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">    <span class="comment">// 处理参数的主要逻辑</span></span><br><span class="line">    <span class="built_in">this</span>.handleQueryParameters();</span><br><span class="line">    ArrayList&lt;String&gt; values = (ArrayList)<span class="built_in">this</span>.paramHashValues.get(name);</span><br><span class="line">    <span class="keyword">return</span> values == <span class="literal">null</span> ? <span class="literal">null</span> : (String[])values.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[values.size()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseParameters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.parametersParsed = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">Parameters</span> <span class="variable">parameters</span> <span class="operator">=</span> <span class="built_in">this</span>.coyoteRequest.getParameters();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parameters.setLimit(<span class="built_in">this</span>.getConnector().getMaxParameterCount());</span><br><span class="line">        <span class="type">String</span> <span class="variable">enc</span> <span class="operator">=</span> <span class="built_in">this</span>.getCharacterEncoding();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">useBodyEncodingForURI</span> <span class="operator">=</span> <span class="built_in">this</span>.connector.getUseBodyEncodingForURI();</span><br><span class="line">        <span class="keyword">if</span> (enc != <span class="literal">null</span>) &#123;</span><br><span class="line">            parameters.setEncoding(enc);</span><br><span class="line">            <span class="keyword">if</span> (useBodyEncodingForURI) &#123;</span><br><span class="line">                parameters.setQueryStringEncoding(enc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parameters.setEncoding(<span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (useBodyEncodingForURI) &#123;</span><br><span class="line">                parameters.setQueryStringEncoding(<span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理参数的主要逻辑</span></span><br><span class="line">        parameters.handleQueryParameters();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.usingInputStream || <span class="built_in">this</span>.usingReader) &#123;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.getConnector().isParseBodyMethod(<span class="built_in">this</span>.getMethod())) &#123;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> <span class="built_in">this</span>.getContentType();</span><br><span class="line">            <span class="keyword">if</span> (contentType == <span class="literal">null</span>) &#123;</span><br><span class="line">                contentType = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">semicolon</span> <span class="operator">=</span> contentType.indexOf(<span class="number">59</span>);</span><br><span class="line">            <span class="keyword">if</span> (semicolon &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                contentType = contentType.substring(<span class="number">0</span>, semicolon).trim();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                contentType = contentType.trim();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;multipart/form-data&quot;</span>.equals(contentType)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.parseParts(<span class="literal">false</span>);</span><br><span class="line">                success = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>.equals(contentType)) &#123;</span><br><span class="line">                success = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="built_in">this</span>.getContentLength();</span><br><span class="line">                <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;chunked&quot;</span>.equalsIgnoreCase(<span class="built_in">this</span>.coyoteRequest.getHeader(<span class="string">&quot;transfer-encoding&quot;</span>))) &#123;</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">var21</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                        Context context;</span><br><span class="line">                        <span class="type">byte</span>[] formData;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            formData = <span class="built_in">this</span>.readChunkedPostBody();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IllegalStateException var17) &#123;</span><br><span class="line">                            parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);</span><br><span class="line">                            context = <span class="built_in">this</span>.getContext();</span><br><span class="line">                            <span class="keyword">if</span> (context != <span class="literal">null</span> &amp;&amp; context.getLogger().isDebugEnabled()) &#123;</span><br><span class="line">                                context.getLogger().debug(sm.getString(<span class="string">&quot;coyoteRequest.parseParameters&quot;</span>), var17);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException var18) &#123;</span><br><span class="line">                            parameters.setParseFailedReason(FailReason.CLIENT_DISCONNECT);</span><br><span class="line">                            context = <span class="built_in">this</span>.getContext();</span><br><span class="line">                            <span class="keyword">if</span> (context != <span class="literal">null</span> &amp;&amp; context.getLogger().isDebugEnabled()) &#123;</span><br><span class="line">                                context.getLogger().debug(sm.getString(<span class="string">&quot;coyoteRequest.parseParameters&quot;</span>), var18);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (formData != <span class="literal">null</span>) &#123;</span><br><span class="line">                            parameters.processParameters(formData, <span class="number">0</span>, formData.length);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">maxPostSize</span> <span class="operator">=</span> <span class="built_in">this</span>.connector.getMaxPostSize();</span><br><span class="line">                    Context context;</span><br><span class="line">                    <span class="keyword">if</span> (maxPostSize &gt;= <span class="number">0</span> &amp;&amp; len &gt; maxPostSize) &#123;</span><br><span class="line">                        context = <span class="built_in">this</span>.getContext();</span><br><span class="line">                        <span class="keyword">if</span> (context != <span class="literal">null</span> &amp;&amp; context.getLogger().isDebugEnabled()) &#123;</span><br><span class="line">                            context.getLogger().debug(sm.getString(<span class="string">&quot;coyoteRequest.postTooLarge&quot;</span>));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">this</span>.checkSwallowInput();</span><br><span class="line">                        parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    context = <span class="literal">null</span>;</span><br><span class="line">                    <span class="type">byte</span>[] formData;</span><br><span class="line">                    <span class="keyword">if</span> (len &lt; <span class="number">8192</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.postData == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="built_in">this</span>.postData = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8192</span>];</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        formData = <span class="built_in">this</span>.postData;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        formData = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.readPostBody(formData, len) != len) &#123;</span><br><span class="line">                            parameters.setParseFailedReason(FailReason.REQUEST_BODY_INCOMPLETE);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var19) &#123;</span><br><span class="line">                        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.getContext();</span><br><span class="line">                        <span class="keyword">if</span> (context != <span class="literal">null</span> &amp;&amp; context.getLogger().isDebugEnabled()) &#123;</span><br><span class="line">                            context.getLogger().debug(sm.getString(<span class="string">&quot;coyoteRequest.parseParameters&quot;</span>), var19);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        parameters.setParseFailedReason(FailReason.CLIENT_DISCONNECT);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    parameters.processParameters(formData, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                success = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            parameters.setParseFailedReason(FailReason.UNKNOWN);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来分析 <code>handleQueryParameters</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleQueryParameters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.didQueryParameters) &#123;</span><br><span class="line">        <span class="built_in">this</span>.didQueryParameters = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.queryMB != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.queryMB.isNull()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;Decoding query &quot;</span> + <span class="built_in">this</span>.decodedQuery + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.queryStringEncoding);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// this.queryMB 这个值之前调试的时候发现是有数据的，跟前台传的值能对应上</span></span><br><span class="line">                <span class="built_in">this</span>.decodedQuery.duplicate(<span class="built_in">this</span>.queryMB);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">                var2.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重点看这个函数</span></span><br><span class="line">            <span class="built_in">this</span>.processParameters(<span class="built_in">this</span>.decodedQuery, <span class="built_in">this</span>.queryStringEncoding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看 <code>this.processParameters(this.decodedQuery, this.queryStringEncoding)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processParameters</span><span class="params">(MessageBytes data, String encoding)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="literal">null</span> &amp;&amp; !data.isNull() &amp;&amp; data.getLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.getType() != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 里面 byte 数组拿的是引用关系，不是深拷贝</span></span><br><span class="line">            data.toBytes();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteChunk</span> <span class="variable">bc</span> <span class="operator">=</span> data.getByteChunk();</span><br><span class="line">        <span class="comment">// 主要看这个函数</span></span><br><span class="line">        <span class="built_in">this</span>.processParameters(bc.getBytes(), bc.getOffset(), bc.getLength(), <span class="built_in">this</span>.getCharset(encoding));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看 <code>private void processParameters(byte[] bytes, int start, int len, Charset charset)</code>，函数很长，主要是解析 <code>name</code> 和 <code>value</code> 的值。重点看 <code>org.apache.tomcat.util.buf.ByteChunk#toString</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processParameters</span><span class="params">(<span class="type">byte</span>[] bytes, <span class="type">int</span> start, <span class="type">int</span> len, Charset charset)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(sm.getString(<span class="string">&quot;parameters.bytes&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">String</span>(bytes, start, len, DEFAULT_CHARSET)&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">decodeFailCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> start;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + len;</span><br><span class="line"></span><br><span class="line">    label172:</span><br><span class="line">    <span class="keyword">while</span>(pos &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nameStart</span> <span class="operator">=</span> pos;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nameEnd</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">valueStart</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">valueEnd</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">parsingName</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">decodeName</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">decodeValue</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">parameterComplete</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span>(bytes[pos]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">37</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">43</span>:</span><br><span class="line">                    <span class="keyword">if</span> (parsingName) &#123;</span><br><span class="line">                        decodeName = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        decodeValue = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ++pos;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">38</span>:</span><br><span class="line">                    <span class="keyword">if</span> (parsingName) &#123;</span><br><span class="line">                        nameEnd = pos;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        valueEnd = pos;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    parameterComplete = <span class="literal">true</span>;</span><br><span class="line">                    ++pos;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">61</span>:</span><br><span class="line">                    <span class="keyword">if</span> (parsingName) &#123;</span><br><span class="line">                        nameEnd = pos;</span><br><span class="line">                        parsingName = <span class="literal">false</span>;</span><br><span class="line">                        ++pos;</span><br><span class="line">                        valueStart = pos;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ++pos;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    ++pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(!parameterComplete &amp;&amp; pos &lt; end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos == end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nameEnd == -<span class="number">1</span>) &#123;</span><br><span class="line">                nameEnd = pos;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valueStart &gt; -<span class="number">1</span> &amp;&amp; valueEnd == -<span class="number">1</span>) &#123;</span><br><span class="line">                valueEnd = pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled() &amp;&amp; valueStart == -<span class="number">1</span>) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">&quot;parameters.noequal&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;nameStart, nameEnd, <span class="keyword">new</span> <span class="title class_">String</span>(bytes, nameStart, nameEnd - nameStart, DEFAULT_CHARSET)&#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String message;</span><br><span class="line">        String value;</span><br><span class="line">        <span class="keyword">if</span> (nameEnd &lt;= nameStart) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valueStart == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(sm.getString(<span class="string">&quot;parameters.emptyChunk&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Mode</span> <span class="variable">logMode</span> <span class="operator">=</span> userDataLog.getNextMode();</span><br><span class="line">                <span class="keyword">if</span> (logMode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (valueEnd &gt; nameStart) &#123;</span><br><span class="line">                        value = <span class="keyword">new</span> <span class="title class_">String</span>(bytes, nameStart, valueEnd - nameStart, DEFAULT_CHARSET);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    message = sm.getString(<span class="string">&quot;parameters.invalidChunk&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;nameStart, valueEnd, value&#125;);</span><br><span class="line">                    <span class="keyword">switch</span>(logMode) &#123;</span><br><span class="line">                        <span class="keyword">case</span> INFO_THEN_DEBUG:</span><br><span class="line">                            message = message + sm.getString(<span class="string">&quot;parameters.fallToDebug&quot;</span>);</span><br><span class="line">                        <span class="keyword">case</span> INFO:</span><br><span class="line">                            log.info(message);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> DEBUG:</span><br><span class="line">                            log.debug(message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.setParseFailedReason(Parameters.FailReason.NO_NAME);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.tmpName.setBytes(bytes, nameStart, nameEnd - nameStart);</span><br><span class="line">            <span class="keyword">if</span> (valueStart &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.tmpValue.setBytes(bytes, valueStart, valueEnd - valueStart);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.tmpValue.setBytes(bytes, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.origName.append(bytes, nameStart, nameEnd - nameStart);</span><br><span class="line">                    <span class="keyword">if</span> (valueStart &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.origValue.append(bytes, valueStart, valueEnd - valueStart);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.origValue.append(bytes, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var21) &#123;</span><br><span class="line">                    log.error(sm.getString(<span class="string">&quot;parameters.copyFail&quot;</span>), var21);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (decodeName) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.urlDecode(<span class="built_in">this</span>.tmpName);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.tmpName.setCharset(charset);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="built_in">this</span>.tmpName.toString();</span><br><span class="line">                <span class="keyword">if</span> (valueStart &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (decodeValue) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.urlDecode(<span class="built_in">this</span>.tmpValue);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>.tmpValue.setCharset(charset);</span><br><span class="line">                    <span class="comment">// 主要看这个 toString 方法</span></span><br><span class="line">                    value = <span class="built_in">this</span>.tmpValue.toString();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里就存起来了，这样在调用的地方获取就能拿到具体的值</span></span><br><span class="line">                    <span class="built_in">this</span>.addParameter(name, value);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalStateException var22) &#123;</span><br><span class="line">                    <span class="type">Mode</span> <span class="variable">logMode</span> <span class="operator">=</span> maxParamCountLog.getNextMode();</span><br><span class="line">                    <span class="keyword">if</span> (logMode != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> var22.getMessage();</span><br><span class="line">                        <span class="keyword">switch</span>(logMode) &#123;</span><br><span class="line">                            <span class="keyword">case</span> INFO_THEN_DEBUG:</span><br><span class="line">                                message = message + sm.getString(<span class="string">&quot;parameters.maxCountFail.fallToDebug&quot;</span>);</span><br><span class="line">                            <span class="keyword">case</span> INFO:</span><br><span class="line">                                log.info(message);</span><br><span class="line">                                <span class="keyword">break</span> label172;</span><br><span class="line">                            <span class="keyword">case</span> DEBUG:</span><br><span class="line">                                log.debug(message);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var23) &#123;</span><br><span class="line">                <span class="built_in">this</span>.setParseFailedReason(Parameters.FailReason.URL_DECODING);</span><br><span class="line">                ++decodeFailCount;</span><br><span class="line">                <span class="keyword">if</span> (decodeFailCount == <span class="number">1</span> || log.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                        log.debug(sm.getString(<span class="string">&quot;parameters.decodeFail.debug&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="built_in">this</span>.origName.toString(), <span class="built_in">this</span>.origValue.toString()&#125;), var23);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">                        <span class="type">Mode</span> <span class="variable">logMode</span> <span class="operator">=</span> userDataLog.getNextMode();</span><br><span class="line">                        <span class="keyword">if</span> (logMode != <span class="literal">null</span>) &#123;</span><br><span class="line">                            message = sm.getString(<span class="string">&quot;parameters.decodeFail.info&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="built_in">this</span>.tmpName.toString(), <span class="built_in">this</span>.tmpValue.toString()&#125;);</span><br><span class="line">                            <span class="keyword">switch</span>(logMode) &#123;</span><br><span class="line">                                <span class="keyword">case</span> INFO_THEN_DEBUG:</span><br><span class="line">                                    message = message + sm.getString(<span class="string">&quot;parameters.fallToDebug&quot;</span>);</span><br><span class="line">                                <span class="keyword">case</span> INFO:</span><br><span class="line">                                    log.info(message);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> DEBUG:</span><br><span class="line">                                    log.debug(message);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.tmpName.recycle();</span><br><span class="line">            <span class="built_in">this</span>.tmpValue.recycle();</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.origName.recycle();</span><br><span class="line">                <span class="built_in">this</span>.origValue.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (decodeFailCount &gt; <span class="number">1</span> &amp;&amp; !log.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="type">Mode</span> <span class="variable">logMode</span> <span class="operator">=</span> userDataLog.getNextMode();</span><br><span class="line">        <span class="keyword">if</span> (logMode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sm.getString(<span class="string">&quot;parameters.multipleDecodingFail&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;decodeFailCount&#125;);</span><br><span class="line">            <span class="keyword">switch</span>(logMode) &#123;</span><br><span class="line">                <span class="keyword">case</span> INFO_THEN_DEBUG:</span><br><span class="line">                    message = message + sm.getString(<span class="string">&quot;parameters.fallToDebug&quot;</span>);</span><br><span class="line">                <span class="keyword">case</span> INFO:</span><br><span class="line">                    log.info(message);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DEBUG:</span><br><span class="line">                    log.debug(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入 <code>toString</code> 函数，看到 <code>StringCache.toString</code>，这里会进行缓存，那大概率就是这里的问题了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == <span class="built_in">this</span>.buff) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.end - <span class="built_in">this</span>.start == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : StringCache.toString(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着分析 <code>org.apache.tomcat.util.buf.StringCache#toString(org.apache.tomcat.util.buf.ByteChunk)</code> 函数，函数比较长，主要是两个功能：如果有缓存则从缓存中拿数据，如果没有缓存则 <code>new String</code> 返回，同时将数据放入 <code>map</code> 中，等到积累到一定数量后，将这些数据构建缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(ByteChunk bc)</span> &#123;</span><br><span class="line">    String value;</span><br><span class="line">    <span class="comment">// 判断是否已经构建了缓存，如果已经构建缓存，则尝试从缓存中拿数据</span></span><br><span class="line">    <span class="keyword">if</span> (bcCache != <span class="literal">null</span>) &#123;</span><br><span class="line">        ++accessCount;</span><br><span class="line">        <span class="comment">// 查看是否在缓存中</span></span><br><span class="line">        value = find(bc);</span><br><span class="line">        <span class="comment">// 如果不在缓存，则直接 new String 返回</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bc.toStringInternal();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果在缓存中，则直接将缓存中的值返回</span></span><br><span class="line">            ++hitCount;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存还没构建</span></span><br><span class="line">        value = bc.toStringInternal();</span><br><span class="line">        <span class="comment">// 长度小于 maxStringSize 才会考虑将其放在缓存中，否则也是直接 new String 返回</span></span><br><span class="line">        <span class="comment">// maxStringSize 的默认值是 128，可通过 tomcat.util.buf.StringCache.maxStringSize 进行配置</span></span><br><span class="line">        <span class="comment">// protected static final int maxStringSize = Integer.parseInt(System.getProperty(&quot;tomcat.util.buf.StringCache.maxStringSize&quot;, &quot;128&quot;));</span></span><br><span class="line">        <span class="keyword">if</span> (byteEnabled &amp;&amp; value.length() &lt; maxStringSize) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(bcStats) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bcCache != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> value;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> size;</span><br><span class="line">                <span class="comment">// 不会立即构建缓存，先将其放在 bcStats 中，等到达 trainThreshold 后，从中取出数据构建 bcCache 缓存</span></span><br><span class="line">                <span class="comment">// trainThreshold 的默认值是 20000，可通过 tomcat.util.buf.StringCache.trainThreshold 进行配置</span></span><br><span class="line">                <span class="comment">// protected static int trainThreshold = Integer.parseInt(System.getProperty(&quot;tomcat.util.buf.StringCache.trainThreshold&quot;, &quot;20000&quot;));</span></span><br><span class="line">                <span class="keyword">if</span> (bcCount &lt;= trainThreshold) &#123;</span><br><span class="line">                    ++bcCount;</span><br><span class="line">                    StringCache.<span class="type">ByteEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringCache</span>.ByteEntry();</span><br><span class="line">                    entry.value = value;</span><br><span class="line">                    <span class="type">int</span>[] count = (<span class="type">int</span>[])bcStats.get(entry);</span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> bc.getEnd();</span><br><span class="line">                        size = bc.getStart();</span><br><span class="line">                        entry.name = <span class="keyword">new</span> <span class="title class_">byte</span>[bc.getLength()];</span><br><span class="line">                        System.arraycopy(bc.getBuffer(), size, entry.name, <span class="number">0</span>, end - size);</span><br><span class="line">                        entry.charset = bc.getCharset();</span><br><span class="line">                        count = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>&#125;;</span><br><span class="line">                        bcStats.put(entry, count);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">var10002</span> <span class="operator">=</span> count[<span class="number">0</span>]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 这部分就是构建缓存的部分</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                    TreeMap&lt;Integer, ArrayList&lt;StringCache.ByteEntry&gt;&gt; tempMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line"></span><br><span class="line">                    StringCache.ByteEntry entry;</span><br><span class="line">                    ArrayList list;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">i$</span> <span class="operator">=</span> bcStats.entrySet().iterator(); i$.hasNext(); list.add(entry)) &#123;</span><br><span class="line">                        Entry&lt;StringCache.ByteEntry, <span class="type">int</span>[]&gt; item = (Entry)i$.next();</span><br><span class="line">                        entry = (StringCache.ByteEntry)item.getKey();</span><br><span class="line">                        <span class="type">int</span>[] countA = (<span class="type">int</span>[])item.getValue();</span><br><span class="line">                        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> countA[<span class="number">0</span>];</span><br><span class="line">                        list = (ArrayList)tempMap.get(count);</span><br><span class="line">                        <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">                            list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">                            tempMap.put(count, list);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    size = bcStats.size();</span><br><span class="line">                    <span class="keyword">if</span> (size &gt; cacheSize) &#123;</span><br><span class="line">                        size = cacheSize;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    StringCache.ByteEntry[] tempbcCache = <span class="keyword">new</span> <span class="title class_">StringCache</span>.ByteEntry[size];</span><br><span class="line">                    <span class="type">ByteChunk</span> <span class="variable">tempChunk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteChunk</span>();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="comment">// 这里缓存就构建完成了，缓存中只有 bcStats 里面的数据</span></span><br><span class="line">                        <span class="comment">// 换句话说，也就是只有排在前面请求的数据，后面请求中的数据并不会被缓存，仍然是 new String 的方式返回</span></span><br><span class="line">                        <span class="keyword">if</span> (n &gt;= size) &#123;</span><br><span class="line">                            bcCount = <span class="number">0</span>;</span><br><span class="line">                            bcStats.clear();</span><br><span class="line">                            bcCache = tempbcCache;</span><br><span class="line">                            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                                <span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                                log.debug(<span class="string">&quot;ByteCache generation time: &quot;</span> + (t2 - t1) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> tempMap.lastKey();</span><br><span class="line">                        list = (ArrayList)tempMap.get(key);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size() &amp;&amp; n &lt; size; ++i) &#123;</span><br><span class="line">                            StringCache.<span class="type">ByteEntry</span> <span class="variable">entry</span> <span class="operator">=</span> (StringCache.ByteEntry)list.get(i);</span><br><span class="line">                            tempChunk.setBytes(entry.name, <span class="number">0</span>, entry.name.length);</span><br><span class="line">                            <span class="type">int</span> <span class="variable">insertPos</span> <span class="operator">=</span> findClosest(tempChunk, tempbcCache, n);</span><br><span class="line">                            <span class="keyword">if</span> (insertPos == n) &#123;</span><br><span class="line">                                tempbcCache[n + <span class="number">1</span>] = entry;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.arraycopy(tempbcCache, insertPos + <span class="number">1</span>, tempbcCache, insertPos + <span class="number">2</span>, n - insertPos - <span class="number">1</span>);</span><br><span class="line">                                tempbcCache[insertPos + <span class="number">1</span>] = entry;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            ++n;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        tempMap.remove(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找缓存是否存在的函数，主要看 compare 函数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title function_">find</span><span class="params">(ByteChunk name)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> findClosest(name, bcCache, bcCache.length);</span><br><span class="line">    <span class="keyword">return</span> pos &gt;= <span class="number">0</span> &amp;&amp; compare(name, bcCache[pos].name) == <span class="number">0</span> &amp;&amp; name.getCharset().equals(bcCache[pos].charset) ? bcCache[pos].value : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">findClosest</span><span class="params">(ByteChunk name, StringCache.ByteEntry[] array, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compare(name, array[<span class="number">0</span>].name) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b + a &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> compare(name, array[i].name);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">                a = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                b = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(b - a != <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> compare(name, array[b].name);</span><br><span class="line">        <span class="keyword">if</span> (result2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要是判断 byte 数组中的数据是否相同</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(CharChunk name, <span class="type">char</span>[] compareTo)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] c = name.getBuffer();</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> name.getStart();</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> name.getEnd();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> compareTo.length;</span><br><span class="line">    <span class="keyword">if</span> (end - start &lt; len) &#123;</span><br><span class="line">        len = end - start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len &amp;&amp; result == <span class="number">0</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c[i + start] &gt; compareTo[i]) &#123;</span><br><span class="line">            result = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c[i + start] &lt; compareTo[i]) &#123;</span><br><span class="line">            result = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareTo.length &gt; end - start) &#123;</span><br><span class="line">            result = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compareTo.length &lt; end - start) &#123;</span><br><span class="line">            result = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toStringInternal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.charset == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.charset = DEFAULT_CHARSET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="built_in">this</span>.charset.decode(ByteBuffer.wrap(<span class="built_in">this</span>.buff, <span class="built_in">this</span>.start, <span class="built_in">this</span>.end - <span class="built_in">this</span>.start));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cb.array(), cb.arrayOffset(), cb.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，可以解释上述的奇怪现象了：</p>
<ul>
<li><p>环境刚重启，对于同个请求（参数一样），触发多次，也不会出现错误，但是运行一段时间后，可能就会报错</p>
<blockquote>
<p>原因：环境运行前期，请求数量少，还没达到构建缓存的阈值，请求参数的值都是通过 <code>new String</code> 返回的，因此能够获取到正常的值，功能运行正常。环境运行一段时间后，请求数量变多，达到构建缓存的阈值，触发缓存构建，部分参数值放在缓存中，后续触发请求时，是从缓存中获取的 <code>String</code> 对象，由于请求处理完毕后，业务代码会对 <code>String</code> 对象执行清零动作，所以后续的请求中从缓存获取到的对象是被清零后的 <code>String</code> 对象，从容导致无法解析报错。</p>
</blockquote>
</li>
<li><p>报错的请求，也不是全部报错，而是部分报错，即使同样是 <code>get</code> 请求，也是部分成功部分失败</p>
<blockquote>
<p>原因：并不是所有的请求参数值都会放到缓存中，只有长度小于某个值、参数值靠前的才会被放在缓存中，其他的不会从缓存中获取，都是直接 <code>new String</code> 的，因此对于不在缓存中的参数，其请求是正常的。</p>
</blockquote>
</li>
</ul>
<h1 id="问题修改"><a href="#问题修改" class="headerlink" title="问题修改"></a>问题修改</h1><p>基于上述分析，此问题主要是因为  <code>tomcat</code> 对请求参数 <code>String</code> 进行缓存，同时业务代码中又对 <code>String</code> 进行清零动作导致的，因此只需要破坏其中一个条件即可解决问题。</p>
<p>基于安全及性能的考虑，建议修改方案：</p>
<ul>
<li>前台：对于某些需要后台配合执行清零动作的接口，请求中增加时间戳参数（目的：保证 <code>String</code> 对象转 <code>byte</code> 数组是唯一的，这样就不会被缓存）</li>
<li>后台：基于请求参数，判断是否含有特定字段（前台加的时间戳参数，也标识着这是一个需要清零的接口），如果有则执行清零动作，否则不执行（目的：特殊数据不留内存，同时避免大范围新建对象对性能造成影响）</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>记录一次内存溢出（性能）问题的修改</title>
    <url>/a-oom-record/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近一段时间在修改一个内存溢出（性能）问题，由于过程比较反复、耗费时间比较久，所以有必要记录一下，为后续其他类似问题提供借鉴。</p>
<p>由于信息安全，此文无法提供真实的代码或截图，只能用文字大致描述。</p>
<span id="more"></span>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>组件提供一个 restful 接口，供外部调用，可以下载文件，文件以 zip 方式下载，大小不定，小则几 MB，大则 200 MB。</p>
<p>在内部实现这个接口时，需要调用另一个组件的接口，获得数据后进行相应的处理，提供下载。</p>
<p>原始的实现：调用另一个组件的接口，一次性将所有数据查询出来，然后进行处理，放入 StringBuilder 对象中，接着创建一个封装 ByteArrayOutputStream 流的 ZipOutputStream  流，将 StiringBuilder 中的数据写入压缩流中，最后返回一个 byte 数组用以构建下载文件。</p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>在调用下载接口时，小文件正常下载，大文件下载时会内存溢出。日志显示在 StringBuilder 的扩容时抛出 <code>java.lang.OutOfMemoryError:Java heap space</code> 异常。在调大堆内存后仍然出现此问题。</p>
<h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><h2 id="第一次修改"><a href="#第一次修改" class="headerlink" title="第一次修改"></a>第一次修改</h2><p>由于异常日志中显示是 StringBuilder 中扩容时申请不到内存导致堆内存溢出，所以直接的修改方案就是替换 StringBuilder 的写法：定义一个匿名内部类，重写输出流，并将流传入处理函数中，用这个流来构建ZipOutputStream  流，在获取到另一个组件传过来的数据后，分批写入压缩流中，最后将新建的匿名内部类的输出流传入 response 中进行下载。这样就避免了将数据写入 StringBuilder 的对象中。</p>
<p>验证结果，小文件下载正常，并发请求下载大文件时异常，日志显示<code>Read Time Out</code>，当时错误地认为是流开着时间太大导致超时被关闭，后面才发现是一个监控进程在重复10次无法得到应用的响应后，错误地认为 tomcat 挂掉，将其重启。</p>
<h2 id="第二次修改"><a href="#第二次修改" class="headerlink" title="第二次修改"></a>第二次修改</h2><p>由于第一次的修改验证结果中，，错误地认为是流开着时间太长导致，所以第二次修改时，将创建流的时间往后推迟，所以此处不再新建匿名内部类重写输出流，而是采用之前的方式创建一个封装 ByteArrayOutputStream 流的 ZipOutputStream 流。不过将此提前到查询另一个组件的数据前面，然后在查询得到数据后，分批直接写入流中。同样省去了构建大容量 StringBuilder 的操作。最后仍然返回一个 byte 数组传入 response 中进行下载。</p>
<p>验证结果，小文件下载正常，并发请求下载大文件时异常，无明显异常日志，tomcat 被重启。查看日志，发现在调用另一个组件的接口后并无日志输出，因此怀疑是在调用另一个组件的接口时出现问题。再次验证，同时查看所有日志输出和 CPU 使用率，证实确实是在调用另一个组件的接口时 tomcat 被重启。将此现象和调用代码反馈给另一个组件的同事，询问原因。得知是调用方式不对，此接口是一个分页查询接口，一次性查询 10000000 的数据容易使系统处于繁忙假死状态，也容易使内存耗尽。</p>
<p>在得知原因后，将接口查询方式改成分批查询。再次验证结果，小文件下载正常，并发请求下载大文件仍然异常，异常日志仍然显示堆内存溢出。只不过这次并不是这块功能代码报出的异常。在苦苦思索找不到原因后，请教另一个同事，走读代码分析发现，创建 ZipOutputStream 流底层是用 ByteArrayOutputStream 流，在将所有数据写入流后，函数最后一行返回的是一个 byte 数组，当数据量大时就容易将内存撑爆。</p>
<h2 id="第三次修改"><a href="#第三次修改" class="headerlink" title="第三次修改"></a>第三次修改</h2><p>经过第一次和第二次的折腾后，已经基本确定不能使用 ByteArrayOutputStream 流来创建 ZipOutputStream 流了，必须使用新建匿名内部类重写输出流的方式来创建 ZipOutputStream 流，同时分批查询另一个组件的数据并分批将处理后的数据写入压缩流中，最后将流传入 response 对象中进行文件下载。这算是结合第一次和第二次的修改吧。</p>
<p>验证结果，小文件下载正常，并发请求下载大文件，前期正常，后期下载文件内容缺失甚至失败，无明显异常日志，tomcat 被重启。再次探讨分析，查看堆内存使用情况，发现在压测时，堆内存使用率高达 99% 并长期居高不下。dump 堆存储快照进行分析，发现大量存活对象属于与另一个组件的接口交互的部分。联系另一个组件的同事进行分析，对此部分进行修改后，重新压测，功能正常，性能提升 40%。</p>
<h2 id="总修改点"><a href="#总修改点" class="headerlink" title="总修改点"></a>总修改点</h2><p>回顾整个过程，主要有以下的修改点：</p>
<ul>
<li>修改构造数据下载方式，由原先的先构造 StringBuilder 和 byte 数组再一次性写流的方式改成分批直接写流的方式，这是对解决堆内存溢出和性能提升的一个重要地方。</li>
<li>修改调用另一个组件的接口的查询方式，由原先的一次性查询大量数据的方式改成分批查询小数据量的方式，同时，修改了查询接口的注册方式。这是解决堆内存溢出的重要点。</li>
<li>对部分经常调用并需要加锁查询的数据，使用缓存获取</li>
<li>对 StringBuilder 的初始化，预判其长度并传入值初始化 StringBuilder 的长度，避免其多次扩容</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当分析堆内存溢出或性能问题时，可以结合以下的方式进行分析：</p>
<ul>
<li>在可能出现问题的地方加上日志，统计代码块耗时时长，以便发现性能瓶颈所在点</li>
<li>当程序“卡”住时，可以结合日志输出和使用 jstack 抓取堆栈进行分析，查看程序“卡”在哪里</li>
<li>当 CPU 使用率居高不下时，用 jstack 抓取堆栈，同时使用 <code>top -p &lt;pid&gt; -H</code> 查看各个子线程的 CPU 使用情况，将 CPU 使用率高的线程号（10进制）在堆栈（16进制，需要进行转换）中进行查找，可以分析是哪个线程的 CPU 占用率高</li>
<li>发生堆内存溢出时，日志记录的异常信息并不一定是出现问题的地方，有可能是其他功能代码产生大量对象长期占据内存不释放导致一些正常功能代码需要申请内存时却申请不到，从而抛出堆内存溢出的异常。此时可以将堆存储快照 dump 出来进行分析</li>
<li>当程序运行出现异常但是并没有明显的异常日志时，可以查看 CPU 使用率和堆内存使用情况，可能是由于堆内存使用率长期居高不下导致，此时可以将堆存储快照 dump 出来进行分析</li>
<li>对部分经常调用并需要加锁查询的数据，可以考虑使用缓存获取</li>
<li>对 StringBuilder 对象，如果能够预判其长度大小，可以在初始化时设置其长度，避免进行多次扩容操作</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>ant concat</title>
    <url>/ant-concat/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在项目中，因为一个问题需要修改某个大的文本文件（超过50MB），由于项目 git 中限制了文件不能超过 50MB，导致文件无法提交成功。此时需要将文件拆分成多个子文件，在打包时再合并成一个文件。由于项目中使用 ant 打包，自然就想到了用 ant 来解决这一问题。concat 标签就是用来合并文件或字符串的，刚好满足这个需求。</p>
<span id="more"></span>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>concat 有很多属性，主要用到的是 <code>destfile</code>、<code>encoding</code>、<code>outputencoding</code>、<code>fixlastline</code>、<code>eol</code>。</p>
<ul>
<li><code>destfile</code>，主要表示合并后输出的文件</li>
<li><code>encoding</code>，主要表示输入的文件的编码格式，默认是 JVM 的编码格式</li>
<li><code>outputencoding</code>，主要表示输出的文件的编码格式，默认是 JVM 的编码格式</li>
<li><code>fixlastline</code>，合并文件时有效，主要表示多个文件合并过程中处理完一个文件后是否添加新的一行</li>
<li><code>eol</code>，与 <code>fixlastline</code> 结合使用，主要表示合并文件中添加一行的内容。主要有：<code>cr</code>、<code>lf</code>、<code>crlf</code>、<code>mac</code>、<code>unix</code>、<code>dos</code>。默认会随操作系统类型进行设置，如 dos 操作系统添加 <code>crlf</code> ，unix 操作系统添加 <code>lf</code>。</li>
</ul>
<p>其他属性的使用及解释参考官网：<a href="http://ant.apache.org/manual/index.html">http://ant.apache.org/manual/index.html</a></p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>假设在 test 目录下有两个文件：a.txt、b.txt，其内容如下</p>
<p>a.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1，北京</span><br><span class="line">2，上海</span><br><span class="line">3，广州</span><br><span class="line">4，深圳</span><br></pre></td></tr></table></figure>

<p>b.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5，杭州</span><br><span class="line">6，武汉</span><br><span class="line">7，天津</span><br><span class="line">8，重庆</span><br></pre></td></tr></table></figure>

<p>现在要将两个文件的内容合并成一个文件 c.txt，则可以编写如下构建脚本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">&quot;testAntConcat&quot;</span> <span class="attr">default</span>=<span class="string">&quot;build&quot;</span> <span class="attr">basedir</span>=<span class="string">&quot;.&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;build&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">concat</span> <span class="attr">fixlastline</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">destfile</span>=<span class="string">&quot;c.txt&quot;</span> <span class="attr">encoding</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">outputencoding</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">&quot;test&quot;</span> <span class="attr">includes</span>=<span class="string">&quot;*.txt&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">concat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果会生成一个 c.txt 文件，内容如下，刚好是 a.txt 和 b.txt 文件的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1，北京</span><br><span class="line">2，上海</span><br><span class="line">3，广州</span><br><span class="line">4，深圳</span><br><span class="line">5，杭州</span><br><span class="line">6，武汉</span><br><span class="line">7，天津</span><br><span class="line">8，重庆</span><br></pre></td></tr></table></figure>

<p>有几个需要注意的地方。第一，在脚本中，<code>fixlastline=&quot;yes&quot;</code> 是必须的，否则合并文件后不会换行，会出现如下的情况，至于新增的换行符，使用默认的即可，ant 会根据系统自行添加。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1，北京</span><br><span class="line">2，上海</span><br><span class="line">3，广州</span><br><span class="line">4，深圳5，杭州</span><br><span class="line">6，武汉</span><br><span class="line">7，天津</span><br><span class="line">8，重庆</span><br></pre></td></tr></table></figure>

<p>第二，<code>encoding=&quot;utf-8&quot;</code>、<code> outputencoding=&quot;utf-8&quot;</code> 这两个属性也是必须的，否则合并文件后会出现乱码，因为包含中文，如果不包含中文，只有数字和字母，没有这两个属性也可以。</p>
<p>总体而言，concat 还是比较简单的，参考官网的说明，写个简单例子验证一下，就能正确运用到项目中了。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>ant使用指导：<a href="http://ant.apache.org/manual/index.html">http://ant.apache.org/manual/index.html</a></p>
]]></content>
      <categories>
        <category>ant</category>
      </categories>
      <tags>
        <tag>ant</tag>
      </tags>
  </entry>
  <entry>
    <title>ant条件判断</title>
    <url>/ant-condition/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ant是一种常用的打包构建工具，支持在构建过程中根据属性值判断选择构建的的步骤，本文将以condition中的equals标签为例，说明ant中的条件判断的用法。</p>
<span id="more"></span>

<h1 id="简单属性条件判断"><a href="#简单属性条件判断" class="headerlink" title="简单属性条件判断"></a>简单属性条件判断</h1><p>简单属性的条件判断是在target标签中增加 if 元素判断，且判断的依据是 if 元素中的属性是否设置了值，如果设置了值，不管值是什么内容（即使是false），都会执行该target，如果没有设置该值，则不执行该target。需要注意的是，在target中的条件判断只能是一个，如果需要多个条件判断，需要将其写在condition标签中，然后将condition标签绑定在一个属性中，再用这个属性写在target中进行判断。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;targetName&quot;</span> <span class="attr">if</span>=<span class="string">&quot;propertionCondition&quot;</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中propertionCondition是一个属性的名称</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>以下例子中，有三个判断：isTrue属性，isWindows属性，isRed属性。</p>
<ul>
<li>isTrue属性：由于isTrue属性设置了值false，所以在<code>&lt;target name=&quot;propertyTrue&quot; if=&quot;isTrue&quot;&gt;</code>的判断中，其为真，会执行该target</li>
<li>isWindows属性：由于os属性的值为windows，故<code>&lt;equals arg1=&quot;windows&quot; arg2=&quot;$&#123;os&#125;&quot; /&gt;</code>条件成立，给isWindows属性设置了值，默认是true（从windows的target执行输出结果可以证实），所以在<code>&lt;target name=&quot;windows&quot; if=&quot;isWindows&quot;&gt;</code>的判断中，条件成立，会执行windows的target。而在<code>&lt;target name=&quot;notWindows&quot; unless=&quot;isWindows&quot;&gt;</code>的判断中，条件不成立，不会执行notWindows的target</li>
<li>isRed属性：由于color属性的值为green，故<code>&lt;equals arg1=&quot;red&quot; arg2=&quot;$&#123;color&#125;&quot; /&gt;</code>条件不成立，不会给isRed属性设置值（从notRed的target的执行输出结果可以证实），所以在<code>&lt;target name=&quot;red&quot; if=&quot;isRed&quot;&gt;</code>的判断中，条件不成立，不会执行red的target。而在<code>&lt;target name=&quot;notRed&quot; unless=&quot;isRed&quot;&gt;</code>的判断中，条件成立，执行notRed的target</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">&quot;testAntCondition&quot;</span> <span class="attr">default</span>=<span class="string">&quot;build&quot;</span> <span class="attr">basedir</span>=<span class="string">&quot;.&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;os&quot;</span> <span class="attr">value</span>=<span class="string">&quot;windows&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;green&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;isTrue&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 如果arg1和arg2相等，则设置isWindows的值（默认是true），否则不设置值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">condition</span> <span class="attr">property</span>=<span class="string">&quot;isWindows&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">equals</span> <span class="attr">arg1</span>=<span class="string">&quot;windows&quot;</span> <span class="attr">arg2</span>=<span class="string">&quot;$&#123;os&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">condition</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 如果arg1和arg2相等，则设置isRed的值（默认是true），否则不设置值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">condition</span> <span class="attr">property</span>=<span class="string">&quot;isRed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">equals</span> <span class="attr">arg1</span>=<span class="string">&quot;red&quot;</span> <span class="attr">arg2</span>=<span class="string">&quot;$&#123;color&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">condition</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 此种if写法判断的是属性是否有设置值，如果设置了值，不管是什么值都会执行，不设置值则不执行设置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 由于isTrue设置了值（虽然是false），此时条件成立，所以这个target会被执行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;propertyTrue&quot;</span> <span class="attr">if</span>=<span class="string">&quot;isTrue&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;This is a target which name is propertyTrue&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;The isTrue value is $&#123;isTrue&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- isWindows设置了值，是true，所以，windows会执行，notWindows不会执行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;windows&quot;</span> <span class="attr">if</span>=<span class="string">&quot;isWindows&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;This is a target which name is windows&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;The isWindows value is $&#123;isWindows&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;notWindows&quot;</span> <span class="attr">unless</span>=<span class="string">&quot;isWindows&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;This is a target which name is notWindows&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;The isWindows value is $&#123;isWindows&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- isRed没有设置值，所以，notRed会执行，red不会执行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;red&quot;</span> <span class="attr">if</span>=<span class="string">&quot;isRed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;This is a target which name is red&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;The isRed value is $&#123;isRed&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;notRed&quot;</span> <span class="attr">unless</span>=<span class="string">&quot;isRed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;This is a target which name is notRed&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;The isRed value is $&#123;isRed&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;build&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">&quot;propertyTrue&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">&quot;windows&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">&quot;notWindows&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">&quot;red&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">&quot;notRed&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/antSimpleCondition.png" alt="ant简单属性条件判断输出结果"></p>
<h1 id="扩展属性条件判断"><a href="#扩展属性条件判断" class="headerlink" title="扩展属性条件判断"></a>扩展属性条件判断</h1><p>扩展属性的条件判断是在target标签中增加 if 元素判断，且判断的依据是 if 元素中的属性值是否是true，如果是true，则执行该target，否则不执行该target（不一定设置属性值是false，只要不是true的其他值都可以）。需要注意的是，在target中的条件判断只能是一个，如果需要多个条件判断，需要将其写在condition标签中，然后将condition标签绑定在一个属性中，再用这个属性写在target中进行判断。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;targetName&quot;</span> <span class="attr">if</span>=<span class="string">&quot;$&#123;propertionCondition&#125;&quot;</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中propertionCondition是一个属性的名称</p>
<h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p>以下例子中，有三个判断：isTrue属性，isWindows属性，isRed属性。</p>
<ul>
<li>isTrue属性：由于isTrue属性设置了值false，所以在<code>&lt;target name=&quot;propertyTrue&quot; if=&quot;isTrue&quot;&gt;</code>的判断中，条件不成立，不会执行该target</li>
<li>isWindows属性：由于os属性的值为windows，故<code>&lt;equals arg1=&quot;windows&quot; arg2=&quot;$&#123;os&#125;&quot; /&gt;</code>条件成立，给isWindows属性设置值为true（从windows的target执行输出结果可以证实），所以在<code>&lt;target name=&quot;windows&quot; if=&quot;isWindows&quot;&gt;</code>的判断中，条件成立，会执行windows的target。而在<code>&lt;target name=&quot;notWindows&quot; unless=&quot;isWindows&quot;&gt;</code>的判断中，条件不成立，不会执行notWindows的target</li>
<li>isRed属性：由于color属性的值为green，故<code>&lt;equals arg1=&quot;red&quot; arg2=&quot;$&#123;color&#125;&quot; /&gt;</code>条件不成立，给isRed属性设置值为false（从notRed的target的执行输出结果可以证实），所以在<code>&lt;target name=&quot;red&quot; if=&quot;isRed&quot;&gt;</code>的判断中，条件不成立，不会执行red的target。而在<code>&lt;target name=&quot;notRed&quot; unless=&quot;isRed&quot;&gt;</code>的判断中，条件成立，执行notRed的target</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">&quot;testAntCondition&quot;</span> <span class="attr">default</span>=<span class="string">&quot;build&quot;</span> <span class="attr">basedir</span>=<span class="string">&quot;.&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;os&quot;</span> <span class="attr">value</span>=<span class="string">&quot;windows&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;green&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;isTrue&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 如果arg1和arg2相等，则设置isWindows的值为true，否则设置为false --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">condition</span> <span class="attr">property</span>=<span class="string">&quot;isWindows&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> <span class="attr">else</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">equals</span> <span class="attr">arg1</span>=<span class="string">&quot;windows&quot;</span> <span class="attr">arg2</span>=<span class="string">&quot;$&#123;os&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">condition</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 如果arg1和arg2相等，则设置isRed的值为true，否则设置为false --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">condition</span> <span class="attr">property</span>=<span class="string">&quot;isRed&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> <span class="attr">else</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">equals</span> <span class="attr">arg1</span>=<span class="string">&quot;red&quot;</span> <span class="attr">arg2</span>=<span class="string">&quot;$&#123;color&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">condition</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 此种if写法判断的是属性值是否是true，如果属性值是true则执行，否则不执行 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 由于isTrue是false，此时条件不成立，所以这个target不会被执行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;propertyTrue&quot;</span> <span class="attr">if</span>=<span class="string">&quot;$&#123;isTrue&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;This is a target which name is propertyTrue&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;The isTrue value is $&#123;isTrue&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- isWindows属性值是true，所以，windows会执行，notWindows不会执行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;windows&quot;</span> <span class="attr">if</span>=<span class="string">&quot;$&#123;isWindows&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;This is a target which name is windows&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;The isWindows value is $&#123;isWindows&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;notWindows&quot;</span> <span class="attr">unless</span>=<span class="string">&quot;$&#123;isWindows&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;This is a target which name is notWindows&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;The isWindows value is $&#123;isWindows&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- isRed属性值是false，所以，notRed会执行，red不会执行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;red&quot;</span> <span class="attr">if</span>=<span class="string">&quot;$&#123;isRed&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;This is a target which name is red&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;The isRed value is $&#123;isRed&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;notRed&quot;</span> <span class="attr">unless</span>=<span class="string">&quot;$&#123;isRed&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;This is a target which name is notRed&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;The isRed value is $&#123;isRed&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;build&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">&quot;propertyTrue&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">&quot;windows&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">&quot;notWindows&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">&quot;red&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">&quot;notRed&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/antExpansionsCondition.png" alt="ant扩展属性条件判断输出结果"></p>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>简单属性条件判断和扩展属性条件判都能让target根据一定条件选择是否执行该target，两者的目的和效果都一样，限制条件也一样：一个target只能有一个条件判断。唯一不同的是简单属性条件判断中的 if 元素写的是属性，而且是判断属性是否设置了值；而扩展属性条件判断中的 if 元素写的是属性值，而且是判断属性值是否是true。相比而言，简单属性条件判断比较简单，但是扩展属性条件判断更加灵活也更加容易理解。所以建议是使用中选择扩展属性条件判断方式。</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p>ant中支持的条件判断：<a href="http://ant.apache.org/manual/Tasks/conditions.html">http://ant.apache.org/manual/Tasks/conditions.html</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>ant使用指导：<a href="http://ant.apache.org/manual/index.html">http://ant.apache.org/manual/index.html</a></p>
]]></content>
      <categories>
        <category>ant</category>
      </categories>
      <tags>
        <tag>ant</tag>
      </tags>
  </entry>
  <entry>
    <title>ant 类函数调用功能</title>
    <url>/ant-function/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ant 是一种打包脚本语言，能极大地方便程序的编译打包工作。但是在平常的开发过程中，经常会遇到一些打包流程，除了一小部分不一样，其他都是一样的。这种情况在编程语言中一般会通过抽取调用函数来减少重复代码，但是在 ant 中并没有函数这种功能。那应该如何来减少重复的代码呢？本文将通过宏定义 <code>macrodef</code> 和 <code>antcall</code> 两种方式来实现 ant 中类似函数的功能。</p>
<span id="more"></span>

<h1 id="宏定义-macrodef"><a href="#宏定义-macrodef" class="headerlink" title="宏定义 macrodef"></a>宏定义 macrodef</h1><p>宏定义的方式主要是通过在宏内部定义变量，并将主体的实现放在 <code>sequential</code> 块中来实现的。其格式如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义宏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">macrodef</span> <span class="attr">name</span>=<span class="string">&quot;macroName&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义宏属性，值由调用宏的地方传入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;attributeName&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- 宏主体实现内容，此处可通过 @&#123;attributeName&#125; 获取传入的 attributeName 变量的值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequential</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequential</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">macrodef</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 调用宏, macroName 是定义的宏的 name 属性的值，attributeName 是宏内部定义的属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">macroName</span> <span class="attr">attributeName</span>=<span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">macroName</span> <span class="attr">attributeName</span>=<span class="string">&quot;...&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个简单的例子如下，假设有多个打包任务，除了打包的路径和打包的名字不同，其他步骤是一样的，此时使用宏定义实现的代码如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">&quot;testFunction&quot;</span> <span class="attr">default</span>=<span class="string">&quot;build&quot;</span> <span class="attr">basedir</span>=<span class="string">&quot;.&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">macrodef</span> <span class="attr">name</span>=<span class="string">&quot;package&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;srcDir&quot;</span> <span class="attr">default</span>=<span class="string">&quot;defaultDir&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;packageName&quot;</span> <span class="attr">default</span>=<span class="string">&quot;defaultName&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">sequential</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;====================================&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;prepare making a package in source code directory @&#123;srcDir&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;making a package with name @&#123;packageName&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;clean the environment after making a package&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sequential</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">macrodef</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;build&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">srcDir</span>=<span class="string">&quot;temp&quot;</span> <span class="attr">packageName</span>=<span class="string">&quot;tempName&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">srcDir</span>=<span class="string">&quot;release&quot;</span> <span class="attr">packageName</span>=<span class="string">&quot;releaseName&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>程序输出如下</p>
<p><img src="/images/ant-function-macrodef-output.png" alt="宏定义输出"></p>
<h1 id="antcall"><a href="#antcall" class="headerlink" title="antcall"></a>antcall</h1><p>antcall 的方式主要是在调用 target 时可以主动传入 param 属性，在这个属性标签中可以为相应的属性设置特定的值。其格式如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 需要被重复调用的 target 定义，内部实现可以用 $&#123;paramName&#125; 来获取传入的 paramName 的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;targetName&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 重复调用其他的 target --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;build&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">&quot;targetName&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;param1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;param2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value2&quot;</span>/&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">antcall</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">&quot;targetName&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;param1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value1111&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;param2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value2222&quot;</span>/&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">antcall</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个简单的例子如下，为了便于比较，此例子实现的功能跟宏定义 macrodef 中的例子一样：有多个打包任务，除了打包的路径和打包的名字不同，其他步骤是一样的。代码如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">&quot;testFunction&quot;</span> <span class="attr">default</span>=<span class="string">&quot;build&quot;</span> <span class="attr">basedir</span>=<span class="string">&quot;.&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;package&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 为 srcDir 和 packageName 设置默认值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;srcDir&quot;</span> <span class="attr">value</span>=<span class="string">&quot;defaultDir&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;packageName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;defaultName&quot;</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;====================================&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;prepare making a package in source code directory $&#123;srcDir&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;making a package with name $&#123;packageName&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;clean the environment after making a package&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">&quot;build&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">&quot;package&quot;</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">&quot;package&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;srcDir&quot;</span> <span class="attr">value</span>=<span class="string">&quot;temp&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;packageName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tempName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">antcall</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">&quot;package&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;srcDir&quot;</span> <span class="attr">value</span>=<span class="string">&quot;release&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;packageName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;releaseName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">antcall</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>程序输出如下</p>
<p><img src="/images/ant-function-antcall-output.png" alt="antcall 输出"></p>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>宏定义和 antcall 两种方式都能减少重复的代码，实现类似函数调用的功能。两者各有优缺点：宏定义需要在内部额外定义需要传入的属性名称，同时可以为这个属性却设置默认值，在调用宏定义时代码相对而言比较少，看起来也比较清晰；相对而言，antcall 的重复调用的 target 跟其他普通的 target 并没有区别，这相对比较简单，只是在调用的地方需要通过 <code>param</code> 标签来指定每个属性的名称和值，在参数多的时候，这很容易造成代码的不雅观，而且当需要为属性设置默认值时，需要额外通过 <code>property</code> 标签进行设值。</p>
]]></content>
      <categories>
        <category>ant</category>
      </categories>
      <tags>
        <tag>ant</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/automation/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>AC 自动机是一种多模式字符串匹配算法，其能在 <code>O(n)</code> 的时间复杂度内完成对多个子字符串的查找，而且其时间复杂度只跟搜索串的长度有关，跟模式串的数量并无关联。是一种高效的字符串匹配算法。</p>
<span id="more"></span>

<h1 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h1><p>AC自动机算法，主要包括预处理过程和查找过程。</p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>预处理过程主要是构建字典树，同时加入 <code>fail</code> 指针，用于在某个节点匹配失败时进行跳转，避免从根节点重新进行匹配，从而达到快速匹配多个子串的效果。其算法基本过程如下：</p>
<ul>
<li>根据输入的模式串，构建字典树。在构建字典树的过程中，如果从根节点到某个节点的路径完全匹配上模式串，则将这个模式串的长度加入节点的存储信息中（用于后续搜索匹配时能还原出匹配到的模式串）。</li>
<li>使用广搜算法，依次构建每个节点的失败指针指向。</li>
</ul>
<p>关于节点的失败指针，可以说是AC自动机算法中的一个难点，也是一个很重要的部分。由于失败指针的加入，在节点匹配失败时，不用重新从根节点出发进行查找，可以直接跳到失败指针指向的节点进行下一步查找，从而减少搜索路径，大大提高搜索效率。</p>
<h3 id="失败指针"><a href="#失败指针" class="headerlink" title="失败指针"></a>失败指针</h3><p>对于失败指针，其定义是在发生匹配失败时进行的跳转。假设节点 <code>cur</code> 的失败指针指向的节点为 <code>fail</code>，从根节点到 <code>fail</code> 节点的路径组成的字符串 <code>suffix</code>，从根节点到 <code>cur</code> 节点的路径组成的字符串 <code>string</code>，则必然满足：<code>suffix</code> 是 <code>string</code> 的最长后缀（如果字符串只有一个字符，则最长后缀为空）。</p>
<p>关于节点的失败指针的构建，其算法如下：</p>
<ul>
<li>根节点的的失败指针为空</li>
<li>对于非根节点 <code>current</code>，获取父亲节点的失败指针指向的节点 <code>temp</code><ul>
<li>如果 <code>temp</code> 为空，则将 <code>current</code> 节点的失败指针指向根节点。</li>
<li>如果 <code>temp</code> 节点和 <code>current</code> 节点的父节点有相同的转移路径（即能够匹配某个相同的字符），则将 <code>current</code> 的失败指针指向 <code>temp</code> 对应的孩子节点上。</li>
<li>如果 <code>temp</code> 节点没有与 <code>current</code> 节点父节点具有相同的转移路径，则继续获取 <code>temp</code> 节点的失败指针指向的节点，将其赋值给 <code>temp</code>，重复上述匹配过程。</li>
</ul>
</li>
<li>在构建节点的失败指针时，如果失败指针指向的节点存在匹配模式串的记录信息（记录了模式串的长度），则将这个信息加入到当前节点中。这个做法是为了方便后续根据搜索串查找相应的匹配串。</li>
</ul>
<p>现在说明上述算法为什么有效。</p>
<p>假设当前节点是 <code>current</code>，当前节点的父节点是 <code>father</code>，父节点的失败指针指向的节点是 <code>fatherFail</code>。则根据失败指针的定义，可以知道，<code>fatherFail</code> 构成的字符串是 <code>father</code>构成的字符串的最长后缀。</p>
<ul>
<li><p>如果 <code>fatherFail</code> 存在一个跳转路径 <code>fp</code>与 <code>father</code> 的跳转路径（从 <code>father</code> 跳转到 <code>current</code>） <code>cp</code> 相同，则说明 <code>fatherFail + fp</code> 构成的字符串是 <code>father + cp</code> 构成的字符串（也是 <code>current</code> 构成的字符串）的最长后缀。即 <code>current</code> 的失败指针指向了 <code>fp</code> 的节点。如下所示</p>
<p><img src="https://guozhchun.github.io/images/automation-1.png" alt="automation-1"></p>
</li>
<li><p>如果上述路径不存在，则查找 <code>fatherFail</code> 的失败指针指向的节点，此时代表的是 <code>fatherFail</code> 路径的最长后缀，同样是 <code>father</code> 的后缀，也是 <code>father</code> 的次最长后缀，如下所示</p>
<p><img src="https://guozhchun.github.io/images/automation-2.png" alt="automation-2"></p>
<p>同样按照第一点进行匹配，如果仍然匹配不到，则继续第二点依次取出当前的失败指针指向的节点的失败指针指向的节点，逐渐缩小最长后缀的范围直到匹配上或为空（无匹配记录）。</p>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>上述描述有点抽象，不好理解，现在举一个例子加以说明，辅助理解。</p>
<p>假设有模式串 <code>he</code>、<code>she</code>、<code>hers</code>、<code>his</code>、<code>shy</code>，则其字典树构建结果如下</p>
<p><img src="https://guozhchun.github.io/images/automation-3.png" alt="automation-3"></p>
<p>图中 <code>4</code>、<code>8</code>、<code>9</code>、<code>10</code>、<code>11</code> 五个节点与其他节点颜色不同，主要是想表示这五个节点组成的路径字符串是一个模式串，旁边标识的 <code>wordLength</code> 的数字表示的是模式串的长度。</p>
<p>接下来对每个节点构建失败指针，用虚线表示。 <code>root</code> 节点的失败指针为空，在图中不表示。</p>
<p> <code>2</code> 号节点，其父节点是 <code>root</code>，父节点的失败指针为空，所以 <code>2</code> 号节点的失败指针指向 <code>root</code> 节点</p>
<p><img src="https://guozhchun.github.io/images/automation-4.png" alt="automation-4"></p>
<p><code>3</code> 号节点，其父节点是 <code>root</code>，父节点的失败指针为空，所以 <code>3</code> 号节点的失败指针指向 <code>root</code> 节点</p>
<p><img src="https://guozhchun.github.io/images/automation-5.png" alt="automation-5"></p>
<p><code>4</code> 号节点，其父节点是 <code>2</code>  节点，<code>2</code> 节点的失败指针指向 <code>root</code>，<code>root</code> 没有 <code>e</code> 的跳转路径，所以继续查找父节点 <code>2</code> 的失败指针节点 <code>root</code>  的失败指针，由于其指向空，所以 <code>4</code> 节点的失败指针指向 <code>root</code> 节点</p>
<p><img src="https://guozhchun.github.io/images/automation-6.png" alt="automation-6"></p>
<p><code>5</code> 号节点，其父节点是 <code>2</code>  节点，<code>2</code> 节点的失败指针指向 <code>root</code>，<code>root</code> 没有 <code>i</code> 的跳转路径，所以继续查找父节点 <code>2</code> 的失败指针节点 <code>root</code>  的失败指针，由于其指向空，所以 <code>5</code> 节点的失败指针指向 <code>root</code> 节点</p>
<p><img src="https://guozhchun.github.io/images/automation-7.png" alt="automation-7"></p>
<p><code>6</code> 号节点，其父节点是 <code>3</code> 节点，<code>3</code> 节点的失败指针指向 <code>root</code>，<code>root</code> 节点有 <code>h</code> 的跳转路径到 <code>2</code> 号节点，所以 <code>6</code> 号节点的失败指针指向 <code>2</code> 号节点</p>
<p><img src="https://guozhchun.github.io/images/automation-8.png" alt="automation-8"></p>
<p><code>7</code> 号节点，其父节点是 <code>4</code> 节点，<code>4</code> 节点的失败指针指向 <code>root</code>，<code>root</code> 没有 <code>r</code> 的跳转路径，所以继续查找父节点 <code>4</code> 的失败指针节点 <code>root</code>  的失败指针，由于其指向空，所以 <code>7</code> 节点的失败指针指向 <code>root</code> 节点</p>
<p><img src="https://guozhchun.github.io/images/automation-9.png" alt="automation-9"></p>
<p><code>8</code> 号节点，其父节点是 <code>5</code> 节点，<code>5</code> 节点的失败指针指向 <code>root</code>，<code>root</code> 节点有 <code>s</code> 的跳转路径到 <code>3</code> 号节点，所以 <code>8</code> 号节点的失败指针指向 <code>3</code> 号节点</p>
<p><img src="https://guozhchun.github.io/images/automation-10.png" alt="automation-10"></p>
<p><code>9</code> 号节点，其父节点是 <code>6</code> 节点，<code>6</code> 节点的失败指针指向 <code>2</code> 节点，<code>2</code> 节点有 <code>e</code> 的跳转路径到 <code>4</code> 号节点，所以 <code>9</code> 号节点的失败指针指向 <code>4</code> 号节点。<strong>同时，由于 <code>4</code> 号节点存在 <code>wordLength</code> （即 <code>4</code> 号节点组成的路径能够构成某部分模式串），所以将 <code>4</code> 号节点的 <code>wordLength</code> 信息加入到 <code>9</code> 号节点的 <code>wordLength</code> 中</strong></p>
<p><img src="https://guozhchun.github.io/images/automation-11.png" alt="automation-11"></p>
<p><code>10</code> 号节点，其父节点是 <code>6</code> 节点，<code>6</code> 节点 失败指针指向 <code>2</code> 节点，<code>2</code> 节点没有 <code>y</code> 的跳转路径，所以继续寻找 <code>2</code> 的失败指针节点，跳转到 <code>root</code> 节点，<code>root</code> 节点没有 <code>y</code> 的跳转路径，继续寻找 <code>root</code> 的失败指针节点，为空，所以 <code>10</code> 号节点的失败指针指向 <code>root</code> 节点</p>
<p><img src="https://guozhchun.github.io/images/automation-12.png" alt="automation-12"></p>
<p><code>11</code> 号节点，其父节点是 <code>7</code> 节点，<code>7</code> 节点的失败指针指向 <code>root</code>，<code>root</code> 节点有 <code>s</code> 的跳转路径到 <code>3</code> 号节点，所以 <code>11</code> 号节点的失败指针指向 <code>3</code> 号节点</p>
<p><img src="https://guozhchun.github.io/images/automation-13.png" alt="automation-13"></p>
<p>至此，节点的失败指针构建完毕。同时也完成了AC自动机的预处理过程。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>节点信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AcNode</span></span><br><span class="line">&#123;</span><br><span class="line">    AcNode[] children = <span class="keyword">new</span> <span class="title class_">AcNode</span>[<span class="number">128</span>];</span><br><span class="line">    AcNode failNode;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; wordLengthList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造字典树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">AcNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        AcNode[] children = current.children;</span><br><span class="line">        <span class="keyword">if</span> (children[word.charAt(i)] == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            children[word.charAt(i)] = <span class="keyword">new</span> <span class="title class_">AcNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        current = children[word.charAt(i)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current.wordLengthList.add(word.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造失败指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildFailPath</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue&lt;AcNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">AcNode</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        AcNode[] children = current.children;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; children.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (children[i] == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">AcNode</span> <span class="variable">temp</span> <span class="operator">=</span> current.failNode;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="literal">null</span> &amp;&amp; temp.children[i] == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = temp.failNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                children[i].failNode = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                children[i].failNode = temp.children[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            children[i].wordLengthList.addAll(children[i].failNode.wordLengthList);</span><br><span class="line">            queue.offer(children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h2><p>搜索过程，先按字典树的查找过程进行匹配，如果在某个节点匹配失败，则运用失败指针跳转到下一个节点继续进行匹配。当搜索到某个节点时，如果该节点存储了模式串的信息（模式串的长度），对进行处理（输出），否则不额外处理。</p>
<p>由于搜索过程中是遍历搜索串的每个字符，能获取到下标信息，根据当前下标和存储的长度就能截取出模式串，所以在预处理的过程中不是存储的模式串，而是存储长度。这样也能节省空间。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>假设对上述模式串构建的 AC 自动机对 <code>ahishers</code> 字符串进行搜索，其搜索过程如下，绿色节点表示当前搜索的节点</p>
<p>首先，匹配 <code>a</code> 字符，由于 <code>root</code> 没有 <code>a</code> 的跳转路径，同时其失败指针为空，所以当前节点仍然停留在 <code>root</code> 上</p>
<p><img src="https://guozhchun.github.io/images/automation-14.png" alt="automation-14"></p>
<p>搜索匹配 <code>h</code> 字符，由于 <code>root</code> 有 <code>h</code> 的跳转路径，所以当前节点移动到 <code>2</code> 号节点上。由于 <code>2</code> 号节点并没有存储模式串的信息，所以直接进入下一个字符的匹配</p>
<p><img src="https://guozhchun.github.io/images/automation-15.png" alt="automation-15"></p>
<p>搜索匹配 <code>i</code> 字符，由于 <code>2</code> 号节点有 <code>i</code> 的跳转路径，所以当前节点移动到 <code>5</code> 号节点上</p>
<p><img src="https://guozhchun.github.io/images/automation-16.png" alt="automation-16"></p>
<p>搜索匹配 <code>s</code> 字符，由于 <code>5</code> 号节点有 <code>i</code> 的跳转路径，所以当前节点移动到 <code>8</code> 号节点上。同时，由于 <code>8</code> 号节点存储了模式串的信息，所以在此处进行额外处理，输出模式串 <code>his</code></p>
<p><img src="https://guozhchun.github.io/images/automation-17.png" alt="automation-17"></p>
<p>搜索匹配 <code>h</code> 字符，由于 <code>8</code> 号节点没有跳转路径 <code>h</code>，所以顺着 <code>8</code> 号节点的失败指针转移到节点 <code>3</code> ，由于节点 <code>3</code> 有跳转路径 <code>h</code>，所以当前节点移动到 <code>6</code> 号节点上</p>
<p><img src="https://guozhchun.github.io/images/automation-18.png" alt="automation-18"></p>
<p><img src="https://guozhchun.github.io/images/automation-19.png" alt="automation-19"></p>
<p>搜索匹配 <code>e</code> 字符，由于 <code>6</code> 号节点有 <code>e</code> 的跳转路径，所以当前节点移动到 <code>9</code> 号节点上。同时，由于 <code>9</code> 号节点存储了模式串的信息，所以在此处进行额外处理，输出模式串 <code>she</code>、<code>he</code></p>
<p><img src="https://guozhchun.github.io/images/automation-20.png" alt="automation-20"></p>
<p>搜索匹配 <code>r</code> 字符，由于 <code>9</code> 号节点没有跳转路径 <code>r</code> ，所以顺着 <code>9</code> 号节点的失败指针转移到 <code>4</code> 号节点。<strong>此处需要注意：虽然 <code>4</code> 号节点存储了模式串的信息，但是访问到 <code>4</code> 号节点并不是“正常”路径访问，是通过失败指针访问的。在构建失败指针的过程中，已经将 <code>4</code> 号节点的相关信息存储在 <code>9</code> 号节点上，因此通过失败指针跳转的，必然经过 <code>9</code> 号节点处理输出模式串，此处不用重复处理</strong>。由于 <code>4</code> 号节点有跳转路径 <code>r</code>，所以当前节点移动到 <code>7</code> 号节点上</p>
<p><img src="https://guozhchun.github.io/images/automation-21.png" alt="automation-21"></p>
<p><img src="https://guozhchun.github.io/images/automation-22.png" alt="automation-22"></p>
<p>搜索匹配 <code>s</code> 字符，由于 <code>7</code> 号节点有 <code>s</code> 跳转路径，所以当前节点移动到 <code>11</code> 号节点上。同时，由于 <code>11</code> 号节点存储了模式串信息，所以在此处进行额外处理，输出模式串 <code>hers</code></p>
<p><img src="https://guozhchun.github.io/images/automation-23.png" alt="automation-23"></p>
<p>至此，搜索结束，总共找到输出四个模式串 <code>his</code>、<code>she</code>、<code>he</code>、<code>hers</code></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(String word)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">AcNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">        <span class="type">AcNode</span> <span class="variable">next</span> <span class="operator">=</span> current.children[ch];</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            current = next;</span><br><span class="line">            <span class="comment">// 此处是要先判断当前节点是否存储了模式串的信息，如果存储了，才进行操作</span></span><br><span class="line">            <span class="comment">// 此处将这个判断放在函数中</span></span><br><span class="line">            handleMatchWords(current, word, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            next = current.failNode;</span><br><span class="line">            <span class="keyword">while</span> (next != <span class="literal">null</span> &amp;&amp; next.children[ch] == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                next = next.failNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                current = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                current = next.children[ch];</span><br><span class="line">                <span class="comment">// 此处是要先判断当前节点是否存储了模式串的信息，如果存储了，才进行操作</span></span><br><span class="line">            	<span class="comment">// 此处将这个判断放在函数中</span></span><br><span class="line">                handleMatchWords(current, word, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h1><p>整个 AC 自动机的构建和搜索样例代码如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Automation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AcNode</span></span><br><span class="line">    &#123;</span><br><span class="line">        AcNode[] children = <span class="keyword">new</span> <span class="title class_">AcNode</span>[<span class="number">128</span>];</span><br><span class="line">        AcNode failNode;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Integer&gt; wordLengthList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AcNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AcNode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(List&lt;String&gt; words)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : words)</span><br><span class="line">        &#123;</span><br><span class="line">            insert(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buildFailPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">AcNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            AcNode[] children = current.children;</span><br><span class="line">            <span class="keyword">if</span> (children[word.charAt(i)] == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                children[word.charAt(i)] = <span class="keyword">new</span> <span class="title class_">AcNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            current = children[word.charAt(i)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        current.wordLengthList.add(word.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildFailPath</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Queue&lt;AcNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">AcNode</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            AcNode[] children = current.children;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; children.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (children[i] == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">AcNode</span> <span class="variable">temp</span> <span class="operator">=</span> current.failNode;</span><br><span class="line">                <span class="keyword">while</span> (temp != <span class="literal">null</span> &amp;&amp; temp.children[i] == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = temp.failNode;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (temp == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    children[i].failNode = root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    children[i].failNode = temp.children[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                children[i].wordLengthList.addAll(children[i].failNode.wordLengthList);</span><br><span class="line">                queue.offer(children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(String word)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">AcNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">AcNode</span> <span class="variable">next</span> <span class="operator">=</span> current.children[ch];</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                current = next;</span><br><span class="line">                <span class="comment">// 此处是要先判断当前节点是否存储了模式串的信息，如果存储了，才进行操作</span></span><br><span class="line">            	<span class="comment">// 此处将这个判断放在函数中</span></span><br><span class="line">                handleMatchWords(current, word, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                next = current.failNode;</span><br><span class="line">                <span class="keyword">while</span> (next != <span class="literal">null</span> &amp;&amp; next.children[ch] == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    next = next.failNode;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    current = root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    current = next.children[ch];</span><br><span class="line">                    <span class="comment">// 此处是要先判断当前节点是否存储了模式串的信息，如果存储了，才进行操作</span></span><br><span class="line">            		<span class="comment">// 此处将这个判断放在函数中</span></span><br><span class="line">                    handleMatchWords(current, word, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleMatchWords</span><span class="params">(AcNode node, String word, <span class="type">int</span> currentPos)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer wordLen : node.wordLengthList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> currentPos - wordLen + <span class="number">1</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">matchWord</span> <span class="operator">=</span> word.substring(startIndex, currentPos + <span class="number">1</span>);</span><br><span class="line">            System.out.println(matchWord);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;</span><br><span class="line">           add(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">           add(<span class="string">&quot;she&quot;</span>);</span><br><span class="line">           add(<span class="string">&quot;hers&quot;</span>);</span><br><span class="line">           add(<span class="string">&quot;his&quot;</span>);</span><br><span class="line">           add(<span class="string">&quot;shy&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Automation</span> <span class="variable">automation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Automation</span>();</span><br><span class="line">        automation.build(words);</span><br><span class="line">        automation.search(<span class="string">&quot;ahishers&quot;</span>);       <span class="comment">// his、she、he、hers</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        automation.search(<span class="string">&quot;abcdefg&quot;</span>);        <span class="comment">// &quot;nothing&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        automation.search(<span class="string">&quot;ahiskhe&quot;</span>);        <span class="comment">// his、he</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        automation.search(<span class="string">&quot;ahiskshers&quot;</span>);     <span class="comment">// his、she、he、hers</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        automation.search(<span class="string">&quot;ahiskabc&quot;</span>);       <span class="comment">// his</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        automation.search(<span class="string">&quot;sher&quot;</span>);           <span class="comment">// she、he</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        automation.search(<span class="string">&quot;he&quot;</span>);             <span class="comment">// he</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        automation.search(<span class="string">&quot;ahishyers&quot;</span>);      <span class="comment">// his、shy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p> <a href="https://www.bilibili.com/video/BV1uJ411Y7Eg?p=4">https://www.bilibili.com/video/BV1uJ411Y7Eg?p=4</a> </p>
<p> <a href="https://www.bilibili.com/video/BV1d7411E7sP?from=search&seid=3361220436715890812">https://www.bilibili.com/video/BV1d7411E7sP?from=search&amp;seid=3361220436715890812</a> </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构与算法</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/binary-indexed-tree/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>树状数组又叫二叉索引树（binary indexed tree），是一种用数组来表示“树”形状的数据结构，这里的“树”并不是真正意义上的树，是一个抽象意义上的“树”，其部分节点并不真实存在，只是为了方便理解而将其用“树”来表示。树状数组常用于求解动态数组（数组中的值经常发生变化）中的区间和。</p>
<span id="more"></span>

<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>一般情况下，画二叉树都会将父节点放在左右子节点的中间，对于树状数组，将父节点位置调整到右子节点的方向上，如下图所示。</p>
<p><img src="https://guozhchun.github.io/images/binary-indexed-tree-1.png" alt="binary-indexed-tree-1"></p>
<p>然后将树中白色背景的节点删除（算法过程中并不需要这部分节点），将蓝色背景的节点统一放到一个水平线上，就可以得到一个数组，如下图所示</p>
<p><img src="https://guozhchun.github.io/images/binary-indexed-tree-2.png" alt="binary-indexed-tree-2"></p>
<p>基于此，就可以用一个数组来表示存储一颗“树”，并用这颗“树”来执行相关业务计算，比如区间和。</p>
<p>但是，对于一个原始数组，怎么将其表示成树状数组呢。首先，要引入一个 <code>lowbit</code> 的概念，<code>lowbit(n)</code> 表示正整数 <code>n</code> 的二进制数的最低位 <code>1</code> 的位置对应数（整数二进制 32 位数里，只在这个位置有数 1，其他位置均为 0）。比如 <code>6</code> 的二进制数是 <code>110</code>，则 <code>lowbit(6) = 2</code>，<code>5</code> 的二进制数为 <code>101</code>，则 <code>lowbit(5) = 1</code>，<code>8</code> 的二进制数为 <code>1000</code>， 则 <code>lowbit(8) = 16</code>。关于 <code>lowbit</code> 有个快速的计算方法： <code>lowbit(n) = n &amp; (-n)</code>。</p>
<p>知道了 <code>lowbit</code> 的含义，现在来构建树状数组。假设用 <code>C</code> 数组来表示构建的树状数组，<code>C[n]</code> 表示 <code>n</code> 节点或左右子树节点之和（如果存在左右子树的话），对于叶子节点，会自动对应到原始数组中。从下图中可以看出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C[1] = nums[1]</span><br><span class="line">C[2] = C[1] + nums[2] = nums[1] + nums[2]</span><br><span class="line">C[3] = nums[3]</span><br><span class="line">C[4] = C[2] + C[3] + nums[4] = nums[1] + nums[2] + nums[3] + nums[4]</span><br><span class="line">C[5] = nums[5]</span><br><span class="line">C[6] = C[5] + nums[6] = nums[5] + nums[6]</span><br><span class="line">C[7] = nums[7]</span><br><span class="line">C[8] = C[4] + C[6] + C[7] + nums[8] = nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6] + nums[7] + nums[8]</span><br><span class="line">C[9] = nums[9]</span><br><span class="line">C[10] = C[9] + nums[10] = nums[9] + nums[10]</span><br><span class="line">C[11] = nums[11]</span><br><span class="line">C[12] = C[10] + nums[11] + nums[12] = nums[9] + nums[10] + nums[11] + nums[12]</span><br><span class="line">C[13] = nums[13]</span><br><span class="line">C[14] = C[13] + nums[14] = nums[13] + nums[14]</span><br><span class="line">C[15] = nums[15]</span><br><span class="line">C[16] = C[8] + C[12] + C[14] + C[15] + nums[16] = nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6] + nums[7] + nums[8] + nums[9] + nums[10] + nums[11] + nums[12] + nums[13] + nums[14] + nums[15] + nums[16]</span><br></pre></td></tr></table></figure>

<p><img src="https://guozhchun.github.io/images/binary-indexed-tree-3.png" alt="binary-indexed-tree-3"></p>
<p>从上述的数组等式中，可以看出，树状数组中的元素包含了原始数组中的部分元素。当初始数组的某个元素发生变化时，树状数组中的部分元素需要跟着改变（树状数组的元素构成里包含了初始数组的这个元素）。比如改变 <code>nums[1]</code> 时，<code>C[1]</code>、<code>C[2]</code>、<code>C[4]</code>、<code>C[8]</code>、<code>C[16]</code>都会发生改变，改变 <code>nums[7]</code> 时， <code>C[7]</code>、<code>C[8]</code>、<code>C[16]</code> 会跟着改变，改变 <code>nums[16]</code> 时，只有  <code>C[16]</code> 会发生变化。</p>
<p>那当某个值发生变化时，怎么知道有哪些值会受影响呢。这里有个递归公式可以判断：当树状数组中 <code>i</code> 的位置发生变化时， <code>i + lowbit(i)</code> 的位置也会发生变化。所以可以得出以下的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是初始数组，sums 是树状数组</span></span><br><span class="line"><span class="comment">// 此函数功能：改变初始数组 index 的值为 val，然后更新树状数组中的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">increaseNum</span> <span class="operator">=</span> val - nums[index];</span><br><span class="line">    nums[index] = val;</span><br><span class="line">    <span class="comment">// 重要的是递推过程元素下标的变化：i += lowBit(i)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; sums.length; i += lowBit(i)) &#123;</span><br><span class="line">        sums[i] += increaseNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的代码虽然是对数组的更新操作，但是同样可以用在构建树状数组的过程中。因为构建树状数组的过程可以看做是将一个初始数组元素都是 <code>0</code> 的数组更新成目标数组的元素的过程。因此，构建树状数组的代码可以是以下操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处假设 nums[0] 是无意义的，真正有意义的数从 nums[1] 开始的</span></span><br><span class="line"><span class="comment">// nums 是初始数组，sums 是树状数组</span></span><br><span class="line"><span class="type">int</span>[] sums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    update(i, nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说完了更新操作，接下来看查询操作。由于树状数组中的元素包含了部分初始数组的元素，因此，当查询初始数组的前缀和或区间和时，可以利用树状数组来快速求解。当求初始数组某个位置的前缀和时，可以利用递推公式在树状数组里进行计算，递归的规律刚好是跟更新操作相反。具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sums 是根据初始数组构建出来的树状数组，sums[0] 无意义，真正有意义的数从 sums[1] 开始</span></span><br><span class="line"><span class="comment">// 此函数功能，求解初始数组中 index 位置的前缀和</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">querySum</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 重要的是递推过程元素下标的变化：i -= lowBit(i)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &gt; <span class="number">0</span>; i -= lowBit(i)) &#123;</span><br><span class="line">        sum += sums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>算法大部分都有模板代码，树状数组也一样，以下给出一个示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] sums;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，构建树状数组，树状数组 sums[0] 留空（无意义），从 sums[1] 开始，sums[i] 对应 nums[i - 1]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// sums[0] 无意义，从 sums[1] 开始，sums[i] 对应 nums[i - 1]</span></span><br><span class="line">        sums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            update(i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将初始数组的 index 位置更新为 val，同时更新树状数组的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">increaseNum</span> <span class="operator">=</span> val - nums[index];</span><br><span class="line">        nums[index] = val;</span><br><span class="line">        <span class="comment">// 重要的是递推过程元素下标的变化：i += lowBit(i)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index + <span class="number">1</span>; i &lt; sums.length; i += lowBit(i)) &#123;</span><br><span class="line">            sums[i] += increaseNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算初始数组 index 位置的前缀和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">querySum</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 重要的是递推过程元素下标的变化：i -= lowBit(i)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &gt; <span class="number">0</span>; i -= lowBit(i)) &#123;</span><br><span class="line">            sum += sums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算正整数 n 对应的二进制数的最低位 1 所在位置对应的数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowBit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构与算法</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>java8中HashMap实现原理</title>
    <url>/hashmap/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HashMap是常用的数据结构，在java8中，其底层是用数组、链表、红黑树结合实现的。在新建一个HashMap时会初始化一个指定大小的数组，在插入元素的过程中，会通过key定位到数组的某个位置上，然后根据链表或红黑树的数据结构进行插入。当数组中已使用的位置达到某个阈值时，会对数组进行扩容。HashMap的数据结构大致如下图所示</p>
<span id="more"></span>

<p><img src="/images/hashmap.png" alt="HashMap数据结构"></p>
<p>本文主要分析put、get和remove方法。</p>
<h1 id="一些成员变量"><a href="#一些成员变量" class="headerlink" title="一些成员变量"></a>一些成员变量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认初始化数组的大小为16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组大小的最大值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认负载因子，主要用于计算threshold的值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表转为红黑树的节点数阈值，当超过这个值时，会将链表转为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将红黑树转为链表的节点数阈值，当小于这个值时，会将红黑数转为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组，连接红黑树和链表</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断数组是否要扩容的阈值 threshold = loadFactor * capacity</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子，用于计算threshold</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap中元素的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>

<h1 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h1><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start=&gt;start: Start</span><br><span class="line">hash=&gt;operation: 对key进行hash求值</span><br><span class="line">isTableEmpty=&gt;condition: 数组未初始化</span><br><span class="line">initTable=&gt;operation: 初始化数组</span><br><span class="line">isFindNodeInArray=&gt;condition: 在数组位置上</span><br><span class="line">							找到相同key</span><br><span class="line">							的节点</span><br><span class="line">isRedBlackTree=&gt;condition: 数组位置关联</span><br><span class="line">						 的是红黑树</span><br><span class="line">handleInRedBlackTree=&gt;operation: 在红黑树中执行</span><br><span class="line">							  节点查找插入操作</span><br><span class="line">isFindNode=&gt;condition: 找到相同</span><br><span class="line">					 key的节点</span><br><span class="line">handleReplacement=&gt;operation: 根据需要替换对应的value</span><br><span class="line">isToReSize=&gt;condition: map元素大小</span><br><span class="line">					 达到阈值</span><br><span class="line">resize=&gt;operation: 扩容</span><br><span class="line">isFindInList=&gt;condition: 在链表中找到</span><br><span class="line">					   相同key节点</span><br><span class="line">insertNodeInList=&gt;operation: 在链表尾部插入节点</span><br><span class="line">isChangeToTree=&gt;condition: 链表节点数是</span><br><span class="line">						 否超过阈值</span><br><span class="line">changeListToTree=&gt;operation: 将链表转为红黑树</span><br><span class="line">end=&gt;end</span><br><span class="line"></span><br><span class="line">start-&gt;hash-&gt;isTableEmpty(yes)-&gt;initTable-&gt;isFindNodeInArray(yes,right)-&gt;isFindNode(yes)-&gt;handleReplacement-&gt;isToReSize(yes)-&gt;resize-&gt;end</span><br><span class="line">isTableEmpty(no)-&gt;isFindNodeInArray(no)-&gt;isRedBlackTree(yes)-&gt;handleInRedBlackTree-&gt;isFindNode</span><br><span class="line">isRedBlackTree(no)-&gt;isFindInList(no)-&gt;insertNodeInList-&gt;isChangeToTree(yes)-&gt;changeListToTree(right)-&gt;isFindNode</span><br><span class="line">isFindInList(yes)-&gt;isFindNode</span><br><span class="line">isFindNode(no)-&gt;isToReSize</span><br><span class="line">isToReSize(no)-&gt;end</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="putVal函数"><a href="#putVal函数" class="headerlink" title="putVal函数"></a>putVal函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先对key取hash定位到对应的数组的位置，然后调用putVal函数放置数据</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果数组并未初始化，则调用resize函数初始化数组，resize函数后面解析</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果hash(key)对应的数组位置上没有节点（数据）</span></span><br><span class="line">    <span class="comment">// 则直接新建一个节点，放在这个位置上</span></span><br><span class="line">    <span class="comment">// 否则，根据是链表还是红黑树执行对应的查找插入操作</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// hash(key)在数组上能找到位置，属于hash冲突</span></span><br><span class="line">        <span class="comment">// 此时，需要查找这个位置关联的链表或红黑树中是否有相同key的节点</span></span><br><span class="line">        <span class="comment">// 如果有，则根据需要替换value的值</span></span><br><span class="line">        <span class="comment">// 如果没有，则根据链表或红黑树执行对应的插入操作</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 数组位置上的节点的key值与插入的key值相同</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果数组位置上关联的是红黑树，则执行红黑树的查找插入操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果数组位置上关联的是链表，则执行链表的查找插入操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 遍历到链表最后，没找到相同key的节点，此时插入新节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在链表尾部插入新的节点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表上的节点数达到阈值，则将其转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 在链表中找到相同key值的节点</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找打了相同key值的节点，则根据需要替换对应的value值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果HashMap中元素个数超过阈值，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resize函数"><a href="#resize函数" class="headerlink" title="resize函数"></a>resize函数</h3><p>resize函数是HashMap扩容的函数，扩容的主要流程为：</p>
<ol>
<li>将capacity和threshold进行扩容，一般情况下是原先的两倍。</li>
<li>根据新的capacity新建数组（一般情况下为原先长度的两倍），将table指向新建的数组</li>
<li>对原先数组及其关联的链表、红黑树的节点进行重分布。将一些节点留在 i （i 为节点所在的原先数组位置）位置上，另一些节点留在 i + oldCapacity 上（i 为节点所在的原先数组位置，oldCapacity为原先数组长度）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果数组大小已经超过MAXIMUM_CAPACITY，则将阈值设为整形最大值，不进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对数组进行扩容，大小变为原先的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对应初始化HashMap(capacity)的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 对应初始花HashMap()的情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 新建数组长度为原先的两倍，将table指向新建的数组</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 对原先数组中的节点进行重分布</span></span><br><span class="line">    <span class="comment">// 一半节点在原先数组的位置上</span></span><br><span class="line">    <span class="comment">// 另一半节点分布到数组的 i + oldCapacity位置上</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 数组位置上只有一个节点，直接放到新的数组上</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 数组位置上关联的是红黑树，执行红黑树的重分布</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 数组位置上关联的是链表，执行链表的重分布</span></span><br><span class="line">                <span class="comment">// 重分布会将原先的链表分成两个链表</span></span><br><span class="line">                <span class="comment">// 一个链表在新数组的 i 位置上（i指原先在数组的位置）</span></span><br><span class="line">                <span class="comment">// 另一个链表在新数组的 i + oldCapacity位置上（oldCapacity指原先数组长度）</span></span><br><span class="line">                <span class="comment">// 重分布后，在每个链表内部，节点的顺序跟原先的保持一致</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="treeifyBin函数"><a href="#treeifyBin函数" class="headerlink" title="treeifyBin函数"></a>treeifyBin函数</h3><p>这是将链表转换为红黑树的函数。在转换之前，会将节点的数据结构由Node转为TreeNode，此转换过程中并不会改变原先链表的顺序，这也是方便重分布红黑树和后续将红黑树转为链表时仍能维持原先的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 将链表的数据结构Node转为红黑树的数据结构TreeNode</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 保持原先链表的节点顺序，方便重分布红黑树和后续由红黑树转为链表时仍能维持节点顺序</span></span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 将链表转为红黑树，执行的是红黑树的插入操作</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="split函数"><a href="#split函数" class="headerlink" title="split函数"></a>split函数</h3><p>这个函数主要是对红黑树进行重分布。由于将链表转为红黑树的过程中维持者链表节点的顺序，因此此处重分布红黑树也是先执行链表的重分布步骤将节点以链表的形式分散在数组两个位置上，然后对这两个位置的链表以插入的方式构造红黑树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">int</span> index, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 红黑树内部仍然维持者链表的节点顺序</span></span><br><span class="line">    <span class="comment">// 此处按照重分布链表的方式，将节点分布在数组的两个位置上</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="literal">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 i 位置上的红黑树</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果红黑树的节点数小于阈值，则将红黑树转为链表</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将链表安装红黑树插入方式转为红黑树</span></span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理 i + oldCapacity位置上的红黑树</span></span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果红黑树的节点数小于阈值，则将红黑树转为链表</span></span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将链表安装红黑树插入方式转为红黑树</span></span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="literal">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="untreeify函数"><a href="#untreeify函数" class="headerlink" title="untreeify函数"></a>untreeify函数</h3><p>此函数是将红黑树转为链表的函数，由于将链表转为红黑树的过程中，替换了节点的数据结构，但是链表的节点顺序并为改变，因此，在将红黑树转为链表的过程中，只需将节点的数据结构由TreeNode转为Node即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="built_in">this</span>; q != <span class="literal">null</span>; q = q.next) &#123;</span><br><span class="line">        <span class="comment">// 由于将链表转为红黑树的过程中，维持者链表节点顺序</span></span><br><span class="line">        <span class="comment">// 此处只需要将节点数据结构由TreeNode转为Node即可</span></span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h1><p>get方法相对而言比较简单，主要是先计算hash(key)的值，然后进行查找操作。</p>
<h2 id="大致流程-1"><a href="#大致流程-1" class="headerlink" title="大致流程"></a>大致流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start=&gt;start: Start</span><br><span class="line">hash=&gt;operation: 对key进行hash求值</span><br><span class="line">isFindInArray=&gt;condition: 在数组位置上找</span><br><span class="line">						到相同key的节点</span><br><span class="line">returnValue=&gt;operation: 返回节点值</span><br><span class="line">returnNull=&gt;operation: 返回空</span><br><span class="line">isRedBlackTree=&gt;condition: 数组位置</span><br><span class="line">						 关联红黑树</span><br><span class="line">findInRedBlackTree=&gt;operation: 在红黑树中查找节点</span><br><span class="line">isFindNode=&gt;condition: 找到相同key节点</span><br><span class="line">findInList=&gt;operation: 在链表中查找节点</span><br><span class="line">end=&gt;end: End</span><br><span class="line"></span><br><span class="line">start-&gt;hash-&gt;isFindInArray(no, left)-&gt;isRedBlackTree(yes)-&gt;findInRedBlackTree-&gt;isFindNode(yes)-&gt;returnValue-&gt;end</span><br><span class="line">isFindNode(no)-&gt;returnNull-&gt;end</span><br><span class="line">isFindInArray(yes)-&gt;isFindNode</span><br><span class="line">isRedBlackTree(no)-&gt;findInList-&gt;isFindNode</span><br></pre></td></tr></table></figure>

<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 先计算hash(key),再执行查找</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组位置上的节点key值相同，则直接返回数组位置节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 数组位置上关联的是红黑树，执行红黑树的查找操作</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 数组位置上关联的是链表，执行链表的查找操作</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h1><h2 id="大致流程-2"><a href="#大致流程-2" class="headerlink" title="大致流程"></a>大致流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start=&gt;start: Start</span><br><span class="line">hash=&gt;operation: 对key进行hash求值</span><br><span class="line">isFindInArray=&gt;condition: 在数组位置上找</span><br><span class="line">						到相同key的节点</span><br><span class="line">isRedBlackTree=&gt;condition: 数组位置</span><br><span class="line">						 关联红黑树</span><br><span class="line">findInRedBlackTree=&gt;operation: 在红黑树中查找节点</span><br><span class="line">isFindNode=&gt;condition: 找到相同key节点</span><br><span class="line">findInList=&gt;operation: 在链表中查找节点</span><br><span class="line">isRBT=&gt;condition: 数组位置</span><br><span class="line">				关联红黑树</span><br><span class="line">deleteNodeInRBT=&gt;operation: 执行红黑树删除节点操作</span><br><span class="line">deleteNodeInList=&gt;operation: 执行链表删除操作</span><br><span class="line">end=&gt;end: End</span><br><span class="line"></span><br><span class="line">start-&gt;hash-&gt;isFindInArray(no, left)-&gt;isRedBlackTree(yes)-&gt;findInRedBlackTree-&gt;isFindNode(yes)-&gt;isRBT(yes)-&gt;deleteNodeInRBT-&gt;end</span><br><span class="line">isFindNode(no)-&gt;end</span><br><span class="line">isFindInArray(yes)-&gt;isFindNode</span><br><span class="line">isRedBlackTree(no)-&gt;findInList-&gt;isFindNode</span><br><span class="line">isRBT(no)-&gt;deleteNodeInList-&gt;end</span><br></pre></td></tr></table></figure>

<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 先查找要删除的节点</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 数组位置上节点key值相同，即为要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 数组位置关联的是红黑树，执行红黑树的查找操作</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 数组位置关联的是链表，执行链表的查找操作</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果相同key值的节点，则执行删除操作</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 数组位置关联的是红黑树，执行红黑树的删除操作</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// 数组位置节点是要删除的节点，删除数组位置节点，将数组位置指针指向链表下一个节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="comment">// 数组位置节点关联的是链表，执行链表的删除操作</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="HashMap是非线程安全的"><a href="#HashMap是非线程安全的" class="headerlink" title="HashMap是非线程安全的"></a>HashMap是非线程安全的</h2><p>在 put 方法中，查找链表到尾部时，如果仍然找不到 key 值相同的元素，则在尾部插入新节点。假设线程A要插入（a, a）的键值对，线程B要插入（b, b）的键值对，再假设 a、b 这两个 key 会映射到同一个 table[i] 上，并且原先都没有插入过 key 为 a 或 b 的键值对；当线程A遍历到链表尾部时，在准备（下一步）插入新节点的时候，线程切换到B执行，B也遍历到链表尾部，并插入新节点（b, b），然后线程切换到A，A插入新节点（a, a），此时会造成插入的（b, b）节点被覆盖丢失。</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>在查找节点和删除节点这两个操作中，都涉及了查找节点的过程，但是在remove的查找节点的过程中并不是调用get方法中调用的<code>getNode</code>函数，而是重新写了类似的查找过程，这让我很疑惑。不管怎样，不可否认，java8中HashMap的源码是优秀的。关于疑问就先留着以后解决吧。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序（C++）</title>
    <url>/heapSort-C-Plus/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  维护堆排序，采用下调的方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downAdjust</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>* a, <span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tem;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &gt;= n)  <span class="comment">//  如果该结点是叶结点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//  如果该结点只有左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">2</span> &gt;= n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  如果该结点的值比左孩子的值小，则交换，然后继续下调操作</span></span><br><span class="line">        <span class="comment">//  否则停止下调操作</span></span><br><span class="line">        <span class="keyword">if</span> (a[k] &lt; a[<span class="number">2</span> * k + <span class="number">1</span>]) </span><br><span class="line">        &#123;</span><br><span class="line">            tem = a[k];</span><br><span class="line">            a[k] = a[<span class="number">2</span> * k + <span class="number">1</span>];</span><br><span class="line">            a[<span class="number">2</span> * k + <span class="number">1</span>] = tem;</span><br><span class="line">            <span class="built_in">downAdjust</span>(<span class="number">2</span> * k + <span class="number">1</span>, a, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  如果该结点值比左右孩子的值都大，则下调操作结束</span></span><br><span class="line">        <span class="keyword">if</span> (a[k] &gt;= a[<span class="number">2</span> * k + <span class="number">1</span>] &amp;&amp; a[k] &gt;= a[<span class="number">2</span> * k + <span class="number">2</span>])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//  如果该结点和左孩子都比右孩子小，则将该结点与右孩子交换，然后继续下调操作</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">2</span> * k + <span class="number">1</span>] &lt; a[<span class="number">2</span> * k + <span class="number">2</span>]) </span><br><span class="line">        &#123;</span><br><span class="line">            tem = a[k];</span><br><span class="line">            a[k] = a[<span class="number">2</span> * k + <span class="number">2</span>];</span><br><span class="line">            a[<span class="number">2</span> * k + <span class="number">2</span>] = tem;</span><br><span class="line">            <span class="built_in">downAdjust</span>(<span class="number">2</span> * k + <span class="number">2</span>, a, n);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            tem = a[k];</span><br><span class="line">            a[k] = a[<span class="number">2</span> * k + <span class="number">1</span>];</span><br><span class="line">            a[<span class="number">2</span> * k + <span class="number">1</span>] = tem;</span><br><span class="line">            <span class="built_in">downAdjust</span>(<span class="number">2</span> * k + <span class="number">1</span>, a, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  堆排序的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapsort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tem;</span><br><span class="line">    <span class="comment">// 先把所有的值按照完全二叉树排好，然后运用下调方式维护堆，从而建立一个堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">downAdjust</span>(i, a, n);</span><br><span class="line">    <span class="comment">//  将堆顶元素与最后一个元素交换，然后运用下调方式维护堆，直至排序完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">    &#123;</span><br><span class="line">        tem = a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = a[i];</span><br><span class="line">        a[i] = tem;</span><br><span class="line">        <span class="built_in">downAdjust</span>(<span class="number">0</span>, a, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;本程序采用堆排序对整数进行排序，以升序结果输出&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入要排序的整数个数：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入您要排序的数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">heapsort</span>(a, n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的结果是：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> []a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>C/C++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>几个好用的hexo插件</title>
    <url>/hexo-pluins/</url>
    <content><![CDATA[<p>hexo官方提供了很多**<a href="https://hexo.io/plugins/">插件</a>**方便编写管理文章，以下几个插件是我觉得相对比较好用的插件。</p>
<p><em>注意：本文均以</em>*<a href="https://github.com/theme-next/hexo-theme-next">NexT</a>*<em>主题 (version: 5.1.4)为基础进行的配置，不同的主题配置不同</em></p>
<span id="more"></span>

<h1 id="Gitment"><a href="#Gitment" class="headerlink" title="Gitment"></a>Gitment</h1><p>这个插件主要是用于增加文章的评论的。主要是借助github的issues，文章评论的内容会当成某个仓库issues放在github上。NexT 5.1.4 版本已经集成了这个插件，只需要注册一个OAuth Application，改下主题的相关配置项即可。主要步骤如下</p>
<h2 id="注册OAuth-Application"><a href="#注册OAuth-Application" class="headerlink" title="注册OAuth Application"></a>注册OAuth Application</h2><p>**<a href="https://github.com/settings/applications/new">点击此处</a>**申请一个新的OAuth Application。如下图所示，需要注意的是Authorization callback URL需要填写自己的hexo网站域名。注册成功后会得到一个<code>Client ID </code>和<code>Client Secret </code>，这两个值是后面配置<code>$&#123;hexoHome&#125;/themes/hexo-theme-next/_config.yml</code>中需要用到的。</p>
<p><img src="/images/registerOAuthApplication.png" alt="register OAuth Application"></p>
<h2 id="修改主题的-config-yml配置"><a href="#修改主题的-config-yml配置" class="headerlink" title="修改主题的_config.yml配置"></a>修改主题的_config.yml配置</h2><p>主要是将gitment底下的<code>enable</code>参数改为<code>true</code>，<code>github_user</code>写自己的github用户名，<code>github_repo</code>是用于存放评论内容的issues对应的仓库，必须存在，可以新建一个新的空仓库，也可以放在已有的仓库底下。<code>client_id</code>和<code>client_secret</code>是上一部中申请OAuth Application生成的<code>Client ID </code>和<code>Client Secret </code>。</p>
<p><img src="/images/gitmentConfig.png" alt="gitment config"></p>
<h2 id="初始化评论"><a href="#初始化评论" class="headerlink" title="初始化评论"></a>初始化评论</h2><p>配置完插件后，需要对开放评论的界面手动初始化评论才能让其他用户进行评论</p>
<p><img src="/images/initComments.png" alt="初始化文章评论"></p>
<h2 id="关闭页面评论"><a href="#关闭页面评论" class="headerlink" title="关闭页面评论"></a>关闭页面评论</h2><p>对于一些不想开放评论功能的界面，可以在对应的页面文件中的开头加入<code>comments: false</code>语句，这样评论区域就不会显示在该页面上了。例如关闭tags页面的评论</p>
<p><img src="/images/closeTagComments.png" alt="close tag page comments"></p>
<h1 id="不蒜子"><a href="#不蒜子" class="headerlink" title="不蒜子"></a>不蒜子</h1><p>这个插件主要是用来统计文章和网站的访问量的，具体使用可以参考**<a href="http://ibruce.info/2015/04/04/busuanzi">官网</a>**。NexT 5.1.4 版本已经集成了这个插件，只需要将<code>$&#123;hexoHome&#125;/themes/hexo-theme-next/_config.yml</code>配置文件中<code>busuanzi_count</code>底下的<code>enable</code>参数改成<code>true</code>即可。其他参数可以参考配置文件中的说明进行修改。</p>
<p><img src="/images/busuanzi.png" alt="busuanzi config"></p>
<h1 id="hexo-filter-flowchart"><a href="#hexo-filter-flowchart" class="headerlink" title="hexo-filter-flowchart"></a>hexo-filter-flowchart</h1><p>使用这个插件可以很方便的用markdown画出流程图，由于我使用的markdown编辑器是**<a href="https://www.typora.io/">Typora</a><strong>，内部集成了flowcharts.js文件，可以使用其画出流程图，对于需要将这些通过Typora画出的流程图上传到网站上并能正常显示，就需要使用</strong><a href="https://github.com/bubkoo/hexo-filter-flowchart">hexo-filter-flowchart</a>**这个插件了。主要配置如下</p>
<h2 id="安装flowchart插件"><a href="#安装flowchart插件" class="headerlink" title="安装flowchart插件"></a>安装flowchart插件</h2><p>在<code>$&#123;hexoHome&#125;</code>目录下执行以下命令完成安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-filter-flowchart</span><br></pre></td></tr></table></figure>

<h2 id="修改-config-yml配置项"><a href="#修改-config-yml配置项" class="headerlink" title="修改 _config.yml配置项"></a>修改 _config.yml配置项</h2><p>在<code> $&#123;hexoHome&#125;/_config.xml</code> 文件中，增加以下的配置项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart:</span><br><span class="line">  # raphael:   # optional, the source url of raphael.js</span><br><span class="line">  # flowchart: # optional, the source url of flowchart.js</span><br><span class="line">  options: # options used for `drawSVG`</span><br></pre></td></tr></table></figure>

<h1 id="local-search"><a href="#local-search" class="headerlink" title="local_search"></a>local_search</h1><p>**<a href="https://github.com/theme-next/hexo-generator-searchdb">local_search</a>**这个插件主要是为博客增加搜索功能。主要安装配置如下</p>
<h2 id="安装hexo-generator-searchdb"><a href="#安装hexo-generator-searchdb" class="headerlink" title="安装hexo-generator-searchdb"></a>安装hexo-generator-searchdb</h2><p>在<code>$&#123;hexoHome&#125;</code>目录下执行以下命令安装hexo-generator-searchdb插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<h2 id="修改主题的-config-yml配置-1"><a href="#修改主题的-config-yml配置-1" class="headerlink" title="修改主题的 _config.yml配置"></a>修改主题的 _config.yml配置</h2><p>主要是将<code>local_search</code>底下的<code>enable</code>值改为<code>true</code></p>
<p><img src="/images/localSearch.png" alt="local search"></p>
<h1 id="hexo-featured-image"><a href="#hexo-featured-image" class="headerlink" title="hexo-featured-image"></a>hexo-featured-image</h1><p>这个插件主要是使用markdown语法写的图片能够上传到网站上并正常显示的一个插件。只需要安装该插件，然后在<code>$&#123;hexoHome&#125;/source</code>目录底下新建一个<code>images</code>目录用于存放图片即可，在引用图片时图片的路径为<code>/images/yourImageName</code>，因为使用<code>hexo g</code>时会将<code>$&#123;hexoHome&#125;/source/images</code>底下的图片拷贝到<code>$&#123;hexoHome&#125;/public/images目录下</code>。例如：引用图片<code>$&#123;hexoHome&#125;/source/images/localSearch.png</code>需要写<code>![](/images/localSearch.png)</code>。这里有点不太好的地方就是引用的图片在markdown上无法显示，因为本地路径不对（但是发布之后路径是对的，因此在线时可以正常显示）。具体配置可以参考**<a href="https://github.com/poacher2k/hexo-featured-image">官网</a>**，这里以其最简单的配置进行说明（不修改 _config.yml文件）</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>在<code>$&#123;hexoHome&#125;</code>目录下执行以下命令完成安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-featured-image</span><br></pre></td></tr></table></figure>

<h2 id="新建images目录"><a href="#新建images目录" class="headerlink" title="新建images目录"></a>新建images目录</h2><p>在<code>$&#123;hexoHome&#125;/source</code>目录下新建<code>images</code>目录</p>
<p><img src="/images/imagesDir.png" alt="create image directory"></p>
<h2 id="引用图片"><a href="#引用图片" class="headerlink" title="引用图片"></a>引用图片</h2><p>在需要引用图片的地方使用markdown的格式进行引用，需要注意的是引用图片的路径必须为<code>/images/yourImageName</code>。例如引用<code>localSearch.png</code>文件应该写<code>![local search](/images/localSearch.png)</code>。</p>
<p><img src="/images/useImage.png" alt="use image"></p>
<h1 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h1><ol>
<li><a href="https://imsun.net/posts/gitment-introduction/">https://imsun.net/posts/gitment-introduction</a></li>
<li><a href="http://ibruce.info/2015/04/04/busuanzi">http://ibruce.info/2015/04/04/busuanzi</a></li>
<li><a href="https://github.com/bubkoo/hexo-filter-flowchart">https://github.com/bubkoo/hexo-filter-flowchart</a></li>
<li><a href="https://github.com/theme-next/hexo-generator-searchdb">https://github.com/theme-next/hexo-generator-searchdb</a></li>
<li><a href="https://github.com/poacher2k/hexo-featured-image">https://github.com/poacher2k/hexo-featured-image</a></li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客修改时间</title>
    <url>/hexoBlogTimeModify/</url>
    <content><![CDATA[<p>hexo博客中默认只有发表时间，并没有最后修改的时间，而且显示时间是年月日，并没有具体到时分秒。这并不能满足我的需求，因此我觉得为博客加上最后的修改时间，并将显示的时间具体到时分秒。本文主要记录如何增加显示博客的最后修改时间，以及将默认显示时间由年月日改成年月日时分秒。</p>
<p><em>注意：本文基于主题</em>*<a href="https://github.com/theme-next/hexo-theme-next">NexT</a>*<em>主题 (version: 5.1.4)，对于其他主题可能并不适合。</em></p>
<span id="more"></span>

<h1 id="增加最后修改时间"><a href="#增加最后修改时间" class="headerlink" title="增加最后修改时间"></a>增加最后修改时间</h1><p>在<code>$&#123;hexoHome&#125;/themes/hexo-theme-next/_config.yml</code>文件中找到<code>post_meta</code>参数，将其底下的<code>updated_at</code>的值改为<code>true</code>，即可显示文章的最后修改时间。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post meta display settings</span></span><br><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">updated_at:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="修改文章显示时间格式"><a href="#修改文章显示时间格式" class="headerlink" title="修改文章显示时间格式"></a>修改文章显示时间格式</h1><p>文章显示时间格式主要是由<code>$&#123;hexoHome&#125;/themes/hexo-theme-next/layout/_macro/post.swig</code>文件中控制的。其中<code>config.date_format</code>主要指<code>$&#123;hexoHome&#125;/_config.xml</code>中的<code>date_format</code>的值。因此有两种方法可以修改文章显示的时间为年月日时分秒。</p>
<p><img src="/images/hexoPostTimeFormatOld.png" alt="控制文章时间显示格式"></p>
<p>方法一：修改<code>$&#123;hexoHome&#125;/_config.xml</code>中的<code>date_format</code>的值<code>YYYY-MM-DD HH:mm:ss</code>。此方法改起来比较简单，不过考虑到变量名和变量值语义不一致，所以我采用了方法二进行修改。</p>
<p>方法二：在<code>$&#123;hexoHome&#125;/_config.xml</code>文件中增加<code>datetime_format: YYYY-MM-DD HH:mm:ss</code>配置项，然后在<code>$&#123;hexoHome&#125;/themes/hexo-theme-next/layout/_macro/post.swig</code>文件中将控制日期显示格式的<code>config.date_format</code>改成<code>config.datetime_format</code>，如下图所示</p>
<p><img src="/images/hexoPostTimeFormatNew.png" alt="文章时间格式显示为年月日时分秒"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>解读 https 通信</title>
    <url>/https/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在浏览器与服务器之间进行通信主要有 http 和 https 两种方式。对于 http 而言，这是一种明文传输的通信协议，这就让客户端与服务器之间的明文通信容易让黑客窃取甚至篡改，无法保证安全。因而引入了 https 协议，即HTTP+SSL&#x2F;TLS，这是一种在 http 协议的基础上加入了 SSL 层进行加解密保护，保证客户端和服务器之间的通信是安全的。</p>
<span id="more"></span>

<h1 id="https-使用的算法"><a href="#https-使用的算法" class="headerlink" title="https 使用的算法"></a>https 使用的算法</h1><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称加密算法是指通信双方拥有相同的密钥，在进行通信时发送方使用这个秘钥进行加密，接收方通过网络接收到密文后，使用相同的秘钥对密文进行解密得到明文。主要的对称加密算法有DES、AES-GCM等。</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密的秘钥有公钥和私钥两个，一个通过公钥加密的消息只能由对应的私钥进行解密，而不能由公钥进行解密。同理，一个通过私钥加密的消息也只能由对应的公钥进行解密，不能通过私钥进行解密。在通信过程中，私钥自己保存，公钥对外发布，任何人都可以获得其他人发布的公钥。当发送方要发送消息时，使用接收方的公钥进行解密，接收方收到消息后，使用自己的私钥进行解密得到明文。常见的非对称加密算法主要有 RSA、DSA 等。</p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>哈希算法主要是对一个消息进行散列求值，是一种将任意长度的数据压缩到某一固定长度的数据的算法。其具有不可逆性、抗冲突性和分布均匀性。其中不可逆性指从 hash 值推测出原先的数据是不可能的。抗冲突性指不存在两个不同的数据其 hash 结果是一样的。常见的哈希算法有 MD5、SHA256等。</p>
<h1 id="https「演进过程」"><a href="#https「演进过程」" class="headerlink" title="https「演进过程」"></a>https「演进过程」</h1><p>此部分主要参考《码农翻身》的「一个故事讲完 HTTPS」章节，并非 https 的真实演进过程。https 的通信过程可直接看<a href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%89%88%E6%9C%AC">数字证书版本</a>章节。</p>
<h2 id="http-版本"><a href="#http-版本" class="headerlink" title="http 版本"></a>http 版本</h2><p>http 是以明文进行通信的，也就是说通信的内容容易被第三方窃取和篡改。下图是正常的通信过程</p>
<p><img src="/images/https-1.png" alt="http原始通信"></p>
<p>但是，由于其脆弱性，容易使通信内容被第三方篡改。如下图所示，客户端发送「Hello」给服务器，但是在中间被黑客篡改成「Goodbye」，服务器收到消息时，以为这是客户端发送的，并不知道这是被篡改的消息。同理，客户端也误以为黑客发送过来的消息是服务器发送的，这就造成了「误解」，从而做出错误的回应。当然，黑客也可以不篡改消息，而只是监听消息。例如对帐号和密码进行传输时，黑客就能通过这种方式轻易地获得对应的帐号和密码，从而使其遭受财产损失。</p>
<p><img src="/images/https-2.png" alt="http原始通信-黑客篡改"></p>
<h2 id="对称加密版本"><a href="#对称加密版本" class="headerlink" title="对称加密版本"></a>对称加密版本</h2><p>由于 http 的极度不安全性，因此可以在客户端和服务器两侧进行某个秘钥的约定，这样在通信前对消息进行加密，接收方接收到消息后使用约定的秘钥进行解密，而黑客由于不知道秘钥，即使获取到消息也无法得知确切的内容，即使进行篡改，在接收方进行解密也会失败，从而保证消息传递的正确性。其通信过程大致如下所示</p>
<p><img src="/images/https-3.png" alt="对称加密通信"></p>
<p>对称加密虽然解决了 http 的明文传输问题，但是其有一个苛刻的要求：客户端和服务器需要事先约定要秘钥并且不能被其他人知道。这个秘钥不能在没有保护情况下通过网络进行传输，否则黑客仍然能截取秘钥，从而对通信过程进行破坏。此外，服务器需要维护大量的与不同客户端进行通信的秘钥，这给服务器增加了负担。</p>
<h2 id="非对称加密版本"><a href="#非对称加密版本" class="headerlink" title="非对称加密版本"></a>非对称加密版本</h2><p>由于使用对称加密进行通信需要维护大量的秘钥，并且需要在通信前约定好秘钥，这不太现实，因此将加密方式该成非对称加密。此方式主要是通信双方分别生成自己的公钥和私钥，然后对外公布公钥，私钥自己保存不泄漏。在通信前，先用对方的公钥对消息进行加密，然后发送消息，接收方在接收消息后用自己的私钥进行解密得到明文。这样就不用事先约定好秘钥了，因为对方的公钥是对外公布的，任何人都能获得，而也只有对应的私钥才能解密用公钥加密的密文，因此也不用担心传输过程中消息被窃取。同时也不用维护多个秘钥了，因为只需要维护好自己的私钥即可。其通信过程大致如下所示</p>
<p><img src="/images/https-4.png" alt="非对称加密通信"></p>
<p>使用非对称加密的 http 进行传输，虽然保证传输内容不被窃取，但是却无法保证传输内容被篡改。因为公钥是对外发布的，任何人都能获得公钥，但发送方使用服务器的公钥进行加密发送消息时，黑客可以截取消息，然后将自己的消息用服务器的公钥进行加密后发送给服务器，服务器接收到消息，因为可以用自己的私钥进行解密，所以仍然认为这是客户端发送的消息，此时就达到了攻击的目的。其通信过程大致如下所示</p>
<p><img src="/images/https-5.png" alt="非对称加密通信-黑客篡改"></p>
<h2 id="对称加密与非对称加密结合版本"><a href="#对称加密与非对称加密结合版本" class="headerlink" title="对称加密与非对称加密结合版本"></a>对称加密与非对称加密结合版本</h2><p>非对称加密的 http 通信除了可以被黑客篡改内容外，还有一个性能问题。使用非对称加解密的速度远远比不上对称加解密的速度。为了解决这问题，采用了常用的折中方法进行处理：同时使用对称加密和非对称加密方式。具体表现为：刚开始时使用非对称加密进行通信，在确认对方身份后，约定一个秘钥并使用非对称加密的方式将秘钥传送给对方，后续使用基于此秘钥的对称加密方式进行通信。此方法不但可以解决非对称加密算法的性能问题，也可以非对称加密版本中被黑客篡改内容的问题，主要是因为攻击者虽然可以获取公钥，但是无法解密，所以攻击只能是整体篡改内容，再使用相同的公钥进行加密通信，但是在约定秘钥的过程中，攻击者虽然可以篡改秘钥，但是却无法让篡改的信息在通信双方都得到正确的解析，从而让通信方得知此消息不是来自目标者而放弃此次通信，从而使本次攻击失败。其失败的攻击过程大致如下所示</p>
<p><img src="/images/https-6.png" alt="对称加密与非对称加密结合通信-解决非对称加密的攻击问题"></p>
<p>正常情况下，使用对称加密和非对称加密相结合的通信过程大致如下所示</p>
<p><img src="/images/https-7.png" alt="对称加密与非对称加密结合通信"></p>
<p>虽然此版本避免了对称加密的维护大量秘钥的问题，也解决了非对称加密的篡改和性能问题，但是仍然无法解决「中间人」攻击的问题。因为此版本有一个大前提：客户端获取的服务器的公钥是正确的。如果这个公钥是黑客伪造的，那整个过程就相当于明文通信了。其攻击过程大致如下所示</p>
<p><img src="/images/https-8.png" alt="对称加密与非对称加密结合通信-黑客攻击"></p>
<h2 id="数字证书版本"><a href="#数字证书版本" class="headerlink" title="数字证书版本"></a>数字证书版本</h2><p>对称加密和非对称加密相结合的版本失效的原因是因为不能确定服务器的公钥真正地来自服务器而不是来自攻击者，所以引入数字证书来确定获取到的是真正服务器的公钥。数字证书主要包含以下内容：证书发行机构、证书有效期、证书所有者（给谁发的证书）及其公钥、证书发行机构的数字签名（对证书的基本信息进行哈希，然后使用自己的私钥对哈希值进行加密），其构成大致如下图所示</p>
<p><img src="/images/https-9.png" alt="数字证书"></p>
<p>客户端在获取证书时，用证书发行机构的公钥对其进行解密获得哈希值，同时对证书的基本信息求哈希，将这两个哈希值进行比较，如果相同，则确定是服务器的公钥，否则认为有攻击。</p>
<p><img src="/images/https-10.png" alt="数字证书-解密认证"></p>
<p>此时又会有一个问题，如何确定证书发行机构的公钥是正确的呢？这就涉及到另一个问题了：操作系统和浏览器中会预先预置一些权威的经过认证的证书发行机构的数字证书（当然就包含其公钥了），如果要进行通信的服务器的数字证书是由这些证书发行机构发行的，那么就会认为是安全的可以进行通信，否则会提示不安全询问是否进行下一步操作。</p>
<p>使用数字证书进行通信的过程大致如下：首先客户端向服务器发送一个请求，服务器进行响应，同时把自己的数字证书发送给客户端，客户端对证书进行解析验证证书可靠性并获取服务端的公钥，然后用这个公钥对约定的秘钥进行加密发送给服务器，后续服务器和客户端之间用这个约定的秘钥进行对称加密的通信，其大致图示如下</p>
<p><img src="/images/https-11.png" alt="数字证书通信"></p>
<p>用此版本进行通信，攻击者虽然也可以拦截并解密服务器发送包含公钥的数字证书，但是其却无法伪造服务器公钥，因为新计算的hash值与数字证书中的数字签名的hash值不一样，而因为攻击者没有证书发行机构的私钥，因此也无法伪造数字签名，这样客户端就能确保收到的公钥是服务器的公钥。在确认这一步后，接着约定秘钥的过程，攻击者因为没有服务器的私钥，也无法窥探和篡改，从而保证约定秘钥的过程也是安全的。在约定秘钥后，后续的通信使用对称加密的方式，攻击者因为没有对应的秘钥，因此也无法窥探和篡改通信消息。至此，可以确定用数字证书的方式进行http通信是安全可靠的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>https 是使用数字证书，结合了对称加密算法、非对称加密算法和哈希算法的建立在 http 之上的安全通信协议。虽然其比 http 多了很多认证的步骤，但是其贵在安全，而这也是 web 应用中很重要的一个特征，因此在 web 应用中应该尽可能地使用 https 协议代替 http 协议进行通信。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 刘欣. 码农翻身[M]. 北京：电子工业出版社，2018</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>java 自动装箱和拆箱</title>
    <url>/java-autoboxing/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>自动装箱和自动拆箱是 java5 提供的一种语法糖，主要是为了方便程序员进行代码编写，在编译时会自动将语法糖去除还原成其真正的语法。</p>
<p>自动装箱：将基本类型转换为其包装类型。如将 <code>int</code> 转成 <code>Integer</code>。其主要是通过包装类中的 <code>valueOf</code> 函数完成的。</p>
<p>自动拆箱：将包装类型转成基本类型。如将 <code>Integer</code> 转成 <code>int</code>。其主要是通过包装类中的 <code>xxxValue</code>函数完成的，其中 <code>xxx</code>代表基本类型。例如 <code>Integer</code> 类中是 <code>intValue</code>，<code>Long</code> 类中是 <code>longValue</code>。</p>
<span id="more"></span>

<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>自动装箱和自动拆箱虽然极大地方便了程序员进行代码的编写，但是在使用过程中仍然需要注意以下几点，否则很容易造成错误。</p>
<ul>
<li>基本类型作为函数形参，包装类型作为函数实参，需要保证函数实参是非空的，否则会报空指针异常。因为将一个包装类转为基本类型时，需要调用包装类的 xxxValue 函数，如果此时包装类是 null ，则调用该函数会抛空指针异常。</li>
<li>对于数字参与运算的情况，会自动执行拆箱过程，即将包装类型转成基本类型。</li>
<li>对于 <code>==</code> 的比较情况，如果两边中有任何一边是表达式（即包含算术运算），则会触发自动拆箱的过程，其比较的是比较的是数值，而不是对象地址</li>
<li>对于整数（Long、Integer、Short 类型），一般情况下，<code>-128 ~ 127</code> 这个范围的数字在使用自动装箱时，同一类型下，同一个数字的包装类型返回的是同一个对象。即 <code>Integer a = 3</code> 和 <code>Integer b = 3</code>，其得到的对象的地址是一样的，而对于 <code>Integer c = 1234567</code> 和 <code>Integer d = 1234567</code>，其得到的对象的地址是不同的。这主要是因为在 Long、Integer、Short 这几种类型中，其内部维护了一个缓存数组，放置着 <code>-128 ~ 127</code> 的包装类型，当外部调用 <code>valueOf</code> 函数时，如果其参数在这个范围内，则返回数组中已有的对象，否则新建一个对象返回。下面是 <code>Integer.valueOf</code> 函数的源码，从中可以证明上述结论。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果传入参数在缓存范围内，可返回缓存中已有的对象，否则新建一个对象返回</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="comment">// 为缓存中预置对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>以下例子参考《 深入理解Java虚拟机：JVM高级特性与最佳实践》而来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInteger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">321</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">321</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">3L</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;c == d: &quot;</span> + (c == d));</span><br><span class="line">        System.out.println(<span class="string">&quot;e == f: &quot;</span> + (e == f));</span><br><span class="line">        System.out.println(<span class="string">&quot;c == (a + b): &quot;</span> + (c == (a + b)));</span><br><span class="line">        System.out.println(<span class="string">&quot;c.equals(a + b): &quot;</span> + (c.equals(a + b)));</span><br><span class="line">        System.out.println(<span class="string">&quot;g == (a + b): &quot;</span> + (g == (a + b)));</span><br><span class="line">        System.out.println(<span class="string">&quot;g.equals(a + b): &quot;</span> + (g.equals(a + b)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">c == d: <span class="literal">true</span></span><br><span class="line">e == f: <span class="literal">false</span></span><br><span class="line">c == (a + b): <span class="literal">true</span></span><br><span class="line">c.equals(a + b): <span class="literal">true</span></span><br><span class="line">g == (a + b): <span class="literal">true</span></span><br><span class="line">g.equals(a + b): <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>下面对输出结果进行解释。</p>
<p>首先 <code>c == d</code> 的输出结果：由于 c 和 d 都是对于 3 的封装类型，并且 3 在<code>-128 ~ 127</code> 这个缓存范围内，所以其指向的是同一个对象，所以返回 true。</p>
<p>对于 <code>e == f</code> 的输出结果：虽然 e 和 f 都是 321 的封装类型，但是由于 321 在<code>-128 ~ 127</code> 这个缓存范围外，每次对其进行装箱时都是新建一个对象，所以 e 和 f 实质上指向的是不同的对象，因此返回 false。</p>
<p>对于 <code>c == (a + b)</code> 的输出结果：由于 <code>==</code> 右边是一个运算表达式，所以会将 <code>==</code> 两边都自动拆箱进行数值之间的比较，所以返回的是 true。</p>
<p>对于 <code>c.equals(a + b)</code> 的输出结果：由于 <code>a + b</code> 包含运算符，所以会先将 a 和 b 进行拆箱，然后进行运算，最后将结果进行装箱与 c 进行比较，由于 <code>a + b</code> 运算得到的结果是 3，在<code>-128 ~ 127</code> 这个缓存范围内，所以其装箱后与 c 指向的是同一个对象，因此返回 true。</p>
<p>对于 <code>g == (a + b)</code>  的输出结果：由于 <code>==</code> 右边是一个运算表达式，所以会将 <code>==</code> 两边都自动拆箱进行数值之间的比较，虽然 <code>a + b</code> 得到的结果 <code>3</code> 是 <code>int</code> 类型，但是转成 <code>long</code> 类型后还是数字 3，与 g 的数值是相等的，因此返回 true。</p>
<p>对于 <code>g.equals(a + b)</code> 的输出结果：<code>a + b</code> 先拆箱进行运算，得到数值 <code>3</code>，由于数值是 <code>int</code> 类型，且不是进行 <code>==</code> 数值间的比较，不需要拆箱强制转换成 <code>long</code> 类型，因此其装箱得到的是 <code>Integer</code> 类型，此时再与 g 对象（<code>Long</code> 类型）进行比较，由于 <code>Intege</code> 不是 <code>Long</code> 类型，也不是其子类型，所以其返回 false。这可以从 <code>Long.equals</code> 中看出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Long)obj).longValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面附上反编译后的代码，证明上述结论与分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInteger</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] var0)</span> &#123;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">var2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">2</span>);</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">var3</span> <span class="operator">=</span> Integer.valueOf(<span class="number">3</span>);</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">var4</span> <span class="operator">=</span> Integer.valueOf(<span class="number">3</span>);</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">var5</span> <span class="operator">=</span> Integer.valueOf(<span class="number">321</span>);</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">var6</span> <span class="operator">=</span> Integer.valueOf(<span class="number">321</span>);</span><br><span class="line">      <span class="type">Long</span> <span class="variable">var7</span> <span class="operator">=</span> Long.valueOf(<span class="number">3L</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;c == d: &quot;</span> + (var3 == var4));</span><br><span class="line">      System.out.println(<span class="string">&quot;e == f: &quot;</span> + (var5 == var6));</span><br><span class="line">      System.out.println(<span class="string">&quot;c == (a + b): &quot;</span> + (var3.intValue() == var1.intValue() + var2.intValue()));</span><br><span class="line">      System.out.println(<span class="string">&quot;c.equals(a + b): &quot;</span> + var3.equals(Integer.valueOf(var1.intValue() + var2.intValue())));</span><br><span class="line">      System.out.println(<span class="string">&quot;g == (a + b): &quot;</span> + (var7.longValue() == (<span class="type">long</span>)(var1.intValue() + var2.intValue())));</span><br><span class="line">      System.out.println(<span class="string">&quot;g.equals(a + b): &quot;</span> + var7.equals(Integer.valueOf(var1.intValue() + var2.intValue())));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 中 Class.forName 和 loadClass 的区别</title>
    <url>/java-class-load/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java 中使用默认的加载器来加载类主要有两种方式，一种是 <code>Class.forName</code>，另一种是 <code>loadClass</code>，这两者都有对应重载方法，默认一个参数时，都接收全限定类名，用于加载类，但是其具体含义不同，一个会执行类初始化，一个不会默认执行类初始化。</p>
<span id="more"></span>

<h1 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h1><p><code>Class.forName</code> 有两个重载函数，分别是：<code>Class&lt;?&gt; forName(String className)</code> 和 <code>Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)</code>，其中 <code>forName(String className)</code> 相当于调用 <code>forName(className, true, loader)</code>。更进一步讲，使用<code>Class&lt;?&gt; forName(String className)</code> 默认会执行类的初始化动作。</p>
<p>如下所示，执行 <code>Class&lt;?&gt; forName(String className)</code> 后会输出静态方法和静态代码块的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLoad</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> testMethod();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------static method----------&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------------TestMethod---------------&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------static block------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLoadMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.guozhchun.load.TestLoad&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------class: &quot;</span> + clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------static method----------</span><br><span class="line">------------static block------------</span><br><span class="line">--------class: class com.guozhchun.load.TestLoad</span><br></pre></td></tr></table></figure>

<h1 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h1><p><code>loadClass</code> 也有两个重载函数：<code>loadClass(String name)</code>  和 <code>loadClass(String name, boolean resolve)</code>，其中，<code>loadClass(String name)</code> 相当于调用 <code>loadClass(String name, boolean false)</code>。更进一步讲，使用 <code>loadClass(String name)</code> 默认不会执行类初始化动作。</p>
<p>如下所示，使用 <code>loadClass(String name)</code> 并不会执行类的静态代码块和静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLoad</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> testMethod();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------static method----------&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------------TestMethod---------------&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------static block------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLoadMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Thread.currentThread().getContextClassLoader().loadClass(<span class="string">&quot;com.guozhchun.load.TestLoad&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------class: &quot;</span> + clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------class: class com.guozhchun.load.TestLoad</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Class.forName</code> 和 <code>loadClass</code> 两者都能进行类加载，并且返回 <code>Class&lt;?&gt;</code> 对象，但是<code>Class.forName</code> 默认会执行类初始化动作，<code>loadClass</code> 默认不会执行类初始化动作。在使用上要根据具体特性进行选择，特别是要加载一些第三方类时，可能该类会有静态属性或静态代码块，如果当前虚拟机并不存在该静态代码块中引用的类，那么选择 <code>Class.forName</code> 就可能报错（因为会执行初始化化，会执行静态类代码块，这时候可能要继续加载其他的类，如果该类不存在，那就会报错），此时应该选择 <code>loadClass</code> 会合适点。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java中foreach实现原理</title>
    <url>/java-foreach/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>循环作为程序中经常使用的语句，在java5之后推出了新的for&#x2F;in(foreach)循环方式以方便程序员编写（阅读）代码。这种方式并不是新的语法，只是语法糖。即编写的foreach循环的代码并不是直接转成字节码，而是由编译器先转成对应的语法，然后再转成字节码，可以理解成是编译器对一些语法的封装提供的另一种方便阅读编写功能代码的实现方式。java中提供的foreach语法糖其底层实现方式主要有两种：对于集合类或实现迭代器的集合使用迭代器的遍历方式，对于数组集合使用数组的遍历方法。</p>
<span id="more"></span>

<h1 id="迭代器遍历模式"><a href="#迭代器遍历模式" class="headerlink" title="迭代器遍历模式"></a>迭代器遍历模式</h1><p>对于实现Iterator接口的集合，使用foreach实现循环功能的代码会被编译器转换成使用迭代器遍历集合的代码，然后再转成字节码。例如以下的程序，使用foreach循环遍历ArrayList集合，使用<code>javac TestForEach.java</code>生成字节码后，再使用<code>javap -verbose TestForEach</code>进行反编译，从反编译的结果来看，可以看出其底层是用迭代器模式进行遍历的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestForEach</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        nums.add(<span class="number">11</span>);</span><br><span class="line">        nums.add(<span class="number">22</span>);</span><br><span class="line">        nums.add(<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译结果如下，从中可以看出，在106<del>118这十几行中是对集合进行遍历输出，在106行先使用<code>List.iterator()</code>接口生成迭代器，然后在109</del>118中不断使用<code>Iterator.hasNext()</code>判断是否有下个元素，有则使用<code>Iterator.next()</code>接口获取下个元素并进行输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /C:/Users/zhchun/Desktop/TestForEach.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2018</span>-<span class="number">7</span>-<span class="number">22</span>; size <span class="number">842</span> bytes</span><br><span class="line">  MD5 checksum 45751115d8755b894835c52451125338</span><br><span class="line">  Compiled from <span class="string">&quot;TestForEach.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestForEach</span></span><br><span class="line">  SourceFile: <span class="string">&quot;TestForEach.java&quot;</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">13.</span>#<span class="number">25</span>        <span class="comment">//  java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">26</span>            <span class="comment">//  java/util/ArrayList</span></span><br><span class="line">   #<span class="number">3</span> = Methodref          #<span class="number">2.</span>#<span class="number">25</span>         <span class="comment">//  java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">9.</span>#<span class="number">27</span>         <span class="comment">//  java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">   #<span class="number">5</span> = InterfaceMethodref #<span class="number">28.</span>#<span class="number">29</span>        <span class="comment">//  java/util/List.add:(Ljava/lang/Object;)Z</span></span><br><span class="line">   #<span class="number">6</span> = InterfaceMethodref #<span class="number">28.</span>#<span class="number">30</span>        <span class="comment">//  java/util/List.iterator:()Ljava/util/Iterator;</span></span><br><span class="line">   #<span class="number">7</span> = InterfaceMethodref #<span class="number">31.</span>#<span class="number">32</span>        <span class="comment">//  java/util/Iterator.hasNext:()Z</span></span><br><span class="line">   #<span class="number">8</span> = InterfaceMethodref #<span class="number">31.</span>#<span class="number">33</span>        <span class="comment">//  java/util/Iterator.next:()Ljava/lang/Object;</span></span><br><span class="line">   #<span class="number">9</span> = Class              #<span class="number">34</span>            <span class="comment">//  java/lang/Integer</span></span><br><span class="line">  #<span class="number">10</span> = Fieldref           #<span class="number">35.</span>#<span class="number">36</span>        <span class="comment">//  java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">11</span> = Methodref          #<span class="number">37.</span>#<span class="number">38</span>        <span class="comment">//  java/io/PrintStream.println:(Ljava/lang/Object;)V</span></span><br><span class="line">  #<span class="number">12</span> = Class              #<span class="number">39</span>            <span class="comment">//  TestForEach</span></span><br><span class="line">  #<span class="number">13</span> = Class              #<span class="number">40</span>            <span class="comment">//  java/lang/Object</span></span><br><span class="line">  #<span class="number">14</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">15</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">16</span> = Utf8               Code</span><br><span class="line">  #<span class="number">17</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">18</span> = Utf8               main</span><br><span class="line">  #<span class="number">19</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">20</span> = Utf8               StackMapTable</span><br><span class="line">  #<span class="number">21</span> = Class              #<span class="number">41</span>            <span class="comment">//  java/util/List</span></span><br><span class="line">  #<span class="number">22</span> = Class              #<span class="number">42</span>            <span class="comment">//  java/util/Iterator</span></span><br><span class="line">  #<span class="number">23</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">24</span> = Utf8               TestForEach.java</span><br><span class="line">  #<span class="number">25</span> = NameAndType        #<span class="number">14</span>:#<span class="number">15</span>        <span class="comment">//  &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">26</span> = Utf8               java/util/ArrayList</span><br><span class="line">  #<span class="number">27</span> = NameAndType        #<span class="number">43</span>:#<span class="number">44</span>        <span class="comment">//  valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">  #<span class="number">28</span> = Class              #<span class="number">41</span>            <span class="comment">//  java/util/List</span></span><br><span class="line">  #<span class="number">29</span> = NameAndType        #<span class="number">45</span>:#<span class="number">46</span>        <span class="comment">//  add:(Ljava/lang/Object;)Z</span></span><br><span class="line">  #<span class="number">30</span> = NameAndType        #<span class="number">47</span>:#<span class="number">48</span>        <span class="comment">//  iterator:()Ljava/util/Iterator;</span></span><br><span class="line">  #<span class="number">31</span> = Class              #<span class="number">42</span>            <span class="comment">//  java/util/Iterator</span></span><br><span class="line">  #<span class="number">32</span> = NameAndType        #<span class="number">49</span>:#<span class="number">50</span>        <span class="comment">//  hasNext:()Z</span></span><br><span class="line">  #<span class="number">33</span> = NameAndType        #<span class="number">51</span>:#<span class="number">52</span>        <span class="comment">//  next:()Ljava/lang/Object;</span></span><br><span class="line">  #<span class="number">34</span> = Utf8               java/lang/Integer</span><br><span class="line">  #<span class="number">35</span> = Class              #<span class="number">53</span>            <span class="comment">//  java/lang/System</span></span><br><span class="line">  #<span class="number">36</span> = NameAndType        #<span class="number">54</span>:#<span class="number">55</span>        <span class="comment">//  out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">37</span> = Class              #<span class="number">56</span>            <span class="comment">//  java/io/PrintStream</span></span><br><span class="line">  #<span class="number">38</span> = NameAndType        #<span class="number">57</span>:#<span class="number">58</span>        <span class="comment">//  println:(Ljava/lang/Object;)V</span></span><br><span class="line">  #<span class="number">39</span> = Utf8               TestForEach</span><br><span class="line">  #<span class="number">40</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">41</span> = Utf8               java/util/List</span><br><span class="line">  #<span class="number">42</span> = Utf8               java/util/Iterator</span><br><span class="line">  #<span class="number">43</span> = Utf8               valueOf</span><br><span class="line">  #<span class="number">44</span> = Utf8               (I)Ljava/lang/Integer;</span><br><span class="line">  #<span class="number">45</span> = Utf8               add</span><br><span class="line">  #<span class="number">46</span> = Utf8               (Ljava/lang/Object;)Z</span><br><span class="line">  #<span class="number">47</span> = Utf8               iterator</span><br><span class="line">  #<span class="number">48</span> = Utf8               ()Ljava/util/Iterator;</span><br><span class="line">  #<span class="number">49</span> = Utf8               hasNext</span><br><span class="line">  #<span class="number">50</span> = Utf8               ()Z</span><br><span class="line">  #<span class="number">51</span> = Utf8               next</span><br><span class="line">  #<span class="number">52</span> = Utf8               ()Ljava/lang/Object;</span><br><span class="line">  #<span class="number">53</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">54</span> = Utf8               out</span><br><span class="line">  #<span class="number">55</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">56</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">57</span> = Utf8               println</span><br><span class="line">  #<span class="number">58</span> = Utf8               (Ljava/lang/Object;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TestForEach</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0       </span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span>        </span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/util/ArrayList</span></span><br><span class="line">         <span class="number">3</span>: dup           </span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1      </span><br><span class="line">         <span class="number">8</span>: aload_1       </span><br><span class="line">         <span class="number">9</span>: bipush        <span class="number">11</span></span><br><span class="line">        <span class="number">11</span>: invokestatic  #<span class="number">4</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">        <span class="number">14</span>: invokeinterface #<span class="number">5</span>,  <span class="number">2</span>            <span class="comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span></span><br><span class="line">        <span class="number">19</span>: pop           </span><br><span class="line">        <span class="number">20</span>: aload_1       </span><br><span class="line">        <span class="number">21</span>: bipush        <span class="number">22</span></span><br><span class="line">        <span class="number">23</span>: invokestatic  #<span class="number">4</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">        <span class="number">26</span>: invokeinterface #<span class="number">5</span>,  <span class="number">2</span>            <span class="comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span></span><br><span class="line">        <span class="number">31</span>: pop           </span><br><span class="line">        <span class="number">32</span>: aload_1       </span><br><span class="line">        <span class="number">33</span>: bipush        <span class="number">33</span></span><br><span class="line">        <span class="number">35</span>: invokestatic  #<span class="number">4</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">        <span class="number">38</span>: invokeinterface #<span class="number">5</span>,  <span class="number">2</span>            <span class="comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span></span><br><span class="line">        <span class="number">43</span>: pop           </span><br><span class="line">        <span class="number">44</span>: aload_1       </span><br><span class="line">        <span class="number">45</span>: invokeinterface #<span class="number">6</span>,  <span class="number">1</span>            <span class="comment">// InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;</span></span><br><span class="line">        <span class="number">50</span>: astore_2      </span><br><span class="line">        <span class="number">51</span>: aload_2       </span><br><span class="line">        <span class="number">52</span>: invokeinterface #<span class="number">7</span>,  <span class="number">1</span>            <span class="comment">// InterfaceMethod java/util/Iterator.hasNext:()Z</span></span><br><span class="line">        <span class="number">57</span>: ifeq          <span class="number">80</span></span><br><span class="line">        <span class="number">60</span>: aload_2       </span><br><span class="line">        <span class="number">61</span>: invokeinterface #<span class="number">8</span>,  <span class="number">1</span>            <span class="comment">// InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;</span></span><br><span class="line">        <span class="number">66</span>: checkcast     #<span class="number">9</span>                  <span class="comment">// class java/lang/Integer</span></span><br><span class="line">        <span class="number">69</span>: astore_3      </span><br><span class="line">        <span class="number">70</span>: getstatic     #<span class="number">10</span>                 <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">73</span>: aload_3       </span><br><span class="line">        <span class="number">74</span>: invokevirtual #<span class="number">11</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span></span><br><span class="line">        <span class="number">77</span>: goto          <span class="number">51</span></span><br><span class="line">        <span class="number">80</span>: <span class="keyword">return</span>        </span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">20</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">32</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">44</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">70</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">77</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">80</span></span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">           frame_type = <span class="number">253</span> <span class="comment">/* append */</span></span><br><span class="line">          offset_delta = <span class="number">51</span></span><br><span class="line">          locals = [ <span class="keyword">class</span> <span class="title class_">java</span>/util/List, <span class="keyword">class</span> <span class="title class_">java</span>/util/Iterator ]</span><br><span class="line">             frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">            offset_delta = <span class="number">28</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>因此，上面使用foreach方式遍历集合的程序与下面使用迭代器模式进行遍历的程序是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestForEach</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        nums.add(<span class="number">11</span>);</span><br><span class="line">        nums.add(<span class="number">22</span>);</span><br><span class="line">        nums.add(<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处没有使用泛型，因为泛型在java中也是一种语法糖，只是编译器提供的一种检查，在运行期会擦除类型信息，其并不像C++那样在语法层面真正的支持泛型</span></span><br><span class="line">        <span class="comment">// 当然，为了良好的编码习惯，在平时的编码中应该使用泛型，即Iterator&lt;Integer&gt; iter = nums.iterator();</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> nums.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> (Integer)iter.next();</span><br><span class="line">            System.out.println(num);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组依次遍历模式"><a href="#数组依次遍历模式" class="headerlink" title="数组依次遍历模式"></a>数组依次遍历模式</h1><p>数组没有实现Iterator接口，但是又要支持foreach语法糖，所以就用了最原始的最基本的依次遍历数组中的每个元素的方式来实现。如下代码是数组用foreach方式实现的遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestForEach</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样使用<code>javac TestForEach.java</code>生成字节码后，再使用<code>javap -verbose TestForEach</code>进行反编译，输出结果如下。从中可以看出，从80~92这十几行是对数组进行遍历输出，这个过程没有使用迭代器，只是不断的对数进行出栈、比较、入栈、输出结果的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /C:/Users/zhchun/Desktop/TestForEach.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2018</span>-<span class="number">7</span>-<span class="number">22</span>; size <span class="number">528</span> bytes</span><br><span class="line">  MD5 checksum 874d6164dd77ec1874a96f4adb7d884b</span><br><span class="line">  Compiled from <span class="string">&quot;TestForEach.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestForEach</span></span><br><span class="line">  SourceFile: <span class="string">&quot;TestForEach.java&quot;</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">5.</span>#<span class="number">17</span>         <span class="comment">//  java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">18.</span>#<span class="number">19</span>        <span class="comment">//  java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = Methodref          #<span class="number">20.</span>#<span class="number">21</span>        <span class="comment">//  java/io/PrintStream.println:(I)V</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">22</span>            <span class="comment">//  TestForEach</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">23</span>            <span class="comment">//  java/lang/Object</span></span><br><span class="line">   #<span class="number">6</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">7</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">8</span> = Utf8               Code</span><br><span class="line">   #<span class="number">9</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">10</span> = Utf8               main</span><br><span class="line">  #<span class="number">11</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">12</span> = Utf8               StackMapTable</span><br><span class="line">  #<span class="number">13</span> = Class              #<span class="number">24</span>            <span class="comment">//  &quot;[Ljava/lang/String;&quot;</span></span><br><span class="line">  #<span class="number">14</span> = Class              #<span class="number">25</span>            <span class="comment">//  &quot;[I&quot;</span></span><br><span class="line">  #<span class="number">15</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">16</span> = Utf8               TestForEach.java</span><br><span class="line">  #<span class="number">17</span> = NameAndType        #<span class="number">6</span>:#<span class="number">7</span>          <span class="comment">//  &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">18</span> = Class              #<span class="number">26</span>            <span class="comment">//  java/lang/System</span></span><br><span class="line">  #<span class="number">19</span> = NameAndType        #<span class="number">27</span>:#<span class="number">28</span>        <span class="comment">//  out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">20</span> = Class              #<span class="number">29</span>            <span class="comment">//  java/io/PrintStream</span></span><br><span class="line">  #<span class="number">21</span> = NameAndType        #<span class="number">30</span>:#<span class="number">31</span>        <span class="comment">//  println:(I)V</span></span><br><span class="line">  #<span class="number">22</span> = Utf8               TestForEach</span><br><span class="line">  #<span class="number">23</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">24</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">25</span> = Utf8               [I</span><br><span class="line">  #<span class="number">26</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">27</span> = Utf8               out</span><br><span class="line">  #<span class="number">28</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">29</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">30</span> = Utf8               println</span><br><span class="line">  #<span class="number">31</span> = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TestForEach</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0       </span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span>        </span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">4</span>, locals=<span class="number">6</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_3      </span><br><span class="line">         <span class="number">1</span>: newarray       <span class="type">int</span></span><br><span class="line">         <span class="number">3</span>: dup           </span><br><span class="line">         <span class="number">4</span>: iconst_0      </span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">11</span></span><br><span class="line">         <span class="number">7</span>: iastore       </span><br><span class="line">         <span class="number">8</span>: dup           </span><br><span class="line">         <span class="number">9</span>: iconst_1      </span><br><span class="line">        <span class="number">10</span>: bipush        <span class="number">22</span></span><br><span class="line">        <span class="number">12</span>: iastore       </span><br><span class="line">        <span class="number">13</span>: dup           </span><br><span class="line">        <span class="number">14</span>: iconst_2      </span><br><span class="line">        <span class="number">15</span>: bipush        <span class="number">33</span></span><br><span class="line">        <span class="number">17</span>: iastore       </span><br><span class="line">        <span class="number">18</span>: astore_1      </span><br><span class="line">        <span class="number">19</span>: aload_1       </span><br><span class="line">        <span class="number">20</span>: astore_2      </span><br><span class="line">        <span class="number">21</span>: aload_2       </span><br><span class="line">        <span class="number">22</span>: arraylength   </span><br><span class="line">        <span class="number">23</span>: istore_3      </span><br><span class="line">        <span class="number">24</span>: iconst_0      </span><br><span class="line">        <span class="number">25</span>: istore        <span class="number">4</span></span><br><span class="line">        <span class="number">27</span>: iload         <span class="number">4</span></span><br><span class="line">        <span class="number">29</span>: iload_3       </span><br><span class="line">        <span class="number">30</span>: if_icmpge     <span class="number">53</span></span><br><span class="line">        <span class="number">33</span>: aload_2       </span><br><span class="line">        <span class="number">34</span>: iload         <span class="number">4</span></span><br><span class="line">        <span class="number">36</span>: iaload        </span><br><span class="line">        <span class="number">37</span>: istore        <span class="number">5</span></span><br><span class="line">        <span class="number">39</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">42</span>: iload         <span class="number">5</span></span><br><span class="line">        <span class="number">44</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">47</span>: iinc          <span class="number">4</span>, <span class="number">1</span></span><br><span class="line">        <span class="number">50</span>: goto          <span class="number">27</span></span><br><span class="line">        <span class="number">53</span>: <span class="keyword">return</span>        </span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">19</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">39</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">47</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">53</span></span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">           frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">27</span></span><br><span class="line">          locals = [ class <span class="string">&quot;[Ljava/lang/String;&quot;</span>, class <span class="string">&quot;[I&quot;</span>, class <span class="string">&quot;[I&quot;</span>, <span class="type">int</span>, <span class="type">int</span> ]</span><br><span class="line">          stack = []</span><br><span class="line">           frame_type = <span class="number">248</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">25</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于用foreach方式实现的数组遍历方式，与下面的依次遍历数组中每个元素的方式是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestForEach</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>虽然foreach方便了程序的编写和阅读，是遍历集合和数组的一种好方式，但是使用foreach进行集合遍历时需要额外注意不能对集合长度进行修改，也就是不能对集合进行增删操作，否则会抛出<code>ConcurrentModificationException</code>异常。例如，下面程序会在执行第13行时抛出<code>ConcurrentModificationException</code>异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestForEach</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        nums.add(<span class="number">11</span>);</span><br><span class="line">        nums.add(<span class="number">22</span>);</span><br><span class="line">        nums.add(<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">11</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 此处使用集合中的remove操作，而不是迭代器中的remove操作，会导致迭代器中的expectedModCount和集合中的modCount变量不相等，从而导致在执行next()函数时抛出异常</span></span><br><span class="line">                nums.remove((Integer)num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然ArrayList的foreach底层用迭代器实现，迭代器也支持在遍历集合的过程中进行删除元素的操作，但是删除的函数必须是迭代器的函数，而不是集合自有的函数。至于上述代码为什么会抛出<code>ConcurrentModificationException</code>异常，可以从ArrayList中的迭代器类找到答案。ArrayList中部分源码如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayList中删除函数源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList中删除函数源码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList中迭代器函数源码</span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList中迭代器类源码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">            <span class="comment">// 此处重新赋值，避免跳过下一个元素</span></span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 此处重新赋值，避免下次调用next()函数时校验不通过抛出异常</span></span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; consumer)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(consumer);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.size;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">            consumer.accept((E) elementData[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">        cursor = i;</span><br><span class="line">        lastRet = i - <span class="number">1</span>;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行<code>for (Integer num : nums)</code>语句时，会先调用ArrayList中的iterator()接口生成迭代器，而在初始化<code>Itr</code>类时会先将ArrayList对象中的<code>modCount</code>变量赋给Itr对象中的<code>expectedModCount</code>变量，在调用迭代器的<code>next</code>函数时会先调用<code>checkForComodification</code>函数进行校验，如果<code>expectedModCount</code>和<code>modCount</code>不相等则会抛出<code>ConcurrentModificationException</code>异常。在正常的集合遍历中，一般情况下，我们只使用迭代器中<code>hasNext</code>和<code>next</code>函数，并不会改变<code>expectedModCount</code>或者<code>modCount</code>的值，所以不会有问题，但是如果在遍历中调用了集合中自有的删除函数操作，则会改变<code>modCount</code>的值，从而导致<code>expectedModCount</code>与<code>modCount</code>不相等，进而在调用迭代器的<code>next</code>函数时进行校验不通过产生<code>ConcurrentModificationException</code>异常。而在遍历中调用迭代器的删除函数操作，由于其内部会在删除元素后对<code>expectedModCount</code>重新赋值，使其与<code>modCount</code>值相等，所以在遍历集合的过程中使用迭代器的删除函数操作不会有问题。</p>
<p>正确的在遍历集合过程中进行删除操作的方式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestForEach</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        nums.add(<span class="number">11</span>);</span><br><span class="line">        nums.add(<span class="number">22</span>);</span><br><span class="line">        nums.add(<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; iter = nums.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> iter.next();</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">11</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 在迭代器遍历中，不能使用集合自有的删除操作，只能使用迭代器中的删除操作，否则会导致迭代器中的expectedModCount和集合中的modCount变量不相等，从而导致在执行next()函数时抛出异常</span></span><br><span class="line">                <span class="comment">//nums.remove((Integer)num);</span></span><br><span class="line">                iter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(num);   </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 朱小厮. Java语法糖之foreach[J&#x2F;OL]. <a href="https://blog.csdn.net/u013256816/article/details/50736498">https://blog.csdn.net/u013256816/article/details/50736498</a> , 2016-02-25 </p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 泛型</title>
    <url>/java-generic/</url>
    <content><![CDATA[<h1 id="为什么使用泛型"><a href="#为什么使用泛型" class="headerlink" title="为什么使用泛型"></a>为什么使用泛型</h1><p>大部分情况下，类和方法中用到的参数或变量都是基本类型或者是某种具体的类型（Integer、String 或 自己编写的类······）。这样做的好处是代码阅读起来很清晰。但是，如果要对多种不同的类型使用相同的功能，仍然采用具体的类型就会产生很多重复的代码，而采用 <code>Object</code> 类型代替所有类型虽然能消除重复代码，但是却存在多种类型混用导致转换错误的隐患。而泛型刚好融合了上述两种方式的优点，既能够用一套代码达到重复利用的目的，也能避免多种类型混用的强制转换错误隐患的发生。</p>
<span id="more"></span>

<p>假设现在要分别对 <code>Integer</code> 和 <code>String</code> 类型实现存储和读取，用三种方式实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：底层分别用 Integer 和 String 实现，写成 IntegerArrayList 和 StringArrayList 两个类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntegerArrayList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer[] elements;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        <span class="keyword">return</span> elements[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, Integer element)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        elements[i] = element;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringArrayList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] elements;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        <span class="keyword">return</span> elements[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, String element)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        elements[i] = element;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一调用</span></span><br><span class="line"><span class="type">IntegerArrayList</span> <span class="variable">integerArrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntegerArrayList</span>();</span><br><span class="line">integerArrayList.add(<span class="number">0</span>, <span class="number">1</span>);        <span class="comment">// OK</span></span><br><span class="line">integerArrayList.add(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>);  <span class="comment">// 编译报错，类型不匹配</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> integerArrayList(<span class="number">0</span>);   <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringArrayList</span> <span class="variable">stringArrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringArrayList</span>();</span><br><span class="line">stringArrayList.add(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>);   <span class="comment">// OK</span></span><br><span class="line">stringArrayList.add(<span class="number">0</span>, <span class="number">1</span>);         <span class="comment">// 编译报错，类型不匹配</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> stringArrayList.get(<span class="number">0</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二： 用 Object 实现，允许不同类型混用，存在类型强制转换报错风险</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectArrayList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        <span class="keyword">return</span> elements[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, Object element)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        elements[i] = element;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二调用</span></span><br><span class="line"><span class="type">ObjectArrayList</span> <span class="variable">objectArrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectArrayList</span>();</span><br><span class="line">objectArrayList.add(<span class="number">0</span>, <span class="number">1</span>);        <span class="comment">// OK</span></span><br><span class="line">objectArrayList.add(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>);  <span class="comment">// OK</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> (Integer) objectArrayList.get(<span class="number">0</span>); <span class="comment">// 运行时报强制类型转换错误，String不能转Integer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> (String) objectArrayList.get(<span class="number">0</span>);   <span class="comment">// 0K</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericArrayList</span>&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> E[] elements;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        <span class="keyword">return</span> elements[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, E element)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        elements[i] = element;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三调用</span></span><br><span class="line">GenericArrayList&lt;Integer&gt; genericArrayList = <span class="keyword">new</span> <span class="title class_">GenericArrayList</span>&lt;&gt;();</span><br><span class="line">genericArrayList.add(<span class="number">0</span>, <span class="number">1</span>);       <span class="comment">// OK</span></span><br><span class="line">genericArrayList.add(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>); <span class="comment">// 编译报错，类型不匹配</span></span><br></pre></td></tr></table></figure>

<p>从上述例子中可以看出，使用泛型，可以消除重复的功能代码，也能让某块功能只保持一种类型，避免多种不同类型混用，同时能够在编译时期发现不合法的强制类型转换，避免将错误遗留到运行期。</p>
<h1 id="泛型的用法"><a href="#泛型的用法" class="headerlink" title="泛型的用法"></a>泛型的用法</h1><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型用在类上时，需要在定义类名后面用 <code>&lt;&gt;</code> 表明，<code>&lt;&gt;</code> 里面的 <code>E</code> 表示某种类型，<code>E</code> 可以是其他的字母，如果有多种不同的类型，可以通用 <code>,</code> 隔开，如定义 <code>map</code> 时用 <code>&lt;K, V&gt;</code>。</p>
<p>在创建泛型类的对象实例时，需要将具体的类型传入，如 <code>new GenericArrayList&lt;Integer&gt; </code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericArrayList</span>&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> E[] elements;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        <span class="keyword">return</span> elements[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, E element)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        elements[i] = element;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型用在接口上时，其定义跟泛型类一样。但是在实现类中，需要将实现类也声明为泛型类；或者将具体的类型传入接口的泛型参数，此时，在实现类中，接口中的相关泛型参数会被替换具体的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericInterface</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类：接口中传入具体的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericInterfaceImpl</span> implement GenericInterface&lt;Integer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(Integer t)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类：接口中不传入具体类型，但是将实现类定位为泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;T&gt; implement GenericInterface&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(T t)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型同样可以用于方法，用于方法时，此泛型参数跟类（或者接口）中的泛型参数并无任何关系。另外，如果泛型参数没有指定边界时，此时跟用 <code>Object</code> 类型效果相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法等价，而且不能同时出现，因为泛型擦除后也是 Object 类型，变成同名同类型函数，无法通过编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Object obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(obj.getClass().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(T t)</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(t.getClass().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用输出，无论调用上面哪种写法的函数，输出结果相同。</span></span><br><span class="line">print(<span class="string">&quot;&quot;</span>);    <span class="comment">// java.lang.String</span></span><br><span class="line">print(<span class="number">1</span>);     <span class="comment">// java.lang.Integer</span></span><br><span class="line">print(<span class="number">1.0</span>);   <span class="comment">// java.lang.Double</span></span><br><span class="line">print(<span class="number">1.0F</span>);  <span class="comment">// java.lang.Float</span></span><br><span class="line">print(<span class="string">&#x27;c&#x27;</span>);   <span class="comment">// java.lang.Character</span></span><br></pre></td></tr></table></figure>

<h1 id="泛型的原理"><a href="#泛型的原理" class="headerlink" title="泛型的原理"></a>泛型的原理</h1><p>java 中的泛型和 C++ 中的泛型不同，C++ 中的泛型是强泛型，在编译期和运行期都持有泛型的信息，而 java 中的泛型是一个<em>假泛型</em>，或者说是一个语法糖，其信息只保留到编译期的静态类型检查（语义分析中的第一部分），在此之后，泛型信息将被擦除（语义分析中另一部分：解语法糖），无法保留到运行期。也就是说，泛型只是为了方便代码的编写，其本质上跟原型类型并无太大差别。</p>
<h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界，如 <code>List&lt;? extend Integer&gt;</code> 将被擦除为 <code>List&lt;Integer&gt;</code>，<code>List&lt;T&gt;</code> 将被擦除为 <code>List&lt;Object&gt;</code> ，而普通的类型变量在未指定边界的情况下将被查出为 <code>Object</code>，如 <code>T</code>  被擦除为 <code>Object</code>。</p>
<p>下面两个程序，是用 <code>Object</code> 和泛型实现的同一个功能，对某个元素进行赋值和读取的操作。从反编译出来的字节码可以看到，两者在进行相关函数的操作时动作是完全一样的。也就是说泛型类型 <code>String</code> 并没有保留到字节码中，在进行 <code>get</code> 操作时，仍然要进行类型转换（<code>checkcast</code> 指令），但是在源码中并没有这一步，这一步其实是编译器自动补充进去的。</p>
<p>使用 <code>Object</code> 类型实现的类及其字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHolder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object obj)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">SimpleHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHolder</span>();</span><br><span class="line">        holder.set(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节码</span></span><br><span class="line">Compiled from <span class="string">&quot;SimpleHolder.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHolder</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SimpleHolder</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(java.lang.Object)</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: aload_1       </span><br><span class="line">       <span class="number">2</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field obj:Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.Object <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field obj:Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">4</span>: areturn       </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class SimpleHolder</span></span><br><span class="line">       <span class="number">3</span>: dup           </span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1      </span><br><span class="line">       <span class="number">8</span>: aload_1       </span><br><span class="line">       <span class="number">9</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String hello world</span></span><br><span class="line">      <span class="number">11</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method set:(Ljava/lang/Object;)V</span></span><br><span class="line">      <span class="number">14</span>: aload_1       </span><br><span class="line">      <span class="number">15</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method get:()Ljava/lang/Object;</span></span><br><span class="line">      <span class="number">18</span>: checkcast     #<span class="number">8</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">      <span class="number">21</span>: astore_2      </span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型实现的类及其字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericHolder</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T obj)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GenericHolder&lt;String&gt; holder = <span class="keyword">new</span> <span class="title class_">GenericHolder</span>&lt;&gt;();</span><br><span class="line">        holder.set(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节码</span></span><br><span class="line">Compiled from <span class="string">&quot;GenericHolder.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericHolder</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">GenericHolder</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T)</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: aload_1       </span><br><span class="line">       <span class="number">2</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field obj:Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field obj:Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">4</span>: areturn       </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class GenericHolder</span></span><br><span class="line">       <span class="number">3</span>: dup           </span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1      </span><br><span class="line">       <span class="number">8</span>: aload_1       </span><br><span class="line">       <span class="number">9</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String hello world</span></span><br><span class="line">      <span class="number">11</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method set:(Ljava/lang/Object;)V</span></span><br><span class="line">      <span class="number">14</span>: aload_1       </span><br><span class="line">      <span class="number">15</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method get:()Ljava/lang/Object;</span></span><br><span class="line">      <span class="number">18</span>: checkcast     #<span class="number">8</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">      <span class="number">21</span>: astore_2      </span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型擦除的问题"><a href="#泛型擦除的问题" class="headerlink" title="泛型擦除的问题"></a>泛型擦除的问题</h2><p>泛型擦除会给函数重载、<code>instanceof</code>、泛型实例化带来问题。如下所示，代码均由于泛型擦除而无法通过编译。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestGeneric</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 编译报错，print(Object obj) 泛型擦除后与 print(Object obj) 有相同的函数签名 </span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(E e)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Object obj)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译报错，List&lt;String&gt; list 和 print(List&lt;Integer&gt; list) 泛型擦除后有相同的函数签名 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;String&gt; list)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;Integer&gt; list)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T obj)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 编译报错，运行其没有具体的类型信息，无法进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> T) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 编译报错，运行其没有具体的类型信息，无法新建具体实例</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 编译报错，运行其没有具体的类型信息，无法新建具体类型的数组</span></span><br><span class="line">        T[] array = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于泛型的类型判断，虽然无法通过 <code>instanceof</code> 来完成，但是可以通过 <code>isInstance</code> 来判断，不过此时，需要传入一个 <code>class</code> 对象，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericType</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; kind</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericType</span><span class="params">(Class&lt;T&gt; kind)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInstance</span><span class="params">(Object obj)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> kind.isInstance(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GenericType&lt;Integer&gt; genericType = <span class="keyword">new</span> <span class="title class_">GenericType</span>&lt;&gt;(Integer.class);</span><br><span class="line">        System.out.println(genericType.isInstance(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>)));  <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于创建泛型的实例，稍微麻烦一点，需要通过工厂类的方式来创建，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Factory</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T <span class="title function_">create</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntegerFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span>&lt;Integer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">create</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>泛型会擦除，那对于以下代码，都会把泛型类型 <code>String</code> 和 <code>Integer</code> 都擦除成 <code>Object</code> ，但是为什么编译器仍然报错了呢。主要原因是，在编译期间，有很多步骤，在语义分析阶段，会先进行标注检查（包含静态类型检查），然后再进行解语法糖（泛型擦除），而在静态类型检查时，泛型类型的信息仍然存在，此时 <code>ArrayList&lt;Integer&gt;</code> 类型的参数无法转成 <code>ArrayList&lt;String&gt;</code> 类型，无法通过编译，根本就没有到达泛型擦除那部分，所以即使泛型擦除后两者是一致的，但是仍然无法通过编译，而这也是 java 提供泛型的一个初衷：将问题提前在编译期暴露出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br></pre></td></tr></table></figure>

<h1 id="泛型边界"><a href="#泛型边界" class="headerlink" title="泛型边界"></a>泛型边界</h1><h2 id="上界通配符-lt-extend-T-gt"><a href="#上界通配符-lt-extend-T-gt" class="headerlink" title="上界通配符 &lt;? extend T&gt;"></a>上界通配符 &lt;? extend T&gt;</h2><p><code>&lt;? extend T&gt;</code> 表示能接受的泛型类型是 <code>T</code> 或者 <code>T</code> 的子类，如 <code>&lt;? extend Number&gt;</code> 表示接受的泛型类型是 <code>Number</code> 或 <code>Number</code> 的子类。对于上界通配符，对于 <code>T</code> 的子类，只允许读操作（类似 <code>List.get</code> 的操作），不允许写操作（类似 <code>List.add</code> 操作）。</p>
<p>因为泛型擦除会替换为它们的非泛型<strong>上界</strong>，所以使用 <code>List&lt;? extend T&gt;</code> 在泛型擦除后，实际上变成 <code>List&lt;T&gt;</code> 类型，对于 <code>T</code> 的子类，类型不匹配，无法添加进去，所以上界通配符对于子类是不支持写操作的。</p>
<p>另一方面，对于读操作，由于获取出来的元素都是 <code>T</code> 及 <code>T</code> 的子类，所以可以直接用 <code>T</code> 类型来表示，因此上界通配符对于子类是支持读操作的。</p>
<h2 id="下界通配符-lt-super-T-gt"><a href="#下界通配符-lt-super-T-gt" class="headerlink" title="下界通配符 &lt;? super T&gt;"></a>下界通配符 &lt;? super T&gt;</h2><p><code>&lt;? super T&gt;</code> 表示接受的泛型类型是 <code>T</code> 或者 <code>T</code> 的父类（祖先类），如 <code>&lt;? super Integer&gt;</code> 表示接受的泛型类型是 <code>Integer</code> 或者 <code>Integer</code> 的父类（如 <code>Number</code>）。对于下界通配符，对于 <code>T</code> 的父类（祖先类），只允许写操作（类似 <code>List.add</code> 的操作），不允许读操作（类似 <code>List.get</code> 操作）。</p>
<p>因为泛型擦除会替换为它们的非泛型<strong>上界</strong>，而 <code>List&lt;? super T&gt;</code> 并没有明确其上边界，所以其上边界是 <code>Object</code>。那么在泛型擦除后，其会变成 <code>List&lt;Object&gt;</code>，自然所有的类型都能放进去（<code>T</code> 的子类放不进去是因为类型校验失败），所以下界通配符对于父类（祖先类）是支持写操作的。</p>
<p>另一方面，对于读操作，因为集合中存放的是 <code>T</code> 及 <code>T</code> 的祖先类，无法用 <code>T</code> 类型来统一表示（会发生类型转换错误）。所以，下界通配符对于父类（祖先类）是不支持读操作的。</p>
<h2 id="无界通配符-lt-gt"><a href="#无界通配符-lt-gt" class="headerlink" title="无界通配符&lt;?&gt;"></a>无界通配符&lt;?&gt;</h2><p>无界通配符（如 <code>List&lt;?&gt;</code>）表示可以使用任何对象，因此使用它类似于使用原生类型(如 <code>List</code>)。但它跟原生类型又有点差别，原先类型可以持有任何类型，而无界通配符修饰的容器持有的是某种具体的类型。</p>
<h2 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h2><p><code>PECS</code> 是  <code>Producer Extends,Consumer Super</code>  的缩写。主要是为了判断什么情况下用 <code>extend</code>，什么情况下用 <code>supper</code>。其说明如下</p>
<p>从集合的角度出发看问题，如果从集合中取数据，则集合是生产者，用 <code>? extend T</code>。如果往集合中放数据，则集合是消费者，用 <code>? supper</code>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p> [1] Eckel,B. Java编程思想（第四版）[M]. 北京：机械工业出版社，2007.6 </p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java标签（label）的使用</title>
    <url>/java-label/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看一些源码的过程中发现使用了标签，当时竟然看不懂，在搜索了一下之后才发现这是 java 标签的用法。这在平时工作中很少用到，甚至都记不起来 java 还有这一个特性。所以，趁着这次机会，把 java 标签复习和记录一下，以便后续再出现类似的情况时能快速找到资料进行复习。</p>
<span id="more"></span>

<h1 id="java-标签的形式"><a href="#java-标签的形式" class="headerlink" title="java 标签的形式"></a>java 标签的形式</h1><p>java 标签是由一个字符串名称和一个冒号组成的标识符，如：<code>label:</code>。其唯一其作用的地方是刚好在迭代语句之前。也就是说，在标签和迭代语句之间不能有任何其他的代码，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label:  <span class="comment">// can not write any other code here </span></span><br><span class="line"><span class="keyword">while</span> (condition) &#123;&#125;</span><br><span class="line"></span><br><span class="line">label: <span class="comment">// can not write any other code here </span></span><br><span class="line"><span class="keyword">for</span> (condition)</span><br></pre></td></tr></table></figure>

<h1 id="java-标签的作用"><a href="#java-标签的作用" class="headerlink" title="java 标签的作用"></a>java 标签的作用</h1><p>java 标签只有配合迭代语句一起使用才能发挥作用，这也是其唯一其作用的地方。其主要作用是用于控制循环的跳转和中断循环。当然，这两个功能单独由 <code>continue</code> 和 <code>break</code> 语句也能做到。但是单独地使用 <code>continue</code> 和 <code>break</code> 语句只是针对一个循环的，并不能控制外层的嵌套循环的跳转。如果将 java 标签和 <code>continue</code>、<code>break</code> 语句结合使用，就能控制外层嵌套的循环跳转，而这也正是 java 标签的独特之处。</p>
<h1 id="java-标签的用法"><a href="#java-标签的用法" class="headerlink" title="java 标签的用法"></a>java 标签的用法</h1><p>java 标签是放在循环语句之前，与 <code>continue</code> 和 <code>break</code> 语句相结合使用的。其形式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">outerLabel:</span><br><span class="line">outer-iteration</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    innerLabel:</span><br><span class="line">    inner-iteration</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 此语句作用相同于单独使用 ‘continue;’</span></span><br><span class="line">        <span class="comment">// 都是跳过本次内部的循环，进入下一次内部循环中</span></span><br><span class="line">        <span class="keyword">continue</span> innerLabel;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 此语句作用相当于单独使用 ‘break;’</span></span><br><span class="line">        <span class="comment">// 都是跳出内部循环，继续执行外层循环</span></span><br><span class="line">        <span class="keyword">break</span> innerLabel;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 此语句作用是调出内部循环，同时跳过本次的外层循环，进入下一次的外层循环中</span></span><br><span class="line">        <span class="comment">// 这是单独使用一个 ‘continue‘ 或 ’break’ 无法做到的</span></span><br><span class="line">        <span class="comment">// 如果要实现类似的功能，需要在此处设置一个标志位，然后使用 &#x27;break&#x27; 中断内部循环</span></span><br><span class="line">        <span class="comment">// 然后再在外部循环中对该标志位进行判断，同时使用 &#x27;continue&#x27; 语句跳过外部的循环</span></span><br><span class="line">        <span class="comment">// 这样操作起来不如直接使用 &#x27;continue outerLabel;&#x27; 简洁清晰</span></span><br><span class="line">        <span class="keyword">continue</span> outerLabel;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 此语句作用是跳出内部循环和外部循环，即直接结束整个外层循环体（终止了两个循环）</span></span><br><span class="line">        <span class="comment">// 这是单独使用一个 ‘continue‘ 或 ’break’ 无法做到的</span></span><br><span class="line">        <span class="comment">// 如果要实现类似的功能，需要在此处设置一个标志位，然后使用 &#x27;break&#x27; 中断内部循环</span></span><br><span class="line">        <span class="comment">// 然后再在外部循环中对该标志位进行判断，同时使用 &#x27;break&#x27; 语句跳出外部的循环</span></span><br><span class="line">        <span class="comment">// 这样操作起来不如直接使用 &#x27;break outerLabel;&#x27; 简洁清晰</span></span><br><span class="line">        <span class="keyword">break</span> outerLabel;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="java-标签的样例"><a href="#java-标签的样例" class="headerlink" title="java 标签的样例"></a>java 标签的样例</h1><p>以下是使用 java 标签的样例。有 10 此外层循环和 3 次内层循环。为了方便观察验证 continue 和 break 的区别，每次执行到第二次内层循环时，进行相应的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLabel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====Begin====&quot;</span>);</span><br><span class="line">        outerLoop:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            innerLoop:</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j + <span class="string">&quot; -- continue innerLoop&quot;</span>);</span><br><span class="line">                    <span class="comment">// 会跳过内部循环，开始下一轮的内部循环</span></span><br><span class="line">                    <span class="keyword">continue</span> innerLoop;  <span class="comment">// same with continue;(without using label)</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">2</span> &amp;&amp; j == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j + <span class="string">&quot; -- break innerLoop&quot;</span>);</span><br><span class="line">                    <span class="comment">// 会结束内部循环，但是不影响外部循环</span></span><br><span class="line">                    <span class="keyword">break</span> innerLoop;  <span class="comment">// same with break;(without using label)</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">3</span> &amp;&amp; j == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j + <span class="string">&quot; -- continue outerLoop&quot;</span>);</span><br><span class="line">                    <span class="comment">// 会跳过内部循环和外部循环，开始下一轮的外部循环</span></span><br><span class="line">                    <span class="keyword">continue</span> outerLoop;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">4</span> &amp;&amp; j == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j + <span class="string">&quot; -- break outerLoop&quot;</span>);</span><br><span class="line">                    <span class="comment">// 会结束内部循环和外部循环，执行循环块后面的语句</span></span><br><span class="line">                    <span class="keyword">break</span> outerLoop;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;====End====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>样例输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">====Begin====</span><br><span class="line">i = 0, j = 0</span><br><span class="line">i = 0, j = 1</span><br><span class="line">i = 0, j = 2</span><br><span class="line">------------</span><br><span class="line">i = 1, j = 0</span><br><span class="line">i = 1, j = 1 -- continue innerLoop</span><br><span class="line">i = 1, j = 2</span><br><span class="line">------------</span><br><span class="line">i = 2, j = 0</span><br><span class="line">i = 2, j = 1 -- break innerLoop</span><br><span class="line">------------</span><br><span class="line">i = 3, j = 0</span><br><span class="line">i = 3, j = 1 -- continue outerLoop</span><br><span class="line">i = 4, j = 0</span><br><span class="line">i = 4, j = 1 -- break outerLoop</span><br><span class="line">====End====</span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出：<code>continue label</code> 语句会直接跳过循环中该语句后面的部分，直接跳到 label 处，执行下一个循环，而 <code>break label</code> 语句会直接跳过循环中该语句后面的部分，直接跳到 label 处，然后结束循环，执行循环块后面的代码。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>java 标签必须与循环语句使用，是循环语句的前面一个语句，才能发挥其效果。</li>
<li><code>continue label</code> 语句会跳过循环块中后面的语句，直接跳到 <code>label</code> 处，然后执行下一个循环。</li>
<li><code>break label</code> 语句会跳过循环块中后面的语句，直接跳到 <code>label</code> 处，然后结束循环，执行循环代码块后面的语句。</li>
<li>在嵌套循环中，要在内部循环中直接控制外部循环的跳转，使用 java 标签语句可以更加简洁清晰地完成功能，特别是对于嵌套了多层内部循环的情况下更能体现其威力。</li>
<li>引申一下，可以设想每个循环都有一个标签（没写的系统默认补上），单独使用 <code>continue</code> 语句就是使用 <code>continue label</code> 语句（系统自动转换），单独使用 <code>break</code> 语句就是使用 <code>break label</code> 语句（系统自动转换），其效果是完全一样的。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Eckel,B. Java编程思想（第四版）[M]. 北京：机械工业出版社，2007.6</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 线程安全</title>
    <url>/java-safe-thread/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<p>当多个线程访问某个对象时，不管运行是环境采用何种调度方式或者这些线程将如何交替执行，并且爱主调代码中不需要任何额外的同步或协同，这个对象都能表现出正确的行为，那么就称这个对象是线程安全的。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;——《Java 并发编程实战》</p>
</blockquote>
<p>这个定义是严谨的，但是看起来有点绕，稍微不严谨一点的说法就是：当一段代码能够在多线程环境下正常运行得到正确结果，那这段代码就是线程安全的。</p>
<span id="more"></span>

<h1 id="java-线程安全分类"><a href="#java-线程安全分类" class="headerlink" title="java 线程安全分类"></a>java 线程安全分类</h1><p>一般情况下，说道线程安全，只有两种结果：线程安全和线程不安全。但是从安全程度来判断，可以将其划分为以下 5 种类型：不可变、绝对线程安全、相对线程安全、线程兼容、线程对立。</p>
<h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p>当一个对象是不可变对象时，其一定是线程安全的，而且不需要提供方或调用方进行任何的同步操作。在 java 中，对于基本类型而言，被 final 修饰就是不可变对象，对于对象而言，其内部的成员都是不可变对象（基本类型是 final，引用类型递归判断不可变性）时，该对象是不可变的。例如，常用的 String 类就是一个不可变对象，对这个对象任何的操作都不会改变原先的值。</p>
<h2 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h2><p>绝对线程安全指不论任何情况下都不需要调用方进行同步操作。这个有点苛刻，通常需要付出很大的甚至不切实际的代价。一般情况下，通常说 Vector 是线程安全的，因为这个类中的方法都是被 synchronized 修饰的同步方法。但是这个类并没有达到“绝对线程安全”的程度。因为以下例子（例子参考自：《深入理解Java虚拟机》）中显示这个类在某种特定的情况下是需要调用方进行同步的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述程序会出现类似以下异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;Thread-382&quot; java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 13</span><br><span class="line">	at java.util.Vector.remove(Unknown Source)</span><br><span class="line">	at test.TestVector$1.run(TestVector.java:26)</span><br><span class="line">	at java.lang.Thread.run(Unknown Source)</span><br></pre></td></tr></table></figure>

<p>虽然 add 和 remove 都是同步方法，但是在 for 循环中，仍然可能存在这样一种情况：一个线程获取了变量 i ，准备执行 remove 操作，但是正好此时切换到另一个线程中执行，在另一个线程中执行了一些删除操作，刚好删除了 n 个数据导致 i 位置在 vector 范围之外，此时切回原先的线程执行 remove 操作就会出现 ArrayIndexOutOfBoundsException 异常。</p>
<p>要想解决上述问题，需要在 for 循环外部加入同步块，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (vector)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            vector.remove(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h2><p>相对线程安全就是平时所说的线程安全。它保证的是任何情况（包括多线程）下，调用对象的<strong>同一个方法</strong>，不需要额外的同步操作，也能获得正确的结果。但是在多线程的环境下，调用对象的不同方法，则需要额外的同步操作才能获得正确的结果。例如上述例子中的 vector 对象，当多个线程分别调用 add 方法往 vector 中加入元素时，其不需要任何的同步操作也能得到正确的结果，而对于 ArrayList 对象而言，多线程调用 add 方法，如果不进行同步操作，则得到的结果很可能少于增加的元素数量，因为 ArrayList 的 add 方法既不是同步的，也不是原子的。</p>
<h2 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h2><p>线程兼容指对象本身不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。</p>
<h2 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h2><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 java 语言天使具备多线程特性，线程对立这种排斥多线程的代码是很少出现。但是仍然存在，常见的线程对立的操作有 Thread 类的 suspend() 和 resume() 方法以及 System.setIn()、System.setOut() 等。</p>
<h1 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h1><p>上文已经说过，当一个对象是不可变对象时，其一定是线程安全的。那当一个对象是可变的，或者是一段代码块时，应该如何保证其线程安全呢。主要有以下三种方法：互斥同步（阻塞同步）、非阻塞同步、不共享数据。</p>
<h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>互斥同步（阻塞同步）是常见的一种同步手段，主要是通过加锁的方式来保证资源共享的同步和正确性的。常见的加锁方法有两种，一种是 <code>synchronized</code>，另一种是 <code>ReentrantLock</code>。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized 关键字可以用于同步方法，也可以用于同步代码块，当用于方法时，其默认会锁定方法所在的类实例或 Class 对象（根据方法是实例方法还是类方法来决定）。当用于同步代码块时，其需要一个参数用于充当锁，对这个对象进行加锁和解锁。</p>
<p>synchronized 同步块对同一个线程来说是可重入的，不会出现自己把自己锁死的问题，对于不同的线程，其会在已进入同步块的线程执行完同步块的代码之前，阻塞其他线程。当线程退出同步代码块时，其他线程被唤醒并争夺获得锁进入同步代码块，因此，这是一个非公平的锁。</p>
<p>使用 synchronized 关键字进行同步，其加锁和解锁的过程都是由虚拟机进行的，并不需要程序手动控制。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock 也是一个可重入的锁，不过 ReentrantLock 的加锁和解锁需要程序自己控制。另外，相比 synchronized ，其具有以下三个特点：等待可中断、可实现公平锁、锁可以绑定多个条件。</p>
<ul>
<li>等待可中断：指当持有所的线程长期不释放所的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li>公平锁：值多个线程在等待同一个锁时，必须按照申请所的时间顺序来依次获得锁。非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。 synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是可以通过带布尔值的构造函数要求使用公平锁。</li>
<li>锁绑定多个条件：指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，一个同步块只能绑定一个锁条件，如果要实现两个条件的锁，需要用两个同步块来实现。而对于 ReentrantLock 则无需这样做，只需要多次调用 newConditon() 方法即可。</li>
</ul>
<h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>互斥同步悲观地认为如果不进行加锁执行代码就会得到不正确的结果，因此其是通过加锁的方式来实现的，这就需要线程的阻塞和唤醒，是一种比较大的性能开销。非阻塞同步则认为乐观地认为大部分情况下是不会有冲突的，因此其是先执行代码，然后再检测是否发生冲突，如果冲突则回退操作并重复尝试，这种方式不涉及加锁及解锁，也不涉及线程的阻塞及唤醒，在某些情况下性能相对较好，但是对于部分经常发生冲突的情况而言，由于其经常发生冲突导致更新失效需要重试，可能会出现性能较差的情况。</p>
<p>非阻塞同步是需要硬件指令集的支持的，因为其需要保证更新操作和冲突检测这两个步骤都具有原子性。这类指令主要有：测试并设置（Test-and-Set）、获取并增加（Fetch-and-Increment）、交换（Swap）、比较并交换（Compare-and-Swap，检测 CAS）、加载链接&#x2F;条件存储（Load-Link&#x2F;Store-Condition，简称 LL&#x2F;SC）。</p>
<p>java 在 <code>sun.misc.Unsafe</code> 包中的 <code>compareAdnSwapInt()</code> 等方法中提供了 CAS 的支持大，但是由于 Unsafe 并不是给用户调用的类，因此，java 在 <code>java.util.concurrent</code> 包中提供了一些封装了支持 CAS 操作的 <code>compareAndSet()</code>、<code>getAndIncreent()</code> 等方法的原子类，如 <code>AtomicInteger</code> 类，其 <code>incrementAndGet()</code> 方法底层就是用 CAS 实现的。</p>
<h2 id="不共享数据"><a href="#不共享数据" class="headerlink" title="不共享数据"></a>不共享数据</h2><p>当数据只存在于本线程中，其他线程无法获取时，那围绕着这些数据进行相关操作的代码都是线程安全的，不需要其他任何的同步操作。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Braan Goetz等，Java 并发编程实战[M]，北京：机械工业出版社，2012<br>[2] 周志明，深入理解Java虚拟机：JVM高级特性与最佳实践[M]，北京：机械工业出版社，2013</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java序列化</title>
    <url>/java-serialize/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>当需要将一个对象进行持久化时，除了保存到数据库或写入到文件之外，java中还提供了一种“轻量级”的方式：序列化。java的对象序列化将那些实现了Serializable接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象，这个恢复过程称为反序列化。</p>
<span id="more"></span>

<h1 id="序列化特点"><a href="#序列化特点" class="headerlink" title="序列化特点"></a>序列化特点</h1><ul>
<li>如果父类实现了Serializable接口，子类默认实现了Serializable接口，即使子类没有明确声明也一样</li>
<li>序列化只保存对象的成员变量信息，并不保存对象的方法信息</li>
<li>对于只实现Serializable接口的对象进行序列化时，静态成员变量（static修饰的变量）和transient 变量（transient修饰的变量），不会进行序列化</li>
<li>静态成员变量和transient变量可以通过实现Serializable接口同时增加writeObject和readObject函数并在writeObject函数中手动对变量进行序列化，或者让对象实现Externalizale接口同时增加writeExternal和readExternal函数并在writeExternal函数中手动对变量进行序列化。</li>
<li>当对象进行序列化时，如果对象中有成员变量不能进行序列化（非基本成员变量，非静态成员变量，非transient变量，非空变量且没有实现Serializable接口），会抛出NotSerializableException异常</li>
<li>当对象被序列化时，如果对象包含了对其他对象的引用，则其他对象也会被序列化。比如说一个类A里面有一个变量 b 是引用B类的一个对象，则当A类的对象a被序列化时，b对象也会被序列化。 </li>
<li>对象序列化时，先序列化父类的成员变量，再序列化子类的成员变量</li>
</ul>
<h1 id="反序列化特点"><a href="#反序列化特点" class="headerlink" title="反序列化特点"></a>反序列化特点</h1><ul>
<li>对实现Serializable接口的对象进行反序列化时不会调用对象的构造函数</li>
<li>对实现Externalizale接口的对象进行反序列化时，会调用对象的默认构造函数（即无参构造函数），如果对象没有默认的构造函数，则会抛出<code>java.io.InvalidClassException: no valid constructor</code>异常</li>
<li>反序列化是在堆中新建对象并尝试还原保存的对象的状态，而不是对原有对象的操作</li>
<li>反序列化时要求能够获取到反序列化对象的class文件，否则会抛出ClassNotFoundException异常</li>
<li>对静态变量和transient变量进行默认反序列化时（由系统保证，不自己单独实现反序列化），如果没有在成员变量声明时赋值，则默认是零值（基本类型是0（boolean是false），非基本类型是null），如果在声明变量时赋值了，则值不变。</li>
</ul>
<h1 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h1><p>将对象变成可序列化主要有以下几种方式：只实现Serializable接口；实现Serializable接口并增加writeObject和readObject方法；实现Externalizable接口。</p>
<p>Serializable接口是一个标记接口，并没有接口方法需要实现类实现，而Externalizable接口继承了Serializable接口，但是却有readExternal和writeExternal两个接口方法需要实现类实现。</p>
<h2 id="只实现Serializable接口"><a href="#只实现Serializable接口" class="headerlink" title="只实现Serializable接口"></a>只实现Serializable接口</h2><h3 id="进行序列化的Person对象"><a href="#进行序列化的Person对象" class="headerlink" title="进行序列化的Person对象"></a>进行序列化的Person对象</h3><p>此处用Person类表示要进行序列化的对象。</p>
<p>成员变量中，用<code>DEFAULT_GENDER</code>变量验证<code>static final</code>的序列化和反序列化过程，用<code>count</code>变量验证<code>static</code>变量的序列化和反序列化的过程，用<code>id</code>变量验证<code>transient</code>变量的序列化和反序列化的过程。</p>
<p>构造函数中，有一个无参的默认构造函数和一个有参的构造函数，在构造函数中均输出一条信息表明调用的是哪个构造函数，并将count值加一，主要用于在反序列化时验证值是否为0</p>
<p>在<code>toString</code>函数中，输出对象的信息，除了输出成员变量的信息，也输出了类变量（static变量）的信息，更重要的是输出了对象的地址信息（<code>super.toString()</code>），这个主要用于验证反序列化时是在堆上新建对象而不是在原有对象上进行修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_GENDER</span> <span class="operator">=</span> <span class="string">&quot;man&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Persion()&quot;</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person(String name, int age, int id)&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [&quot;</span> + <span class="built_in">super</span>.toString() + <span class="string">&quot;]&quot;</span> </span><br><span class="line">                + <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name </span><br><span class="line">                + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, count=&quot;</span> + count </span><br><span class="line">                + <span class="string">&quot;, DEFAULT_GENDER=&quot;</span> + DEFAULT_GENDER + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进行序列化"><a href="#进行序列化" class="headerlink" title="进行序列化"></a>进行序列化</h3><p>此处将序列化和反序列分开在不同的程序中运行，这样更能说明静态变量不进行序列化。当然，也可以将反序列化的代码写在序列化的后面，这样除了静态变量的结果稍微需要注意一下之外，其他变量的结果跟序列化和反序列化程序分开的情况并无不同。下面程序中将注释的代码放开即可得到序列化和反序列化程序合在一起的结果。</p>
<p>在序列化的程序中，首先新建了一个person对象并输出对象信息，然后将该对象进行序列化输出，再改变person对象的成员变量值，这样做的目的是在反序列化时验证序列化之后又修改对象是否会影响序列化的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeOutput</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----New a Person----&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">12</span>, <span class="number">1111</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----Begin Serialize----&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.txt&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(person);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----Change Person----&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">21</span>);</span><br><span class="line">        person.setId(<span class="number">2222</span>);</span><br><span class="line">        person.setName(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        person.setCount(<span class="number">10</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        System.out.println(&quot;----Begin Deserialize----&quot;);</span></span><br><span class="line"><span class="comment">//        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;person.txt&quot;));</span></span><br><span class="line"><span class="comment">//        Person person1 = (Person) objectInputStream.readObject();</span></span><br><span class="line"><span class="comment">//        // 此处会输出 Person [serialize.Person@6bc7c054][id=0, name=Alice, age=12, count=10, DEFAULT_GENDER=man]</span></span><br><span class="line"><span class="comment">//        // 可以看到地址与序列化前的地址不一样，另外count的值是10，这是因为count是静态变量，属于类，不属于某个具体的对象</span></span><br><span class="line"><span class="comment">//        // 而此处是在同一个程序中，Person类并没有被销毁或新建，其类信息保存者，因此反序列化后虽然对象的静态成员变量赋值为零值</span></span><br><span class="line"><span class="comment">//        // 但是由于Person类相关信息仍然存在，在对象读取类变量时，会将类变量的值赋给对象，所以count输出值是10</span></span><br><span class="line"><span class="comment">//        System.out.println(person1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----New a Person----</span><br><span class="line">Person(String name, int age, int id)</span><br><span class="line">Person [serialize.Person@15db9742][id=1111, name=Alice, age=12, count=1, DEFAULT_GENDER=man]</span><br><span class="line">----Begin Serialize----</span><br><span class="line">----Change Person----</span><br><span class="line">Person [serialize.Person@15db9742][id=2222, name=Bob, age=21, count=10, DEFAULT_GENDER=man]</span><br></pre></td></tr></table></figure>

<h3 id="进行反序列化"><a href="#进行反序列化" class="headerlink" title="进行反序列化"></a>进行反序列化</h3><p>反序列化的程序很简单，就是直接读取序列化产生的文件，输出对象信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeInput</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----Begin Deserialize----&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;person.txt&quot;</span>));</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) objectInputStream.readObject();</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----Begin Deserialize----</span><br><span class="line">Person [serialize.Person@70dea4e][id=0, name=Alice, age=12, count=0, DEFAULT_GENDER=man]</span><br></pre></td></tr></table></figure>

<p>对比序列化和反序列化的输出结果，可以看出</p>
<ul>
<li>对象地址不同，这说明反序列化是在堆上新建对象，而不是在原有对象上进行修改</li>
<li>id变量值不同，序列化时id是111，反序列化后是0，这说明序列化时并不会对transient变量进行序列化</li>
<li>count变量值不同，序列化时count是1，反序列化后是0，这说明序列化时并不会对静态变量进行序列化</li>
<li>对person对象进行序列化后，改变person对象，再将其反序列化时，并不会将序列化对象后的修改反映到反序列化的对象中</li>
</ul>
<h2 id="实现Serializable接口并增加writeObject和readObject方法"><a href="#实现Serializable接口并增加writeObject和readObject方法" class="headerlink" title="实现Serializable接口并增加writeObject和readObject方法"></a>实现Serializable接口并增加writeObject和readObject方法</h2><p>对于静态成员变量和transient变量，虽然默认的序列化操作不会将其进行序列化，但是可以在对象中增加writeObject和readObject方法将其手动序列化。需要注意的是方法签名有严格的要求，必须是以下的形式：</p>
<ul>
<li>修饰符必须是private</li>
<li>返回类型必须是void</li>
<li>函数名称必须是<code>writeObject</code>或<code>readObject</code></li>
<li>函数入参只能有一个，且<code>writeObject</code>函数的入参只能是<code>ObjectOutputStream</code>类型参数，<code>readObject</code>函数的入参只能是<code>ObjectInputStream</code>类型参数</li>
</ul>
<p>如下两个是合格writeObject和readObject方法签名</p>
<p><code>private void writeObject(ObjectOutputStream stream)</code></p>
<p><code>private void readObject(ObjectInputStream stream)</code></p>
<p>对于使用了Serializable接口并且增加了writeObject和readObject方法的对象而言，在序列化时，系统会先判断对象是否有writeObject函数（严格按照上述约束进行判断），如果有此函数，则调用此函数进行序列化，不会调用默认的序列化函数，如果需要执行默认的序列化操作，需要在writeObject函数中手动调用<code>defaultWriteObject()</code>函数进行默认的序列化操作。也就是说，如果不调用<code>defaultWriteObject()</code>函数，则只会将writeObject函数中手动序列化的变量进行序列化。</p>
<p>同样，在反序列化时，系统也会先判断对象是否有readObject函数，如果有此函数，则调用此函数进行反序列化，不会调用默认的反序列化函数，如果需要执行默认的反序列化函数，需要在readObject函数中手动调用<code>defaultReadObject()</code>函数进行默认的反序列化操作。也就是说，如果不调用<code>defaultReadObject()</code>函数，则只会将readObject函数中手动反序列化的变量进行序列化。</p>
<p>在将对象变量进行手动序列化和反序列化时，需要注意反序列化的顺序和序列化的顺序是一致的。</p>
<h3 id="进行序列化的Person对象-1"><a href="#进行序列化的Person对象-1" class="headerlink" title="进行序列化的Person对象"></a>进行序列化的Person对象</h3><p>与“只实现Serializable接口方式”的Person对象不同，此处增加了writeObject和readObject方法，并在writeObject中调用了defaultWriteObject进行了了默认的序列化操作后将transient变量和静态变量进行了序列化输出。相应地，在readObject中调用了deafultReadObject进行了默认的反序列化操作，然后将对应的transient变量和静态变量进行了反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_GENDER</span> <span class="operator">=</span> <span class="string">&quot;man&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Persion()&quot;</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person(String name, int age, int id)&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----private void writeObject(ObjectOutputStream stream)----&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用defaultWriteObject函数，可以执行默认的序列化操作</span></span><br><span class="line">        <span class="comment">// 否则name和age这两个正常的变量不会进行序列化</span></span><br><span class="line">        stream.defaultWriteObject();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将transizent变量进行序列化</span></span><br><span class="line">        stream.writeObject(id);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将静态变量进行序列化</span></span><br><span class="line">        stream.writeObject(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----private void readObject(ObjectInputStream stream)----&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用defaultReadObject函数，可以执行默认的反序列化操作</span></span><br><span class="line">        <span class="comment">// 否则name和age这两个正常的变量不会进行反序列化</span></span><br><span class="line">        stream.defaultReadObject();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将transizent变量进行反序列化</span></span><br><span class="line">        id = (<span class="type">int</span>) stream.readObject();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将静态变量进行反序列化</span></span><br><span class="line">        count = (<span class="type">int</span>) stream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [&quot;</span> + <span class="built_in">super</span>.toString() + <span class="string">&quot;]&quot;</span> </span><br><span class="line">                + <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name </span><br><span class="line">                + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, count=&quot;</span> + count </span><br><span class="line">                + <span class="string">&quot;, DEFAULT_GENDER=&quot;</span> + DEFAULT_GENDER + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进行序列化-1"><a href="#进行序列化-1" class="headerlink" title="进行序列化"></a>进行序列化</h3><p>序列化的程序与“只实现Serializable接口”方式中的序列化程序相同，不同的是输出结果，从程序的输出结果中可以看出，序列化时调用了对象的writeObject函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeOutput</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----New a Person----&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">12</span>, <span class="number">1111</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----Begin Serialize----&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.txt&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(person);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----Change Person----&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">21</span>);</span><br><span class="line">        person.setId(<span class="number">2222</span>);</span><br><span class="line">        person.setName(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        person.setCount(<span class="number">10</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        System.out.println(&quot;----Begin Deserialize----&quot;);</span></span><br><span class="line"><span class="comment">//        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;person.txt&quot;));</span></span><br><span class="line"><span class="comment">//        Person person1 = (Person) objectInputStream.readObject();</span></span><br><span class="line"><span class="comment">//        // 此处会输出Person [serialize.Person@1540e19d][id=1111, name=Alice, age=12, count=1, DEFAULT_GENDER=man]</span></span><br><span class="line"><span class="comment">//        // 可以看到地址与序列化前的地址不一样，另外count的值是1，这是因为在序列化时将静态变量count进行了序列化输出</span></span><br><span class="line"><span class="comment">//        // 在反序列化时将该值进行反序列化，重新给类变量赋值，变成了1</span></span><br><span class="line"><span class="comment">//        System.out.println(person1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----New a Person----</span><br><span class="line">Person(String name, int age, int id)</span><br><span class="line">Person [serialize.Person@15db9742][id=1111, name=Alice, age=12, count=1, DEFAULT_GENDER=man]</span><br><span class="line">----Begin Serialize----</span><br><span class="line">----private void writeObject(ObjectOutputStream stream)----</span><br><span class="line">----Change Person----</span><br><span class="line">Person [serialize.Person@15db9742][id=2222, name=Bob, age=21, count=10, DEFAULT_GENDER=man]</span><br></pre></td></tr></table></figure>

<h3 id="进行反序列化-1"><a href="#进行反序列化-1" class="headerlink" title="进行反序列化"></a>进行反序列化</h3><p>反序列化的程序与“只实现Serializable接口”方式中的反序列化程序相同，不同的是输出结果，从程序的输出结果中可以看出，反序列化时调用了对象的readObject函数。而对比序列化和反序列化的输出结果，也可以看出静态变量和transient变量也进行了序列化和反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeInput</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----Begin Deserialize----&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;person.txt&quot;</span>));</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) objectInputStream.readObject();</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----Begin Deserialize----</span><br><span class="line">----private void readObject(ObjectInputStream stream)----</span><br><span class="line">Person [serialize.Person@42a57993][id=1111, name=Alice, age=12, count=1, DEFAULT_GENDER=man]</span><br></pre></td></tr></table></figure>

<h2 id="实现Externalizable接口"><a href="#实现Externalizable接口" class="headerlink" title="实现Externalizable接口"></a>实现Externalizable接口</h2><p>与实现Serializable接口不同，实现Externalizable接口需要实现writeExternal和readExternal这两个接口方法。在进行序列化时，会调用writeExternal方法进行序列化，而在反序列化时，readExternal方法会被调用。需要注意的是，用此方法实现序列化和反序列化，必须手动对所有需要序列化的对象变量进行手动序列化和反序列化，包括基本数据类型的变量，否则不会对该变量进行序列化，而且此方法也没有类似defaulWriteObject和defaultReadObject函数可供调用实现默认的序列化和反序列化的功能。另外，此中方式实现反序列化时，会调用对象的默认构造函数（即无参构造函数），如果对象没有默认的构造函数，则会抛出<code>java.io.InvalidClassException: no valid constructor</code>异常。</p>
<p>在将对象变量进行手动序列化和反序列化时，需要注意反序列化的顺序和序列化的顺序是一致的。</p>
<h3 id="进行序列化的Person对象-2"><a href="#进行序列化的Person对象-2" class="headerlink" title="进行序列化的Person对象"></a>进行序列化的Person对象</h3><p>与“只实现Serializable接口”方式不同，此处实现Externalizable接口，并实现了writeExternal和readExternal接口方法。在writeExternal方法中，对所有的成员变量进行了手动序列化，包括基本成员变量（如age变量）、transient变量和静态变量。相应地，在readExternal方法中，按照序列化成员变量的顺序，对所有成员变量进行反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_GENDER</span> <span class="operator">=</span> <span class="string">&quot;man&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Persion()&quot;</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person(String name, int age, int id)&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----public void writeExternal(ObjectOutput out)----&quot;</span>);</span><br><span class="line">        <span class="comment">// 所有需要序列化的对象变量都需要手动序列化，包括基本类型的变量</span></span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeObject(age);</span><br><span class="line">        <span class="comment">// 序列化transient变量</span></span><br><span class="line">        out.writeObject(id);</span><br><span class="line">        <span class="comment">// 序列化静态变量</span></span><br><span class="line">        out.writeObject(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----public void readExternal(ObjectInput in)----&quot;</span>);</span><br><span class="line">        <span class="comment">// 所有需要反序列化的对象变量都需要手动反序列化，包括基本类型的变量</span></span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        age = (<span class="type">int</span>) in.readObject();</span><br><span class="line">        <span class="comment">// 反序列化transient对象</span></span><br><span class="line">        id = (<span class="type">int</span>) in.readObject();</span><br><span class="line">        <span class="comment">// 反序列化静态变量</span></span><br><span class="line">        count = (<span class="type">int</span>) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [&quot;</span> + <span class="built_in">super</span>.toString() + <span class="string">&quot;]&quot;</span> </span><br><span class="line">                + <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name </span><br><span class="line">                + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, count=&quot;</span> + count </span><br><span class="line">                + <span class="string">&quot;, DEFAULT_GENDER=&quot;</span> + DEFAULT_GENDER + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进行序列化-2"><a href="#进行序列化-2" class="headerlink" title="进行序列化"></a>进行序列化</h3><p>进行序列化的程序与前两种方式相同，不同的是程序的输出结果。从输出结果可以看出，在序列化时调用了对象的writeExternal函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeOutput</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----New a Person----&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">12</span>, <span class="number">1111</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----Begin Serialize----&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.txt&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(person);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----Change Person----&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">21</span>);</span><br><span class="line">        person.setId(<span class="number">2222</span>);</span><br><span class="line">        person.setName(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        person.setCount(<span class="number">10</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        System.out.println(&quot;----Begin Deserialize----&quot;);</span></span><br><span class="line"><span class="comment">//        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;person.txt&quot;));</span></span><br><span class="line"><span class="comment">//        Person person1 = (Person) objectInputStream.readObject();</span></span><br><span class="line"><span class="comment">//        // 此处会输出Person [serialize.Person@1540e19d][id=1111, name=Alice, age=12, count=1, DEFAULT_GENDER=man]</span></span><br><span class="line"><span class="comment">//        // 可以看到地址与序列化前的地址不一样，另外count的值是1，这是因为在序列化时将静态变量count进行了序列化输出</span></span><br><span class="line"><span class="comment">//        // 在反序列化时将该值进行反序列化，重新给类变量赋值，变成了1</span></span><br><span class="line"><span class="comment">//        System.out.println(person1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----New a Person----</span><br><span class="line">Person(String name, int age, int id)</span><br><span class="line">Person [serialize.Person@15db9742][id=1111, name=Alice, age=12, count=1, DEFAULT_GENDER=man]</span><br><span class="line">----Begin Serialize----</span><br><span class="line">----public void writeExternal(ObjectOutput out)----</span><br><span class="line">----Change Person----</span><br><span class="line">Person [serialize.Person@15db9742][id=2222, name=Bob, age=21, count=10, DEFAULT_GENDER=man]</span><br></pre></td></tr></table></figure>

<h3 id="进行反序列化-2"><a href="#进行反序列化-2" class="headerlink" title="进行反序列化"></a>进行反序列化</h3><p>反序列化的程序与前两种相同，不同的是输出结果，从程序的输出结果中可以看出，反序列化时调用了对象的readExternal函数。而对比序列化和反序列化的输出结果，也可以看出静态变量和transient变量也进行了序列化和反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeInput</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----Begin Deserialize----&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;person.txt&quot;</span>));</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) objectInputStream.readObject();</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----Begin Deserialize----</span><br><span class="line">Persion()</span><br><span class="line">----public void readExternal(ObjectInput in)----</span><br><span class="line">Person [serialize.Person@3d4eac69][id=1111, name=Alice, age=12, count=1, DEFAULT_GENDER=man]</span><br></pre></td></tr></table></figure>

<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p>深入学习java序列化：<a href="http://beautyboss.farbox.com/post/study/shen-ru-xue-xi-javaxu-lie-hua">http://beautyboss.farbox.com/post/study/shen-ru-xue-xi-javaxu-lie-hua</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Eckel,B. Java编程思想（第四版）[M]. 北京：机械工业出版社，2007.6</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 排序</title>
    <url>/java-sort/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在平常的开发中经常需要用到排序，在 java 中主要有两种类型的排序，一种是数组 Arrays，另一种是集合 Collections，都是通过调用 sort 函数来实现排序的。而这也要求进行排序的对象需要 Comparable 接口或者在调用 sort 函数时将实现 Comparator 的对象作为另一个参数传入，从而达到排序的目的。</p>
<span id="more"></span>

<h1 id="数组-Arrays-排序"><a href="#数组-Arrays-排序" class="headerlink" title="数组 Arrays 排序"></a>数组 Arrays 排序</h1><p>数组的排序主要是依靠 <code>Arrays.sort</code> 函数来完成。由于数组的元素可以是由基本类型组成，也可以由对象组成，因此这个函数可以对基本类型的数组进行排序，也可以对对象数组进行排序。排序主要有两种方式，一种是由对象实现<code>Comparable </code> 接口中的 <code>compareTo</code> 函数（<em>注意：基本类型不用实现这个接口</em>）。另一种是在调用 <code>Arrays.sort</code> 函数时将实现 <code>Comparator </code> 接口的 <code>compare</code> 函数的对象作为参数传入该函数进行比较。</p>
<h2 id="使用-Comparable-实现排序"><a href="#使用-Comparable-实现排序" class="headerlink" title="使用 Comparable 实现排序"></a>使用 Comparable 实现排序</h2><p>使用 Comparable 的方式进行排序，要求排序的对象实现 Comparable 接口，并实现接口中的 compareTo 函数。此函数将本对象与另一个对象进行比较，如果本对象小于另一个对象，则返回负数，如果本对象大于另一个对象，则返回正数，相等则返回 0。</p>
<p>程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> score, String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;, score=&quot;</span> + score + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.score - s.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----init students----&quot;</span>);</span><br><span class="line">        Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">4</span>];</span><br><span class="line">        students[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>, <span class="number">10</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        students[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="number">50</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        students[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="number">30</span>, <span class="string">&quot;Tony&quot;</span>);</span><br><span class="line">        students[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="string">&quot;Amy&quot;</span>);</span><br><span class="line">        Arrays.stream(students).forEach(x -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----sort by Comparable [by score]----&quot;</span>);</span><br><span class="line">        Arrays.sort(students);</span><br><span class="line">        Arrays.stream(students).forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----init students----</span><br><span class="line">Student [id=4, score=10, name=Tom]</span><br><span class="line">Student [id=2, score=50, name=Alice]</span><br><span class="line">Student [id=3, score=30, name=Tony]</span><br><span class="line">Student [id=1, score=20, name=Amy]</span><br><span class="line">----sort by Comparable [by score]----</span><br><span class="line">Student [id=4, score=10, name=Tom]</span><br><span class="line">Student [id=1, score=20, name=Amy]</span><br><span class="line">Student [id=3, score=30, name=Tony]</span><br><span class="line">Student [id=2, score=50, name=Alice]</span><br></pre></td></tr></table></figure>

<h2 id="使用-Comparator-实现排序"><a href="#使用-Comparator-实现排序" class="headerlink" title="使用 Comparator 实现排序"></a>使用 Comparator 实现排序</h2><p>使用 Comparator 方式进行排序，不要求排序对象实现 Comparable  接口，只需要在调用 Arrays.sort 函数时将将实现 Comparator  接口的 compare 函数的对象作为参数传入该函数进行比较即可。compare 函数接收两个排序类型的参数，如果第一个对象对象小于第二个对象，则返回负数，如果第一个对象大于第二个对象，则返回正数，相等则返回 0。</p>
<p>程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> score, String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;, score=&quot;</span> + score + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----init students----&quot;</span>);</span><br><span class="line">        Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">4</span>];</span><br><span class="line">        students[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>, <span class="number">10</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        students[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="number">50</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        students[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="number">30</span>, <span class="string">&quot;Tony&quot;</span>);</span><br><span class="line">        students[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="string">&quot;Amy&quot;</span>);</span><br><span class="line">        Arrays.stream(students).forEach(x -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----sort by Comparator [by id]----&quot;</span>);</span><br><span class="line">        Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getId() - o2.getId();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Arrays.stream(students).forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----init students----</span><br><span class="line">Student [id=4, score=10, name=Tom]</span><br><span class="line">Student [id=2, score=50, name=Alice]</span><br><span class="line">Student [id=3, score=30, name=Tony]</span><br><span class="line">Student [id=1, score=20, name=Amy]</span><br><span class="line">----sort by Comparator [by id]----</span><br><span class="line">Student [id=1, score=20, name=Amy]</span><br><span class="line">Student [id=2, score=50, name=Alice]</span><br><span class="line">Student [id=3, score=30, name=Tony]</span><br><span class="line">Student [id=4, score=10, name=Tom]</span><br></pre></td></tr></table></figure>

<h2 id="混合使用-Comparable-和-Comparator"><a href="#混合使用-Comparable-和-Comparator" class="headerlink" title="混合使用 Comparable 和 Comparator"></a>混合使用 Comparable 和 Comparator</h2><p>单独使用 Comparable 或 Comparator 都能达到排序的效果，但是如果排序的对象实现了 Comparable  接口，同时在调用 Arrays.sort 函数时又传入了实现 Comparator 接口的比较对象，那结果会是怎样呢。实验证明，如果同时实现了这两个接口，将以 Comparator 的比较为准。</p>
<p>程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> score, String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;, score=&quot;</span> + score + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.score - s.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----init students----&quot;</span>);</span><br><span class="line">        Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">4</span>];</span><br><span class="line">        students[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>, <span class="number">10</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        students[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="number">50</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        students[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="number">30</span>, <span class="string">&quot;Tony&quot;</span>);</span><br><span class="line">        students[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="string">&quot;Amy&quot;</span>);</span><br><span class="line">        Arrays.stream(students).forEach(x -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----sort by Comparator [by id]----&quot;</span>);</span><br><span class="line">        Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getId() - o2.getId();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Arrays.stream(students).forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----init students----</span><br><span class="line">Student [id=4, score=10, name=Tom]</span><br><span class="line">Student [id=2, score=50, name=Alice]</span><br><span class="line">Student [id=3, score=30, name=Tony]</span><br><span class="line">Student [id=1, score=20, name=Amy]</span><br><span class="line">----sort by Comparator [by id]----</span><br><span class="line">Student [id=1, score=20, name=Amy]</span><br><span class="line">Student [id=2, score=50, name=Alice]</span><br><span class="line">Student [id=3, score=30, name=Tony]</span><br><span class="line">Student [id=4, score=10, name=Tom]</span><br></pre></td></tr></table></figure>

<h1 id="集合-Collections-排序"><a href="#集合-Collections-排序" class="headerlink" title="集合 Collections 排序"></a>集合 Collections 排序</h1><p>集合 Collections 排序和数组 Arrays 排序的方式类似，只不过集合的排序主要是依靠 <code>Collections.sort</code> 函数来完成。集合排序主要有两种方式，一种是由对象实现<code>Comparable </code> 接口中的 <code>compareTo</code> 函数。另一种是在调用 <code>Collections.sort</code> 函数时将实现 <code>Comparator </code> 接口的 <code>compare</code> 函数的对象作为参数传入该函数进行比较。</p>
<h2 id="使用-Comparable-实现排序-1"><a href="#使用-Comparable-实现排序-1" class="headerlink" title="使用 Comparable 实现排序"></a>使用 Comparable 实现排序</h2><p>使用 Comparable 的方式进行排序，要求排序的对象实现 Comparable 接口，并实现接口中的 compareTo 函数。此函数将本对象与另一个对象进行比较，如果本对象小于另一个对象，则返回负数，如果本对象大于另一个对象，则返回正数，相等则返回 0。</p>
<p>程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> score, String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;, score=&quot;</span> + score + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.score - s.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----init students----&quot;</span>);</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="number">50</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="number">30</span>, <span class="string">&quot;Tony&quot;</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>, <span class="number">20</span>, <span class="string">&quot;Amy&quot;</span>));</span><br><span class="line">        students.forEach(x -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----sort by Comparable [by score]----&quot;</span>);</span><br><span class="line">        Collections.sort(students);</span><br><span class="line">        students.forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----init students----</span><br><span class="line">Student [id=1, score=10, name=Tom]</span><br><span class="line">Student [id=2, score=50, name=Alice]</span><br><span class="line">Student [id=3, score=30, name=Tony]</span><br><span class="line">Student [id=4, score=20, name=Amy]</span><br><span class="line">----sort by Comparable [by score]----</span><br><span class="line">Student [id=1, score=10, name=Tom]</span><br><span class="line">Student [id=4, score=20, name=Amy]</span><br><span class="line">Student [id=3, score=30, name=Tony]</span><br><span class="line">Student [id=2, score=50, name=Alice]</span><br></pre></td></tr></table></figure>

<h2 id="使用-Comparator-实现排序-1"><a href="#使用-Comparator-实现排序-1" class="headerlink" title="使用 Comparator 实现排序"></a>使用 Comparator 实现排序</h2><p>使用 Comparator 方式进行排序，不要求排序对象实现 Comparable  接口，只需要在调用 Collections.sort 函数时将将实现 Comparator  接口的 compare 函数的对象作为参数传入该函数进行比较即可。compare 函数接收两个排序类型的参数，如果第一个对象对象小于第二个对象，则返回负数，如果第一个对象大于第二个对象，则返回正数，相等则返回 0。由于 java8 中新增了对 lambda 表达式的支持，因此，可以直接用 lambda 表达式实现比较对象并将其作为参数传入 Collection.sort 函数中。</p>
<p>程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> score, String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;, score=&quot;</span> + score + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----init students----&quot;</span>);</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="number">50</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="number">30</span>, <span class="string">&quot;Tony&quot;</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>, <span class="number">20</span>, <span class="string">&quot;Amy&quot;</span>));</span><br><span class="line">        students.forEach(x -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用外部比较器，方式一：显式调用 Collections排序</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----sort by Comparator [by id]----&quot;</span>);</span><br><span class="line">        Collections.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getId() - o2.getId();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        students.forEach(x -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用外部比较器，方式二：隐式调用 Collections排序</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----sort by Comparator [by name]----&quot;</span>);</span><br><span class="line">        students.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        students.forEach(x -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用外部比较器，方式三：隐式调用 Collections排序，用 lambda 表达式实现 Comparator 接口</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----sort by lambda [by id]----&quot;</span>);</span><br><span class="line">        students.sort((x, y) -&gt; x.getId() - y.getId());</span><br><span class="line">        students.forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----init students----</span><br><span class="line">Student [id=1, score=10, name=Tom]</span><br><span class="line">Student [id=2, score=50, name=Alice]</span><br><span class="line">Student [id=3, score=30, name=Tony]</span><br><span class="line">Student [id=4, score=20, name=Amy]</span><br><span class="line">----sort by Comparator [by id]----</span><br><span class="line">Student [id=1, score=10, name=Tom]</span><br><span class="line">Student [id=2, score=50, name=Alice]</span><br><span class="line">Student [id=3, score=30, name=Tony]</span><br><span class="line">Student [id=4, score=20, name=Amy]</span><br><span class="line">----sort by Comparator [by name]----</span><br><span class="line">Student [id=2, score=50, name=Alice]</span><br><span class="line">Student [id=4, score=20, name=Amy]</span><br><span class="line">Student [id=1, score=10, name=Tom]</span><br><span class="line">Student [id=3, score=30, name=Tony]</span><br><span class="line">----sort by lambda [by id]----</span><br><span class="line">Student [id=1, score=10, name=Tom]</span><br><span class="line">Student [id=2, score=50, name=Alice]</span><br><span class="line">Student [id=3, score=30, name=Tony]</span><br><span class="line">Student [id=4, score=20, name=Amy]</span><br></pre></td></tr></table></figure>

<h2 id="混合使用-Comparable-和-Comparator-1"><a href="#混合使用-Comparable-和-Comparator-1" class="headerlink" title="混合使用 Comparable 和 Comparator"></a>混合使用 Comparable 和 Comparator</h2><p>与数组 Arrays 排序一样，如果同时实现了这两个接口，将以 Comparator 的比较为准。</p>
<p>程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> score, String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;, score=&quot;</span> + score + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.score - s.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----init students----&quot;</span>);</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="number">50</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="number">30</span>, <span class="string">&quot;Tony&quot;</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>, <span class="number">20</span>, <span class="string">&quot;Amy&quot;</span>));</span><br><span class="line">        students.forEach(x -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用外部比较器，方式一：显式调用 Collections排序</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----sort by Comparator [by id]----&quot;</span>);</span><br><span class="line">        Collections.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getId() - o2.getId();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        students.forEach(x -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用外部比较器，方式二：隐式调用 Collections排序</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----sort by Comparator [by name]----&quot;</span>);</span><br><span class="line">        students.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        students.forEach(x -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用外部比较器，方式三：隐式调用 Collections排序，用 lambda 表达式实现 Comparator 接口</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----sort by lambda [by id]----&quot;</span>);</span><br><span class="line">        students.sort((x, y) -&gt; x.getId() - y.getId());</span><br><span class="line">        students.forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----init students----</span><br><span class="line">Student [id=<span class="number">1</span>, score=<span class="number">10</span>, name=Tom]</span><br><span class="line">Student [id=<span class="number">2</span>, score=<span class="number">50</span>, name=Alice]</span><br><span class="line">Student [id=<span class="number">3</span>, score=<span class="number">30</span>, name=Tony]</span><br><span class="line">Student [id=<span class="number">4</span>, score=<span class="number">20</span>, name=Amy]</span><br><span class="line">----sort by Comparator [by id]----</span><br><span class="line">Student [id=<span class="number">1</span>, score=<span class="number">10</span>, name=Tom]</span><br><span class="line">Student [id=<span class="number">2</span>, score=<span class="number">50</span>, name=Alice]</span><br><span class="line">Student [id=<span class="number">3</span>, score=<span class="number">30</span>, name=Tony]</span><br><span class="line">Student [id=<span class="number">4</span>, score=<span class="number">20</span>, name=Amy]</span><br><span class="line">----sort by Comparator [by name]----</span><br><span class="line">Student [id=<span class="number">2</span>, score=<span class="number">50</span>, name=Alice]</span><br><span class="line">Student [id=<span class="number">4</span>, score=<span class="number">20</span>, name=Amy]</span><br><span class="line">Student [id=<span class="number">1</span>, score=<span class="number">10</span>, name=Tom]</span><br><span class="line">Student [id=<span class="number">3</span>, score=<span class="number">30</span>, name=Tony]</span><br><span class="line">----sort by lambda [by id]----</span><br><span class="line">Student [id=<span class="number">1</span>, score=<span class="number">10</span>, name=Tom]</span><br><span class="line">Student [id=<span class="number">2</span>, score=<span class="number">50</span>, name=Alice]</span><br><span class="line">Student [id=<span class="number">3</span>, score=<span class="number">30</span>, name=Tony]</span><br><span class="line">Student [id=<span class="number">4</span>, score=<span class="number">20</span>, name=Amy]</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>java 中排序主要是通过对排序对象实现 Comparable 接口或者在调用排序函数时传入一个实现 Comparator 接口的比较对象来实现的。这两种方法各有优点，其中 Comparable 接口可以看出是对排序对象的一种默认实现，在调用排序函数时只需要传入排序对象集合即可得到排序结果，但是一种类型的对象只能有一种默认实现的排序方法。相比而言， Comparator 接口的排序方式显得更加灵活，其可以不受排序对象限制（无论排序对象有没有默认的排序实现），可以无限制地实现多种不同的排序方式，而且，即使排序对象有默认的排序行为（实现了 Comparable 接口），也可以通过外部实现 Comparator 接口的方式改变其排序行为。</p>
<p>因此，对于需要多种不同的排序方式的对象，建议对排序对象实现 Comparable 接口，为其赋有默认的排序行为，对其他的排序方式则通过外部实现 Comparator 接口的方式来实现。当然，如果某些情况下不允许改变排序对象，那就只能通过外部实现 Comparator 接口的方式来实现排序了。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal 介绍</title>
    <url>/java-threadlocal/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>ThreadLocal</code> 是 java 提供的一个方便对象在本线程内不同方法中传递和获取的类。用它定义的变量，仅在本线程中可见和维护，不受其他线程的影响，与其他线程相互隔离。</p>
<span id="more"></span>

<p>虽然在本线程不同方法中使用变量，可以通过在方法中传入参数解决，但是当涉及多个方法甚至多个类时，为每个方法增加同样的参数将是一场噩梦，此时 <code>ThreadLocal</code> 就能很好地解决这个问题。它可以在本线程内任何一个地方赋值，在任何一个地方获取值，并且不用作为函数参数传入。这看起来像静态成员变量，但是 <code>ThreadLocal</code> 变量相比静态成员变量的一个优势就是，<code>ThreadLocal</code> 是线程隔离的，其值不会受另一个线程的影响，也不用考虑加锁或值被其他线程篡改的问题，而这些问题都是静态成员变量无法做到的。因此当涉及一个对象需要在很多不同方法之间传递时，应该考虑使用 <code>ThreadLocal</code> 对象来简化代码。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><code>ThreadLocal</code> 通过 <code>set</code> 方法可以给变量赋值，通过 <code>get</code> 方法获取变量的值。当然，也可以在定义变量时通过 <code>ThreadLocal.withInitial</code> 方法给变量赋初始值，或者定义一个继承 <code>ThreadLocal</code> 的类，然后重写 <code>initialValue</code> 方法。</p>
<p>示例代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadLocal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;StringBuilder&gt; builder = ThreadLocal.withInitial(StringBuilder::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    append(j);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s append %d, now builder value is %s, ThreadLocal instance hashcode is %d, ThreadLocal instance mapping value hashcode is %d\n&quot;</span>, threadName, j, builder.get().toString(), builder.hashCode(), builder.get().hashCode());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                change();</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s set new stringbuilder, now builder value is %s, ThreadLocal instance hashcode is %d, ThreadLocal instance mapping value hashcode is %d\n&quot;</span>, threadName, builder.get().toString(), builder.hashCode(), builder.get().hashCode());</span><br><span class="line">            &#125;, <span class="string">&quot;thread-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        builder.get().append(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">newStringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        builder.set(newStringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在例子中，定义了一个 <code>builder</code> 的 <code>ThreadLocal</code> 对象，然后启动 5 个线程，分别对 <code>builder</code> 对象进行访问和修改操作，这两个操作放在两个不同的函数 <code>append</code>、<code>change</code> 中进行，两个函数访问 <code>builder</code> 对象也是直接获取，而不是放入函数的入参中传递进来。<br>代码输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thread-0 append 0, now builder value is 0, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 566157654</span><br><span class="line">thread-0 append 1, now builder value is 01, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 566157654</span><br><span class="line">thread-4 append 0, now builder value is 0, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 654647086</span><br><span class="line">thread-3 append 0, now builder value is 0, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 1803363945</span><br><span class="line">thread-2 append 0, now builder value is 0, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 1535812498</span><br><span class="line">thread-1 append 0, now builder value is 0, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 2075237830</span><br><span class="line">thread-2 append 1, now builder value is 01, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 1535812498</span><br><span class="line">thread-3 append 1, now builder value is 01, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 1803363945</span><br><span class="line">thread-4 append 1, now builder value is 01, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 654647086</span><br><span class="line">thread-0 append 2, now builder value is 012, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 566157654</span><br><span class="line">thread-0 set new stringbuilder, now builder value is HelloWorld, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 1773033190</span><br><span class="line">thread-4 append 2, now builder value is 012, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 654647086</span><br><span class="line">thread-4 set new stringbuilder, now builder value is HelloWorld, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 700642750</span><br><span class="line">thread-3 append 2, now builder value is 012, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 1803363945</span><br><span class="line">thread-3 set new stringbuilder, now builder value is HelloWorld, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 1706743158</span><br><span class="line">thread-2 append 2, now builder value is 012, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 1535812498</span><br><span class="line">thread-2 set new stringbuilder, now builder value is HelloWorld, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 1431127699</span><br><span class="line">thread-1 append 1, now builder value is 01, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 2075237830</span><br><span class="line">thread-1 append 2, now builder value is 012, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 2075237830</span><br><span class="line">thread-1 set new stringbuilder, now builder value is HelloWorld, ThreadLocal instance hashcode is 796465865, ThreadLocal instance mapping value hashcode is 1970695360</span><br></pre></td></tr></table></figure>

<p>从输出中 <code>1~6</code> 行可以看出，不同线程访问的是同一个 <code>builder</code> 对象（不同线程输出的 <code>ThreadLocal instance hashcode</code> 值相同），但是每个线程获得的 <code>builder</code> 对象存储的实例 <code>StringBuilder</code> 不同（不同线程输出的 <code>ThreadLocal instance mapping value hashcode</code> 值不相同）。</p>
<p>从输出中 <code>1~2</code>、<code>9~10</code>行可以看出，同一个线程中修改 <code>builder</code> 对象存储的实例的值时，并不会影响到其他线程的 <code>builder</code> 对象存储的实例（<code>thread-4</code> 线程改变存储的 <code>StringBuilder</code> 的值并不会引起 <code>thread-0</code> 线程的 <code>ThreadLocal instance mapping value hashcode</code> 值发生改变）</p>
<p>从输出中 <code>9~13</code> 行可以看出，一个线程对 <code>ThreadLocal</code> 对象存储的值发生改变时，并不会影响其他的线程（<code>thread-0</code> 线程调用 <code>set</code> 方法改变本线程 <code>ThreadLocal</code> 存储的对象值，本线程的 <code>ThreadLocal instance mapping value hashcode</code> 发生改变，但是 <code>thread-4</code> 的 <code>ThreadLocal instance mapping value hashcode</code> 并没有因此改变）。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><code>ThreadLocal</code> 能在每个线程间进行隔离，其主要是靠在每个 <code>Thread</code> 对象中维护一个 <code>ThreadLocalMap</code> 来实现的。因为是线程中的对象，所以对其他线程不可见，从而达到隔离的目的。那为什么是一个 <code>Map</code> 结构呢。主要是因为一个线程中可能有多个 <code>ThreadLocal</code> 对象，这就需要一个集合来进行存储区分，而用 <code>Map</code> 可以更快地查找到相关的对象。</p>
<p><code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 对象的一个静态内部类，内部维护一个 <code>Entry</code> 数组，实现类似 <code>Map</code> 的 <code>get</code> 和 <code>put</code> 等操作，为简单起见，可以将其看做是一个 <code>Map</code>，其中 <code>key</code> 是 <code>ThreadLocal</code> 实例，<code>value</code> 是 <code>ThreadLocal</code> 实例对象存储的值。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>当调用 <code>ThreadLocal</code> 的 <code>set</code> 方法给变量设置值时，<code>ThreadLocal</code> 对象会先获取本线程的 <code>ThreadLocalMap</code> 对象，然后将当前的 <code>ThreadLocal</code> 对象及要设置值作为键值对放入 <code>Map</code> 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的 ThreadLocalMap 对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// this 指当前的 ThreadLocal 对象</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// key 不存在，则创建 map 并设置值</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="comment">// threadLocals 是 Thread 中的一个变量，因此是线程隔离的，不会受其他线程影响</span></span><br><span class="line">    <span class="comment">// 其在 Thread 类中的定义如下：ThreadLocal.ThreadLocalMap threadLocals = null;</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>获取 <code>ThreadLocal</code> 存储的对象值时，需要调用 <code>get</code> 方法。此方法也是先获取本线程的 <code>ThreadLocalMap</code> 对象，然后将当前的 <code>ThreadLocal</code> 对象作为 <code>key</code> 从 <code>Map</code> 中获取对应的值，如果没有，则返回一个初始 <code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的 ThreadLocalMap 对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// this 指当前的 ThreadLocal 对象</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p> <code>ThreadLocalMap</code> 中的 <code>key</code> 是一个 <code>ThreadLocal</code> 对象，且是一个弱引用，而 <code>value</code> 却是一个强引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">      * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">      * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">      * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">      * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">      * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>毫无疑问，如果线程执行完关闭，那么线程的所有对象都会被销毁，此时不会存在内存泄漏的问题。此外，在执行 <code>get</code>、<code>set</code> 操作时，调用进入 <code>ThreadLocalMap</code> 内部的函数，会对 <code>Entry</code> 进行检查，如果 <code>key</code> 为空，也会将 <code>value</code> 设置为空，让其可以被垃圾回收。所以一般情况下也不会造成内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get 或 set 方法，满足一定条件时会进入 expungeStaleEntry 方法</span></span><br><span class="line"><span class="comment">// 此方法内部会将 key 为 null 的 Entry 的 value 设置为 null，从而使得其可以被垃圾回收</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 value 值为 null，清空引用，让其可以被 GC 回收</span></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置 value 值为 null，清空引用，让其可以被 GC 回收</span></span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，存在一种情况，可能导致内存泄漏。如果在某一时刻，将 <code>ThreadLocal</code> 实例设置为 <code>null</code>，即没有 <code>ThreadLocal</code> 没有强引用了，如果发生 GC 时，由于 <code>ThreadLocal</code> 实例只存在弱引用，所以被回收了，但是 <code>value</code> 仍然存在一个当前线程连接过来的强引用，其不会被回收，只有等到线程结束死亡或者手动清空 <code>value</code>  或者等到另一个 <code>ThreadLocal</code> 对象进行 <code>get</code> 或 <code>set</code> 操作时刚好触发 <code>expungeStaleEntry</code> 函数并且刚好能够检查到本 <code>ThreadLocal</code> 对象 <code>key</code> 为空（概率太小），这样才不会发生内存泄漏。否则，<code>value</code> 始终有引用指向它，它也不会被 GC 回收，那么就会导致内存泄漏。虽然发生内存泄漏的概率比较小，但是为了保险起见，也建议在使用完 <code>ThreadLocal</code> 对象后调用一下 <code>remove</code> 方法清理一下值。</p>
<p><img src="/images/threadlocal.png" alt="内存泄漏"></p>
<h1 id="与线程池结合使用"><a href="#与线程池结合使用" class="headerlink" title="与线程池结合使用"></a>与线程池结合使用</h1><p>由于线程池是会复用线程的，因此如果在线程任务中对 <code>ThreadLocal</code> 没有经过重新设值而直接读取值的话，可能读取到的是该线程上一个任务赋值的结果，而不是本次任务的初始值，从而导致一些意向不到的错误。如下所示，创建一个固定大小是 3 的线程池，但是往线程池中放入 5 个任务，则最后两个任务会复用之前创建的线程，此时调用 <code>ThreadLocal</code> 的 <code>get</code> 方法获取到的是上一个任务赋值的结果，而不是本线程的初始值（程序输出的第<code>4~5</code> 行就是复用了线程 <code>11</code> 和 <code>13</code>，第一次获取到的是也是上一个任务赋的值 <code>2</code>，而不是本线程的初始值 <code>1</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadLocalExecutor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; id = ThreadLocal.withInitial(() -&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">                <span class="comment">// 任务开始时重新赋值，否则可能读取到的是上一个任务的值</span></span><br><span class="line">                <span class="comment">// id.set(1);</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">before</span> <span class="operator">=</span> id.get();</span><br><span class="line">                increment();</span><br><span class="line">                <span class="type">int</span> <span class="variable">after</span> <span class="operator">=</span> id.get();</span><br><span class="line"></span><br><span class="line">                System.out.printf(<span class="string">&quot;Thread id: %d, before increment: %d, after increment: %d\n&quot;</span>, threadId, before, after);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> id.get() + <span class="number">1</span>;</span><br><span class="line">        id.set(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread id: 11, before increment: 1, after increment: 2</span><br><span class="line">Thread id: 13, before increment: 1, after increment: 2</span><br><span class="line">Thread id: 12, before increment: 1, after increment: 2</span><br><span class="line">Thread id: 13, before increment: 2, after increment: 3</span><br><span class="line">Thread id: 11, before increment: 2, after increment: 3</span><br></pre></td></tr></table></figure>

<p>为了避免如上情况的发生，可以在每个任务开始时，为 <code>ThreadLocal</code> 对象重新设置初始值（在 <code>get</code> 方法前先调用 <code>set</code> 方法），或者使用原生的创建线程的方式（跳开线程池的方式）。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java8 思维导图</title>
    <url>/java8-mind/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java8 中提供了很多方便开发人员的特性，包括：lambda 表达式、流操作、默认函数等。本文主要是将这些特性以思维导图的方式进行总结，方便后续复习。</p>
<span id="more"></span>

<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="/images/Java8.bmp" alt="java8 特性思维导图"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaagent-premain使用介绍</title>
    <url>/javaagent-premain/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>javaagent是jvm提供的一个“插件”，通过在javaagent可以在不侵入源码的情况下在运行时动态修改java类。本文将介绍如何通过启动时加载 javaagent，利用premain的方式在不修改源码的情况下将部分函数功能进行替换或修改。</p>
<span id="more"></span>

<h1 id="基础类介绍"><a href="#基础类介绍" class="headerlink" title="基础类介绍"></a>基础类介绍</h1><p>本例中要修改的函数是 <code>TestUser</code> 中的 <code>toString</code> 和 <code>getName</code>，其中，<code>toString</code> 是整体替换，<code>getName</code> 是在函数执行前后分别打印一条日志。<code>TestUser</code> 基础类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guozhchun.javaagent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestUser</span><span class="params">(String id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get name in TestUser&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;TestUser&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="premain-函数"><a href="#premain-函数" class="headerlink" title="premain 函数"></a>premain 函数</h1><p>javaagent支持在启动时进行加载，此时需要实现以下的方法。JVM会首先寻找第一个带 <code>Instrumentation</code> 参数的方法，如果没有发现，再寻找第二个不带 <code>Instrumentation</code>的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void premain(String args, Instrumentation inst);</span><br><span class="line">public static void premain(String args);</span><br></pre></td></tr></table></figure>

<p>javaagent 也支持在运行过程中动态加载，此时则需要实现以下的方法。同样的，JVM会首先寻找第一个带 <code>Instrumentation</code> 参数的方法，如果没有发现，再寻找第二个不带 <code>Instrumentation</code>的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void agentmain(String args, Instrumentation inst);</span><br><span class="line">public static void agentmain(String args);</span><br></pre></td></tr></table></figure>

<p>这几个方法的第一个参数 <code>args</code> 是随同 <code>-javaagent</code> 一起传入的程序参数，如果这个字符串代表了多个参数，就需要自己解析这些参数。参数传递方式如 <code>-javaagent xxx.jar=key1=value1,key2=value2</code>，此时<code>args</code> 获取到的值是 <code>key1=value1,key2=value2</code> 。 <code>inst</code> 是 <code>Instrumentation</code>类型的对象，是JVM自动传入的，我们可以拿这个参数进行类增强等操作。</p>
<p>本例将使用启动时加载javaagent的方式进行功能的增强和修改。</p>
<p>首先，定义 <code>premain</code> 函数，并在函数中增加 <code>ClassFileTransformer</code> 转换类，这个类是用来增强待修改类和函数的。此类主要实现两个功能：</p>
<ul>
<li>重写 <code>TestUser</code> 类中 <code>toString</code> 方法，替换原有函数体</li>
<li>修改 <code>TestUser</code> 类中 <code>getName</code> 方法，在其函数体前后增加打印日志的操作</li>
</ul>
<p>本例中，用到了 <code>javassist</code> 库提供的函数来进行类方法的修改。其 <code>maven</code> 坐标如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.29.1-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>premain</code> 的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guozhchun.javaagent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAgentPreMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String args, Instrumentation inst)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------premain, args: &quot;</span> + args);</span><br><span class="line">        inst.addTransformer((loader, className, classBeingRedefined, protectionDomain, classfileBuffer) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (!className.equals(<span class="string">&quot;com/guozhchun/javaagent/TestUser&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">                <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.getCtClass(className.replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;.&quot;</span>));</span><br><span class="line">                <span class="type">CtMethod</span> <span class="variable">method</span> <span class="operator">=</span> ctClass.getDeclaredMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">                body += <span class="string">&quot;System.out.println(\&quot;Change in transformer: call toString\&quot;);&quot;</span>;</span><br><span class="line">                body += <span class="string">&quot;return \&quot;id: \&quot; + id + \&quot;, name: \&quot; + name;&quot;</span>;</span><br><span class="line">                body += <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">                method.setBody(body);</span><br><span class="line"></span><br><span class="line">                <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> ctClass.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">                ctMethod.insertBefore(<span class="string">&quot;System.out.println(\&quot;Change in transformer: Before get name\&quot;);&quot;</span>);</span><br><span class="line">                ctMethod.insertAfter(<span class="string">&quot;System.out.println(\&quot;Change in transformer: After get name\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">                ctClass.detach();</span><br><span class="line">                <span class="keyword">return</span> bytes;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="MANIFEST-MF"><a href="#MANIFEST-MF" class="headerlink" title="MANIFEST.MF"></a>MANIFEST.MF</h1><p>要使用 javaagent，还需要定义 MANIFEST.MF 文件，在文件中指明 <code>Premain-Class</code>，如本例中 <code>Premain-Class: com.guozhchun.javaagent.TestAgentPreMain</code>。同时需要将这个文件打包在 jar 中。</p>
<p>对于使用 <code>maven </code> 打包的方式，可以使用以下定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--自动添加META-INF/MANIFEST.MF --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>com.guozhchun.javaagent.TestAgentPreMain<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打出来的 MANIFEST.MF 文件如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Premain-Class: com.guozhchun.javaagent.TestAgentPreMain</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Build-Jdk-Spec: 1.8</span><br><span class="line">Created-By: Maven JAR Plugin 3.2.2</span><br></pre></td></tr></table></figure>

<h1 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h1><p>编写 main 函数，调用 <code>TestUser</code> 中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guozhchun.javaagent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAgent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------Test javaagent-------------&quot;</span>);</span><br><span class="line">        <span class="type">TestUser</span> <span class="variable">testUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestUser</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;alice&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;get user info: &quot;</span> + testUser);</span><br><span class="line">        System.out.println(<span class="string">&quot;get user id: &quot;</span> + testUser.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;get user name: &quot;</span> + testUser.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行-javaagent"><a href="#运行-javaagent" class="headerlink" title="运行 javaagent"></a>运行 javaagent</h1><p>把 <code>premain</code> 所在类及相关类打成 jar 包，运行 <code>TestAgent</code> main 方法，传入 <code>javaagent</code> 参数，<code>java -javaagent:xxx -jar xxx</code>。运行结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-------premain, args: null</span><br><span class="line">------------Test javaagent-------------</span><br><span class="line">Change in transformer: call toString</span><br><span class="line">get user info: id: 1, name: alice</span><br><span class="line">get user id: 1</span><br><span class="line">Change in transformer: Before get name</span><br><span class="line">get name in TestUser</span><br><span class="line">Change in transformer: After get name</span><br><span class="line">get user name: alice</span><br></pre></td></tr></table></figure>

<p>可以看到，在执行 <code>main</code> 函数前，会先执行 <code>premain</code> 方法。同时在调用 <code>TestUser</code> 的相关方法时，也不是 <code>TestUser</code> 类中的默认实现，而是 <code>premain</code> 方法中增加的 <code>ClassFileTransformer</code> 类里修改过的函数体代码。从这里可以看出，javaagent确实是可以在不修改源码的前提下对部分类和函数进行功能的修改。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/510702981">https://zhuanlan.zhihu.com/p/510702981</a></li>
<li><a href="https://blog.csdn.net/WTUDAN/article/details/120573235">https://blog.csdn.net/WTUDAN/article/details/120573235</a></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/kmp/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>字符串匹配算法是常见的一种字符串操作，其是在一个主字符串中查找一个子字符串（也叫模式串），即判断模式串是否是主字符串的一个子串。最简单的做法是两个循环分别比较每个字符，直到找到匹配的位置或遍历结束。这种做法需要消耗 O(m * n) (m 表示主字符串的长度，n 表示模式串的长度) 的时间复杂度。而 KMP 算法则可以通过跳过一些重复的比较过程将时间复杂度控制在 O(m + n)  (m 表示主字符串的长度，n 表示模式串的长度)。</p>
<span id="more"></span>

<h1 id="传统字符串匹配算法"><a href="#传统字符串匹配算法" class="headerlink" title="传统字符串匹配算法"></a>传统字符串匹配算法</h1><h2 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h2><p>传统的字符串匹配算法，是用两个循环，外层循环遍历主字符串，里层循环遍历模式串。在外层循环的每一次循环过程，都以当前主字符串指针的位置为起始位置，遍历 n 个字符( n 为模式串长度)，与模式串的字符一 一进行比较，直到所有字符匹配或遍历结束。其过程大致如下图所示</p>
<p>当主字符串和模式串的当前位置字符匹配时，指针向后移动一位</p>
<p><img src="/images/KMP-1.png" alt="传统字符串匹配算法图1"></p>
<p>当发现有字符不匹配时，主字符串的查询起始位置相比上次的查询起始位置加一，模式串的查询起始位置归零</p>
<p><img src="/images/KMP-2.png" alt="传统字符串匹配算法图2"></p>
<p>重复上述过程直到所有字符匹配或遍历结束</p>
<p><img src="/images/KMP-3.png" alt="传统字符串匹配算法图3"></p>
<h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串匹配：如果 needle 是 haystack 的子字符串，则输出最先匹配的 haystack 的起始下标，否则返回 -1</span></span><br><span class="line"><span class="comment"> * 输入参数：haystack 主字符串； needle 模式串</span></span><br><span class="line"><span class="comment"> * 返回：-1 或其他非负整数。-1：needle 不是 haystack 的子字符串，其他非负整数：最先匹配的 haystack 的起始下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (haystack == <span class="literal">null</span> || needle == <span class="literal">null</span> || needle.length() &gt; haystack.length())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needle.length() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; haystack.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; needle.length(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + j &gt;= haystack.length() || haystack.charAt(i + j) != needle.charAt(j))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == needle.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>由于传统的字符串匹配算法在面对字符不匹配时，会将模式串的查询起始位置归零，而主字符串的查询起始位置仅仅是相比上次增加一而已。从这个地方进行重新比较，将会产生大量的重复的比较。例如主字符串是<code>abababababc</code>，模式串是<code>ababc</code>，采用传统的字符串匹配算法将会对<code>abab</code>在主字符串<code>abababababc</code>中进行重复的比较。而实际上，在模式串<code>c</code>字符匹配失败时，由于<code>abab</code>的最长相同前缀后缀是<code>ab</code>，所以下次重新进行查询匹配时，模式串的查询起始位置可以从第三个字符开始，而主字符串的查询起始位置也可以从失配的地方开始。这就可以减少字符串<code>ab</code>的重复匹配，而这也就是KMP算法的主要思想。</p>
<h2 id="基本过程-1"><a href="#基本过程-1" class="headerlink" title="基本过程"></a>基本过程</h2><p>KMP算法主要是先对模式串求解其部分匹配表（网上也有称之为 next 数组），即字符串的最长公共前缀后缀字符串长度，主要是用来在字符串发生失配时决定模式串指针的移动。然后用两个指针分别指向主字符串和模式串，比较两个指针指向的字符是否相同，如果相同，则分别将指针向后移动一位，如果不同，则保持主字符串指针不动，将模式串的指针根据其部分匹配表（或 next 数组）移动位置，进行下一轮比较。</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>其大致流程如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start=&gt;start: start</span><br><span class="line">end=&gt;end: end</span><br><span class="line">isFindOrEnd=&gt;condition: 是否完全匹配</span><br><span class="line">					  或遍历结束</span><br><span class="line">isCharEqual=&gt;condition: 主字符串和模</span><br><span class="line">					  式串指针指向</span><br><span class="line">					  位置的字符是</span><br><span class="line">					  否相等</span><br><span class="line">addPointer=&gt;operation: 主字符串和模式串</span><br><span class="line">					 指针向后移动一位</span><br><span class="line">isPatternStrFirstIndex=&gt;condition: 模式串指针</span><br><span class="line">								在第一个位置</span><br><span class="line">changePatternStrPoninter=&gt;operation: 主字符串指针不变，</span><br><span class="line">								  模式串指针根据部</span><br><span class="line">								  分匹配表进行变化</span><br><span class="line">changeMainStrPointer=&gt;operation: 模式串指针不变，</span><br><span class="line">							  主字符串指针向</span><br><span class="line">							  后移动一位</span><br><span class="line"></span><br><span class="line">start-&gt;isFindOrEnd(no)-&gt;isCharEqual(no)-&gt;isPatternStrFirstIndex(no)-&gt;changePatternStrPoninter(right)-&gt;isFindOrEnd</span><br><span class="line">isFindOrEnd(yes,right)-&gt;end</span><br><span class="line">isCharEqual(yes)-&gt;addPointer-&gt;isFindOrEnd</span><br><span class="line">isPatternStrFirstIndex(yes)-&gt;changeMainStrPointer(right)-&gt;isFindOrEnd</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>仍以“传统字符串匹配算法”章节中的例子为例，KMP算法的匹配过程大致如下</p>
<p>当主字符串和模式串的的指针指向的字符匹配时，两者的指针均向后移动一位</p>
<p><img src="/images/KMP-1.png" alt="KMP算法图1"></p>
<p>当主字符串和模式串的指针指向的字符不匹配时，如果模式串指针不是在第一位，则保持主字符串指针不动，根据部分匹配表将模式串的指针进行移动；如果模式串指针在第一位，则保持模式串指针不动，将主字符串指针向后移动一位</p>
<p><img src="/images/KMP-4.png" alt="KMP算法图2"></p>
<p>重复上述过程直到所有字符匹配或遍历结束</p>
<p><img src="/images/KMP-3.png" alt="KMP算法图3"></p>
<h2 id="部分匹配表的作用"><a href="#部分匹配表的作用" class="headerlink" title="部分匹配表的作用"></a>部分匹配表的作用</h2><p>部分匹配表是用来在字符匹配失败时决定模式串指针的移动的。那为什么这种方式有效呢。现在来解释一下为什么在字符不匹配时可以根据部分匹配表直接跳过模式串部分的字符，并且可以保持主字符串的指针不动。</p>
<p>首先，假设已经<strong>正确的</strong>求出了模式串的部分匹配表，在某个字符匹配失败时，模式串的前一个字符对应的部分匹配表的值为 n（为简单起见，假设为 2），根据KMP算法，可以得知模式串的指针应该指向第 3 个字符。如下图所示</p>
<p><img src="/images/KMP-5.png" alt="部分匹配表作用示例图-1"></p>
<p>可是为什么是第 3 个字符，而不是大于 3 的其他字符呢（为简单起见，假设为第 4 个字符）。如下图所示，假设可以指针跳到第 4 个字符，则意味着前 3 个字符与主字符指针的前 3 个字符相等，那么就可以推出刚才失配的位置前面的模式串子串的最长公共前缀后缀是 3 而不是 2，这与部分匹配表中的值 2 相矛盾，而在此之前已经假设了部分匹配表是正确的，所以在匹配失败时，模式串的指针只能跳到第 3 个字符而不是第 4 个字符。</p>
<p><img src="/images/KMP-6.png"></p>
<p>因此在字符匹配失败时，可以根据部分匹配表直接跳到将模式的指针移动到正确的位置并且可以跳过一些无效的重复比较项，从而提高效率。</p>
<h2 id="最长公共前缀后缀"><a href="#最长公共前缀后缀" class="headerlink" title="最长公共前缀后缀"></a>最长公共前缀后缀</h2><p>部分匹配表是根据字符串的最长公共前缀后缀求出的。那么什么是字符串的最长公共前缀后缀呢。假设一个字符串的长度为 m ，那么字符串的最长公共前缀后缀即是满足以下要求的由 [0, n] 组成子字符串：</p>
<ul>
<li>存在正整数 n，n &lt;&#x3D; m</li>
<li>由 [0, n] 组成的字符串与由 [m - n, m]组成的字符串相等</li>
<li>若 n &#x3D;&#x3D; m，则要求所有字符都相等，若 n !&#x3D; m，则由 [0, n + 1] 组成的字符串与由 [m - n - 1, m]组成的字符串不相等</li>
</ul>
<p>简单来说，就是一个字符串的最开始的前 n （n 要尽可能的大）个字符和最后的 n 个字符相等。例如：<code>aaaaaa</code>的最长公共前缀后缀是<code>aaaaaa</code>，而<code>aaaabbbaaabb</code>没有最长的公共前缀后缀，而<code>aaaabbaaa</code>的最长公共前缀后缀是<code>aaa</code></p>
<h2 id="部分匹配表求解过程"><a href="#部分匹配表求解过程" class="headerlink" title="部分匹配表求解过程"></a>部分匹配表求解过程</h2><p>部分匹配表（也称为 next 数组），主要的求解过程是用两个指针，第一个指针指向第一个字符，第二个指针指向第二个字符，然后比较两个指针指向的字符是否相等，如果相等，则当前第二个指针指向的字符的部分匹配表值是第一个指针所在位置的下标加一，然后分别将两个指针向后移动一位；如果两个指针指向的字符不相等，则取出第一个指针的前一位字符对应的部分匹配表的值，将第一个指针跳到此位置，然后与第二个指针指向的字符进行比较，如果不相等则重复上述过程直到相等或回到第一个字符，如果回到了第一个字符还没有遇到字符相等的情况，则值是0，然后将第二个指针往后移动一位，否则将第一个指针所在位置的下标加一得到当前第二个指针指向的字符的部分匹配表值，然后分别将两个指针往后移动一位。重复上述过程直到第二个指针到字符串末尾结束。</p>
<h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><p>其大致流程图如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start=&gt;start: start</span><br><span class="line">end=&gt;end: end</span><br><span class="line">declaration=&gt;operation: i 代表第二个指针，</span><br><span class="line">					  k 代表第一个指针，</span><br><span class="line">					  s 代表字符串，</span><br><span class="line">					  p 代表部分匹配表</span><br><span class="line">init=&gt;operation: i 在第二个位置，</span><br><span class="line">			    k 在第一个位置</span><br><span class="line">isEqual=&gt;condition: s[i] == s[k]</span><br><span class="line">getResult1=&gt;operation: p[i] = k + 1</span><br><span class="line">					 i++</span><br><span class="line">					 k++</span><br><span class="line">changeJ=&gt;operation: k = p[k - 1]</span><br><span class="line">isFirstPos=&gt;condition: k == 0</span><br><span class="line">getResult2=&gt;operation: p[i] = 0</span><br><span class="line">					 i++</span><br><span class="line">isEnd=&gt;condition: i 到字符串末尾</span><br><span class="line"></span><br><span class="line">start-&gt;declaration-&gt;init-&gt;isEqual(yes)-&gt;getResult1-&gt;isEnd(yes)-&gt;end</span><br><span class="line">isEqual(no)-&gt;isFirstPos(yes)-&gt;getResult2-&gt;isEnd</span><br><span class="line">isFirstPos(no)-&gt;changeJ(right)-&gt;isEqual</span><br><span class="line">isEnd(no)-&gt;isEqual</span><br></pre></td></tr></table></figure>

<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>仍以“传统字符串匹配算法”章节中的模式串为例，其求解部分匹配表的流程大致如下</p>
<p>第一次循环时，由于 k 和 i 所在位置的字符相等，所以 i 位置的部分匹配表的值为 k 的下标位置加一，然后将 k 和 i 分别向后移动一位</p>
<p><img src="/images/KMP-PM-1.png" alt="部分模式匹配求解过程-1"></p>
<p>第二次循环时，由于 k 和 i 所在位置的字符不匹配，所以将 k 移动到 k 前一个位置的部分匹配表的值对应的地方，即 0 的位置，此时与 i 位置的字符仍然不匹配，由于此时 k 已经是在字符串的第一个位置，所以此时 i 所在位置的部分匹配表的值为 0，然后将 i 向后移动一位</p>
<p>第三次循环时，由于 k 和 i 所在位置的字符相等，所以 i 位置的部分匹配表的值为 k 的下标位置加一，然后将 k 和 i 分别向后移动一位</p>
<p><img src="/images/KMP-PM-2.png" alt="部分模式匹配求解过程-2"></p>
<p>第四次循环时，由于 k 和 i 所在位置的字符相等，所以 i 位置的部分匹配表的值为 k 的下标位置加一，然后将 k 和 i 分别向后移动一位</p>
<p>第五次循环时，由于 k 和 i 所在位置的字符不匹配，所以将 k 移动到 k 前一个位置的部分匹配表的值对应的地方，即 1 的位置，此时与 i 位置的字符相等，所以 i 位置的部分匹配表的值为此时 k 的下标位置加一，即 2，然后将 k 和 i 分别向后移动一位</p>
<p><img src="/images/KMP-PM-3.png" alt="部分模式匹配求解过程-3"></p>
<p>第六次循环时，由于 k 和 i 所在位置的字符不匹配，所以将 k 移动到 k 前一个位置的部分匹配表的值对应的地方，即 1 的位置，此时与 i 位置的字符仍然不匹配，由于此时 k 不是在字符串的第一个位置，所以继续将 k 移动到 k 前一个位置的部分匹配表的值对应的地方，即 0 的位置，此时与 i 位置的字符仍然不匹配，由于此时 k 已经是在字符串的第一个位置，所以此时 i 所在位置的部分匹配表的值为 0。由于 i 已经到达字符串最后一位，所以结束循环。至此，字符串的部分匹配表也求解完毕</p>
<p><img src="/images/KMP-PM-4.png" alt="部分模式匹配求解过程-4"></p>
<h2 id="程序代码-1"><a href="#程序代码-1" class="headerlink" title="程序代码"></a>程序代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取字符串的部分匹配表（next数组），即截止当前位置的字符串的最长公共前缀后缀的长度（第一个位置默认为0）</span></span><br><span class="line"><span class="comment"> * 例如：输入&quot;aabaaac&quot;</span></span><br><span class="line"><span class="comment"> *      输出：[0, 1, 0, 1, 2, 2, 0]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getPartialMatchTable(String str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] partialMatchTable = <span class="keyword">new</span> <span class="title class_">int</span>[str.length()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    partialMatchTable[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; str.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (str.charAt(i) != str.charAt(pointer) &amp;&amp; pointer &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pointer = partialMatchTable[pointer - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == str.charAt(pointer))</span><br><span class="line">        &#123;</span><br><span class="line">            partialMatchTable[i] = pointer + <span class="number">1</span>;</span><br><span class="line">            pointer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            partialMatchTable[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> partialMatchTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串匹配：如果 needle 是 haystack 的子字符串，则输出最先匹配的 haystack 的起始下标，否则返回 -1</span></span><br><span class="line"><span class="comment"> * 输入参数：haystack 主字符串； needle 模式串</span></span><br><span class="line"><span class="comment"> * 返回：-1 或其他非负整数。-1：needle 不是 haystack 的子字符串，其他非负整数：最先匹配的 haystack 的起始下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (haystack == <span class="literal">null</span> || needle == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needle.length() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] partialMatchTable = getPartialMatchTable(needle);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 模式串的指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">// 主字符串的指针</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; haystack.length())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(index))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == needle.length() - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i - index;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            index++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果模式串指针大于0，说明已经进行了部分匹配，此时只需要根据部分匹配表移动模式串的指针即可，不需要移动主字符串的指针</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                index = partialMatchTable[index - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果模式串指针为0，说明第一个字符就匹配失败，此时需要移动主字符串指向到下一个位置</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/av3246487/?from=search&seid=17173603269940723925">https://www.bilibili.com/video/av3246487/?from=search&amp;seid=17173603269940723925</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构与算法</tag>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title>morris 算法</title>
    <url>/morris/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>morris 算法是一种二叉树的遍历算法，其利用树叶子节点的孩子为空的特点，将空的孩子节点临时指向其后继节点，后续再次遍历到该节点时重置为空使其恢复树的结构。这种遍历算法能够压缩空间，使其在 <code>O(1)</code> 的空间复杂度内完成对树结构的遍历。</p>
<span id="more"></span>

<h1 id="算法主要过程"><a href="#算法主要过程" class="headerlink" title="算法主要过程"></a>算法主要过程</h1><p>从根节点触发，对每个节点执行以下步骤</p>
<ul>
<li>如果存在左孩子，则找出左孩子的最右节点，<ul>
<li>如果该节点为空，则将其右指针指向当前节点（这是第一次遍历到该节点），将当前指针移到左孩子上</li>
<li>如果该节点指向了当前节点，则将其右指针置为空，恢复树的结构（这是第二次遍历到该节点），将当前指针移到右孩子上</li>
</ul>
</li>
<li>如果不存在左孩子，则将当前指针移到右孩子上，进行下一轮遍历</li>
</ul>
<p>通过上述遍历过程，如果某个节点有左孩子，则该节点被访问两次，如果节点没有左孩子，则该节点只被访问一次，因此，上述的遍历过程时间复杂度为 <code>O(n)</code>。由于使用循环遍历，没有使用递归的方式，因此不会有额外的空间消耗，其空间复杂度为 <code>O(1)</code>。</p>
<p>下面用一个例子来说明 morris 算法的遍历过程，假设有以下一颗树：</p>
<p><img src="https://guozhchun.github.io/images/morris-1.png" alt="morris-1"></p>
<p>首先，指针在节点<code>1</code> 处，由于有左孩子 <code>2</code> ，所以找到 <code>2</code> 的最右节点 <code>5</code>，由于节点 <code>5</code> 的右孩子为空，因此将其指向节点 <code>1</code>，并将当前指针移到左孩子节点 <code>2</code> 上。如下图所示</p>
<p><img src="https://guozhchun.github.io/images/morris-2.png" alt="morris-2"></p>
<p>接着，由于节点 <code>2</code> 有左孩子 <code>4</code>，所以找到 <code>4</code> 的最右节点是它本身，由于节点 <code>4</code> 的右孩子为空，因此将其指向节点 <code>2</code>，并将当前指针移到左孩子节点 <code>4</code> 上。如下图所示</p>
<p><img src="https://guozhchun.github.io/images/morris-3.png" alt="morris-3"></p>
<p>接着，节点 <code>4</code> 没有左孩子，直接到右孩子上（上一步骤已经将节点 <code>4</code> 的右孩子指向节点  <code>2</code>）上</p>
<p><img src="https://guozhchun.github.io/images/morris-4.png" alt="morris-4"></p>
<p>由于节点 <code>2</code> 有左孩子 <code>4</code>，所以找到 <code>4</code> 的最右节点是它本身，由于节点 <code>4</code> 的右孩子指向了当前节点，所以将节点 <code>4</code> 的右孩子节点置为空（还原树的结构），然后将当前指针移到右节点 <code>5</code> 上</p>
<p><img src="https://guozhchun.github.io/images/morris-5.png" alt="morris-5"></p>
<p>节点 <code>5</code> 没有左孩子，直接到右孩子上（之前步骤已经将节点 <code>5</code> 的右孩子指向节点  <code>1</code>）上</p>
<p><img src="https://guozhchun.github.io/images/morris-6.png" alt="morris-6"></p>
<p>由于节点 <code>1</code> 有左孩子 <code>2</code> ，所以找到 <code>2</code> 的最右节点 <code>5</code>，由于节点 <code>5</code> 的右孩子指向了当前节点 <code>1</code>，所以将节点 <code>5</code> 的右孩子置空（还原树的结构），然后将当前指针移到右节点 <code>3</code> 上</p>
<p><img src="https://guozhchun.github.io/images/morris-7.png" alt="morris-7"></p>
<p>由于节点 <code>3</code> 有左孩子 <code>6</code>，所以找到 <code>6</code> 的最右节点是它本身，由于节点 <code>6</code> 的右孩子为空，因此将其指向节点 <code>3</code>，并将当前指针移到左孩子节点 <code>6</code> 上</p>
<p><img src="https://guozhchun.github.io/images/morris-8.png" alt="morris-8"></p>
<p>节点 <code>6</code> 没有左孩子，直接到右孩子上（上一步骤已经将节点 <code>6</code> 的右孩子指向节点  <code>3</code>）上</p>
<p><img src="https://guozhchun.github.io/images/morris-9.png" alt="morris-9"></p>
<p>由于节点 <code>3</code> 有左孩子 <code>6</code>，所以找到 <code>6</code> 的最右节点是它本身，由于节点 <code>6</code> 的右孩子指向了当前节点，所以将节点 <code>6</code> 的右孩子节点置为空（还原树的结构），然后将当前指针移到右节点 <code>7</code> 上</p>
<p><img src="https://guozhchun.github.io/images/morris-10.png" alt="morris-10"></p>
<p>由于节点 <code>7</code> 的左右孩子都是空的，因此遍历结束。</p>
<h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><p>使用 morris 算法可以在 <code>O(1)</code> 的空间复杂度和 <code>O(n)</code> 的时间复杂度下完成对树的前序遍历，而使用递归的方式，则需要 <code>O(H)</code>（树的高度，函数递归栈）的空间复杂度和 <code>O(n)</code> 的时间复杂度。一般情况下，都是使用递归的方式进行前序遍历（简单直观），如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(TreeNode root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visit(root);</span><br><span class="line">    preOrderTraversal(root.left);</span><br><span class="line">    preOrderTraversal(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果对空间复杂度有特殊的要求，则可以使用 morris 算法来完成树的前序遍历，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preOrderMorrisTraversal</span><span class="params">(TreeNode root)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode prev;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.left != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prev = current.left;</span><br><span class="line">            <span class="keyword">while</span> (prev.right != <span class="literal">null</span> &amp;&amp; prev.right != current)</span><br><span class="line">            &#123;</span><br><span class="line">                prev = prev.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (prev.right == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                prev.right = current;</span><br><span class="line">                <span class="comment">// 前序遍历，先访问节点，再访问左右子树，所以在第一次找左子树最右节点后，将访问根节点</span></span><br><span class="line">                <span class="comment">// 第二次找当前节点左子树最右节点后，不再重新访问</span></span><br><span class="line">                visit(current);</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                prev.right = <span class="literal">null</span>;</span><br><span class="line">                current = current.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            visit(current);</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><p>递归的中序遍历也很简单直观，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inOrderTraversal(root.left);</span><br><span class="line">    visit(root);</span><br><span class="line">    inOrderTraversal(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>morris 的中序遍历跟前序遍历差不多，唯一不同就是访问根节点的顺序不同，前置遍历将访问根节点放在了第一次找根节点左子树最右节点的时候，中序遍历将访问根节点放在了第二次找根节点左子树最右节点的时候。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inOrderMorrisTraversal</span><span class="params">(TreeNode root)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode prev;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.left != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prev = current.left;</span><br><span class="line">            <span class="keyword">while</span> (prev.right != <span class="literal">null</span> &amp;&amp; prev.right != current)</span><br><span class="line">            &#123;</span><br><span class="line">                prev = prev.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (prev.right == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                prev.right = current;</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 当前序节点右指针指向当前节点时，说明左子树已经遍历完成</span></span><br><span class="line">                prev.right = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 中序遍历，需要先访问完左子树，再访问根节点</span></span><br><span class="line">                <span class="comment">// 所以需要在第二次找左子树的最右节点后才进行根节点的访问</span></span><br><span class="line">                visit(current);</span><br><span class="line">                current = current.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            visit(current);</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><p>递归的后续遍历，仍然是简单直观的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postOrderTraversal</span><span class="params">(TreeNode root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postOrderTraversal(root.left);</span><br><span class="line">    postOrderTraversal(root.right);</span><br><span class="line">    visit(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但 morris 的后序遍历就稍微复杂了点，其需要在第二次找根节点左孩子的最右节点时，以根节点左孩子到这个最右节点之间构成的链表进行反向遍历，完成树的后续遍历操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postOrderMorrisTraversal</span><span class="params">(TreeNode root)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode prev;</span><br><span class="line">    <span class="comment">// 为方便操作，此处虚拟一个额外的根节点，让其左指针指向当前树的根节点</span></span><br><span class="line">    <span class="comment">// 并以这个虚拟根节点作为 morris 算法遍历开始的根节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(DUMMY_VALUE);</span><br><span class="line">    dummy.left = root;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.left != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prev = current.left;</span><br><span class="line">            <span class="keyword">while</span> (prev.right != <span class="literal">null</span> &amp;&amp; prev.right != current)</span><br><span class="line">            &#123;</span><br><span class="line">                prev = prev.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (prev.right == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                prev.right = current;</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                prev.right = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 此处以当前节点的左子树为链表头节点，每个节点的右节点相互连接构成一个链表</span></span><br><span class="line">                <span class="comment">// 对链表进行反向遍历访问，即可完成当前节点左子树的前序遍历</span></span><br><span class="line">                visitReverse(current.left);</span><br><span class="line">                current = current.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 和前序遍历和中序遍历不同，此处不会进行节点的访问</span></span><br><span class="line">            <span class="comment">// 因为后序遍历需要先遍历完左右子树才访问根节点</span></span><br><span class="line">            <span class="comment">// 如果此处直接访问节点，此时右子树并没有遍历完成，会造成错误</span></span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">visitReverse</span><span class="params">(TreeNode root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> rightReverse(root);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(current);</span><br><span class="line">        current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    rightReverse(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(1) 空间复杂度、O(n) 时间复杂度进行链表倒序</span></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">rightReverse</span><span class="params">(TreeNode root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (root.right != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">next</span> <span class="operator">=</span> root.right;</span><br><span class="line">        root.right = next.right;</span><br><span class="line">        next.right = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 风之筝.经典算法小评(2)——Morris树遍历算法 [J&#x2F;OL].  <a href="https://ghh3809.github.io/2018/08/06/morris-traversal/#morris%E9%81%8D%E5%8E%86">https://ghh3809.github.io/2018/08/06/morris-traversal/#morris%E9%81%8D%E5%8E%86</a>, 2018-08-06<br>[2] god-jiang. 神级遍历——morris[J&#x2F;OL].  <a href="https://zhuanlan.zhihu.com/p/101321696">https://zhuanlan.zhihu.com/p/101321696</a>, 2020-01-06</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构与算法</tag>
        <tag>morris</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 中 count(*)、count(1)、count(主键ID)、count(列名) 的区别</title>
    <url>/mysql-count/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在平常使用过程中，经常需要用到 “计数” 的功能，但是有时会纠结于是使用 count(*)、count(1)、count(主键ID) 还是 count(列名)，这几种查询方式有什么区别呢？本文将对此进行简单的介绍。</p>
<span id="more"></span>

<h1 id="按结果集区别"><a href="#按结果集区别" class="headerlink" title="按结果集区别"></a>按结果集区别</h1><p>按照查询返回的结果集进行区分，可以将上述四种查询分为两类，一类是返回表中的总记录数（不考虑 where 的过滤条件，如果加上 where 的过滤条件，则是返回过滤后的所有记录数，下同），另一类是返回表中字段不为空的记录数。</p>
<ul>
<li>返回表中总记录数：count(*)、count(1)、count(主键ID) 都是属于这一类，其会扫描表中所有记录，不管这个记录中是否包含空字段（主键不为空），都会将这条记录返回并进行计数。</li>
<li>返回表中字段不为空的记录数：count(列名) 会自动过滤掉该列的值为空的记录，将非空的记录返回并进行记录</li>
</ul>
<p>可以看到，如果某个列中存在空值，则 count(*)、count(1)、count(主键ID) 查询得到的结果大于 count(列名) 查询得到的结果。如果某个列中不存在空值，则上述四种查询方式得到的结果相同。</p>
<h1 id="按查询性能区别"><a href="#按查询性能区别" class="headerlink" title="按查询性能区别"></a>按查询性能区别</h1><p>分析性能时，按照以下三个原则进行分析</p>
<ul>
<li>server 层需要什么，InnoDB 引擎层就返回什么</li>
<li>InnoDB 只给必要的值</li>
<li>现在的优化器只优化了 count(*) 的语义为 “取行数”，其他 “显而易见” 的优化并没有做</li>
</ul>
<p>四种查询的性能如下</p>
<ul>
<li>count(列名)：一行行地从表中读取该字段返回给 server 层，server 层进行判断，如果不为空，则计数加一。</li>
<li>count(主键ID)：遍历整张表，把每一行的 id 值取出来返回给 server 层，server 层判断到值不为空，计数加一。从这里看，count(主键ID) 与 count(列名) 的做法类似，似乎没有多大的性能差别，但是 count(主键ID) 可以选择最小的索引进行遍历，而 count(列名)，如果在该列上没有索引，则只能选择主键的索引进行遍历，这样就多了一层遍历。即使该字段上有索引，但可能该索引并不是最小的索引。因此，整体而言，count(列名) 的查询性能低于count(主键ID)。</li>
<li>count(1)：会选择最小的索引数进行遍历，但是遍历时并不会取出具体的值，server 层对于返回的每一行，放一个数字 “1” 进去，然后判断该值不为空，计数加一。可以看到，虽然其与 count(主键ID) 一样取最小的索引数进行遍历，但是 count(1) 并不会读取表中的数据值，而 count(主键ID) 需要读取表中的数据值进行返回，其多了一个操作，相比更加耗时。因此，count(1) 的查询性能优于  count(主键ID) 。</li>
<li>count(*)：mysql 专门对这个查询进行了优化，其会选择最小的索引数进行遍历，同样不会取值，server 层拿到返回的每一行数据，计数加一。</li>
</ul>
<p>从上述分析可以知，按查询效率而言， count(字段) &lt; count(主键ID) &lt; count(1) ≈ count(*)</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从查询结果而言，count(字段) 不会统计字段值为空的记录，count(主键ID)、count(1)、count(*) 会统计字段值为空的记录。从查询性能而言，count(字段) &lt; count(主键ID) &lt; count(1) ≈ count(*)。</p>
<p>因此，对于需要剔除非空字段的统计，使用 count(字段) 进行查询，对于需要统计所有字段（包含非空字段），使用 count(*) 进行查询。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 林晓斌.count(*)这么慢，我该怎么办？[J&#x2F;OL]. <a href="https://time.geekbang.org/column/article/72775%EF%BC%8C2018-12-14">https://time.geekbang.org/column/article/72775，2018-12-14</a></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>快排（C++）</title>
    <url>/quickSort-C-Plus/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> key = a[(start + end) / <span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> i = start, j = end;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j)  <span class="comment">// the &#x27;=&#x27; can remove</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// the &#x27;&lt;&#x27; can not change to &#x27;&lt;=&#x27;, or it will wrong</span></span><br><span class="line">        <span class="comment">// for example, the array is 3, 3, 3, 3. In this way, the key is 3</span></span><br><span class="line">        <span class="comment">// if the condition is a[i] &lt;= key, then i will increase to 4 which is out of the range of array</span></span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt; key)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="comment">// the &#x27;&gt;&#x27; can not change to &#x27;&gt;=&#x27;, or it will wrong</span></span><br><span class="line">        <span class="comment">// for example, the array is 3, 3, 3, 3. In this way, the key is 3</span></span><br><span class="line">        <span class="comment">// if the condition is a[j] &gt;= key, then i will decrease to -1 which is out of the range of array</span></span><br><span class="line">        <span class="keyword">while</span> (a[j] &gt; key)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="comment">// must have this if condition, or it will wrong</span></span><br><span class="line">        <span class="comment">// for example, the array is 3, 5, 7, 1, 8, 6, 4, 2</span></span><br><span class="line">        <span class="comment">// if don&#x27;t have the if condition, then the 5 will come to the left one and j will be -1</span></span><br><span class="line">        <span class="comment">// after that, the 5 will be in left one always, which is wrong obviously</span></span><br><span class="line">        <span class="comment">// must have &quot;=&quot;, considerate the array 2, 3. if not &quot;=&quot;, it will loop and can&#x27;t stop</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j)  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(a, start, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(a, i, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;please input the number count you want to sort: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;please input the number, seperate with space&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">quick_sort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the sort result is: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> []a;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>C/C++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql MVCC 介绍</title>
    <url>/mysql-mvcc/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MVCC （multiversion concurrency control），多版本并发控制，主要是通过在每一行记录中增加三个字段，与 undo log 中相关记录配合使用，同时加上可见性算法，使得各个事务可以在不加锁的情况下能够同时地读取到某行记录上的准确值（这个值对不同的事务而言可能是不同的）。使用 MVCC，在不加锁的情况下也能读取到准确的数据，大大提高了并发效率。</p>
<span id="more"></span>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>提到 MVCC，必须提到事务。关于事务，有四个特性，即我们常说的 ACID。</p>
<ul>
<li>原子性（Atomicity）：表示事务要么全部执行，要么全部不执行，这是一个不可分割的最小单元</li>
<li>一致性（Consistency）：表示事务总是从一个一致的状态转移到另一个一致的状态</li>
<li>隔离性（Isolation）：表示各个事务之间相关隔离，互不影响</li>
<li>持久性（Durability）：指一个事务一旦被提交，它对数据库的改变就是永久性的，即使后续数据库发生故障也不会有影响</li>
</ul>
<p>而事务隔离性又分为四种级别：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）、串行化（serializable）。</p>
<ul>
<li>读未提交：指一个事务还没有提交，它本身所做的修改就能被其他事务所看到。在这种情况下，会产生脏读、幻读和不可重复读的问题。</li>
<li>读提交：指一个事务提交之后，它本身所做的修改就能被其他事务所看到。在这种情况下，解决了「读未提交」的脏读问题，但是仍然会产生幻读和不可重复读的问题。</li>
<li>可重复读：指在同一个事务之中，读到的数据是一致的。这种隔离级别下，可以解决脏读和不可重复读的问题，但是仍然存在幻读的问题。</li>
<li>串行化：指多个事务中，如果读写锁冲突时，后访问的事务必须等前一个事务执行完成后才能继续执行。这种隔离级别最高，也解决了脏读、幻读和不可重复读的问题。但是其也大大限制了并发的程度。</li>
</ul>
<p>关于这四种隔离级别的差异，可以通过以下例子（例子来源于：<a href="https://time.geekbang.org/column/article/68963">林晓斌：MySQL实战45讲</a>）来加以说明。</p>
<p>假设存在一张表，里面只有一个字段和一条记录，值是 1，现在发生以下的操作</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>t1</td>
<td>启动事务，查询得到值 1</td>
<td></td>
</tr>
<tr>
<td>t2</td>
<td></td>
<td>启动事务</td>
</tr>
<tr>
<td>t3</td>
<td></td>
<td>查询得到值 1</td>
</tr>
<tr>
<td>t4</td>
<td></td>
<td>将 1 改成 2</td>
</tr>
<tr>
<td>t5</td>
<td>查询得到值 V1</td>
<td></td>
</tr>
<tr>
<td>t6</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>t7</td>
<td>查询得到值 V2</td>
<td></td>
</tr>
<tr>
<td>t8</td>
<td>提交事务</td>
<td></td>
</tr>
<tr>
<td>t9</td>
<td>查询得到值 V3</td>
<td></td>
</tr>
</tbody></table>
<p>针对不同的隔离级别，V1、V2、V3 读到的值不同。</p>
<p>在「读未提交」的隔离级别下，由于 t4 时刻事务 B 将值改成了 2，虽然 B 还没提交事务，但是此时的修改对其他事务是可见的，所以 V1、V2、V3 查询到的值都是 2。</p>
<p>在「读提交」的隔离级别下，t4 时刻修改了值，但是在 t5 时刻，事务 B 还没有提交，此时事务 A 读取到的值还是老的值，所以 V1 是 1，而在 t7 时刻，由于事务 B 已经在 t6 时刻提交了，此时事务 B 所做的修改对其他的事务都可见，所以事务 A 在 t7 时刻能看到事务 B 的修改，此时 V2 的值为 2，当然 V3 的值也为 2。</p>
<p>在「可重复读」的隔离级别下，遵循 “事务在执行期间看到的数据必须是前后一致” 的要求，所以无论事务 B 是否修改值，也无论事务 B 是否提交，事务 A 在没提交前读到的值都是相同的，即 V1 和 V2 的值都是 1，当 A 事务提交后，再次查询时，事务 B 的修改就能被 A 看到了，所以 V3 的值为 2。</p>
<p>在「串行化」的隔离级别下，当事务 B 在 t4 时刻执行更新时，由于与事务 A 操作的是同一行，且出现读写冲突，此时事务 B 被会阻塞，等待事务 A 执行完毕后，再执行事务 B，所以 V1 和 V2 的值是 1，V3 的值是 2。</p>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><h2 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h2><p>在数据库表的记录中，每一个记录都会添加三个字段：</p>
<ul>
<li><p>DB_TRX_ID：6个字节，表示最近一次修改本记录的事务ID</p>
</li>
<li><p>DB_ROLL_PTR ：7 个字节，回滚指针，指向回滚段中的 undo log record，用于找出这个记录的上个修改版本的数据。</p>
</li>
<li><p>DB_ROW_ID：6 个字节，一个单调递增的 ID，确定表中记录的唯一性。</p>
</li>
</ul>
<p>当对某个记录进行更新时，会将当前记录写入 undo log 中，并更新当前记录中 DB_ROLL_PTR 字段值，使其指向刚才的 undo log record，然后更新当前记录相关字段值，同时更新 DB_TRX_ID 字段，记录执行更新操作的事务 ID。简略的更新过程大致如下所示</p>
<p><img src="/images/mysql-mvcc-1.png" alt="mysql-mvcc-update"></p>
<h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><p>由上面的更新操作可以得知，数据库表记录始终记录着最新的更新结果，那对于「可重复读」和「读提交」的隔离级别的事务，它是如何保证在开启本事务后，其他事务对记录进行了更新操作，而本事务仍然能够读取到准确的值（不是表记录的最新值，而是历史版本的值）的？从更新操作中可以得知，通过循环遍历 DB_ROLL_PTR 可以拿到当前记录的历史版本（当然，只是活跃的事务，如果当前记录没有相关事务在操作，则会清理 undo log，就不能拿到历史版本数据了） 。但是这么多历史版本的数据，究竟哪个版本的数据才是当前事务所要的呢？这时就要判断当前版本的数据是否对当前事务可见了。</p>
<p>在开启事务时，会将当前活跃的事务（已经开启了事务，但是还没有提交）的事务 ID 放在一个数组里面，同时记录数组里面最小的事务 ID 为「低水位」，记录当前系统已经创建的事务ID 的最大值加一为「高水位」。这三者组成了一个事务的一致性视图（read-view）。当事务要查询某个记录的数据时，实际上就是拿该记录的事务ID（包括历史版本的事务ID）和这个一致性视图进行比较，直到某个版本的数据是可见的为止。其查询过程如下：</p>
<ul>
<li>读取的记录的事务ID小于低水位，说明这个版本的数据在开启本事务前已经提交，是可见的，直接返回这个数据</li>
<li>读取的记录的事务ID大于高水位，说明这个版本的数据在开启本事务后提交的，不可见，从记录中取出 DB_ROLL_PTR 指向的记录并读取其事务 ID，开始下一轮的判断</li>
<li>读取的记录的事务ID介于低水位和高水位中间，此时判断事务ID是否在一致性视图的事务数组中：<ul>
<li>如果不在，说明这个版本的数据在开启本事务前已经提交，是可见的，直接返回这个数据</li>
<li>如果在，说明这个版本的数据是由开启事务后的其他活跃事务提交的，对本事务是不可见的，因此需要从记录中取出 DB_ROLL_PTR 指向的记录并读取其事务 ID，开始下一轮的判断</li>
</ul>
</li>
</ul>
<p>其判断过程的流程图大致如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start=&gt;start: Start</span><br><span class="line">readTxId=&gt;operation: 读取记录中的事务ID（DB_TRX_ID）</span><br><span class="line">isLessLow=&gt;condition: 事务ID小于低水位</span><br><span class="line">isMoreHigh=&gt;condition: 事务ID大于高水位</span><br><span class="line">isInArray=&gt;condition: 事务ID在一致</span><br><span class="line">					  性事务数组中</span><br><span class="line">nextRecode=&gt;operation: 根据 DB_ROLL_PTR 取出历史版本记录</span><br><span class="line">return=&gt;operation: 返回当前记录数据</span><br><span class="line">end=&gt;end</span><br><span class="line"></span><br><span class="line">start-&gt;readTxId-&gt;isLessLow(yes,right)-&gt;return</span><br><span class="line">isLessLow(no)-&gt;isMoreHigh(yes)-&gt;nextRecode</span><br><span class="line">isMoreHigh(no)-&gt;isInArray(yes)-&gt;nextRecode</span><br><span class="line">isInArray(no)-&gt;return</span><br><span class="line">nextRecode(left)-&gt;readTxId</span><br><span class="line">return-&gt;end</span><br></pre></td></tr></table></figure>

<p>关于判断数据可见性，除了上述用高水位、低水位和事务视图数组结合判断之外，可以简化成以下规则判断：</p>
<ul>
<li>对于当前事务中的数据，可见</li>
<li>对于其他事务中的数据<ul>
<li>如果版本未提交，不可见</li>
<li>如果版本已经提交，且是在创建本事务视图后提交的，不可见</li>
<li>如果版本已经提交，且是在创建本事务视图前提交的，可见</li>
</ul>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>现在用一个例子（此例子来自：<a href="https://time.geekbang.org/column/article/70562">林晓斌：MySQL实战45讲</a>）来对上述查找过程进行说明。假设在「可重复读」的隔离级别下，有以下的表结构和数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `k` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into t(id, k) values(1,1),(2,2);</span><br></pre></td></tr></table></figure>

<p>假设进行以下的操作（事务C 的 update 操作完即自动提交事务），在进行以下操作前，假设当前活跃的事务 ID 为 99，记录（1,1）的 DB_TRX_ID 值是 90。则事务 A 的视图数组是 [99, 100]，事务 B 的视图数组是 [99, 100, 101]，事务 C 的视图数组是 [99, 100, 101, 102]</p>
<table>
<thead>
<tr>
<th>事务A（事务ID：100）</th>
<th>事务B（事务ID：101）</th>
<th>事务C（事务ID：102）</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction with consistent snapshot;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>start transaction with consistent snapshot;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set k &#x3D; k + 1 where id &#x3D; 1;</td>
</tr>
<tr>
<td></td>
<td>update t set k &#x3D; k + 1 where id &#x3D; 1;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select k from t where id &#x3D; 1;</td>
<td></td>
</tr>
<tr>
<td>select k from t where id &#x3D; 1;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>commit;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p>当事务 A 执行查询语句时，其查询数据逻辑图（此图来自：<a href="https://time.geekbang.org/column/article/70562">林晓斌：MySQL实战45讲</a>）如下所示</p>
<p><img src="/images/mysql-mvcc-2.png" alt="mysql-mvcc-query"></p>
<p>其查找过程如下，首先，获取记录的事务ID（101），比高水位大，不可见，所以取出记录的上一个历史版本，获取其事务ID（102），比高水位大，不可见，再获取记录的上一个历史版本，获取其事务ID（90），比低水位小，可见，所以返回这个记录中的 k 字段的值 1。</p>
<p>当然，也可以用简化版本来判断。过程如下，首先，获取记录（1，3），还没有提交，不可见，取出上一个历史版本（1，2），（1，2）已经提交，但是在本事务视图创建后提交的，不可见，继续取出上一个历史版本（1，1），（1，1）已经提交，且是在本事务视图创建前提交的，可见，所以最终返回 k 的值是 1。</p>
<p>此处需要额外关注的是，事务 B 的更新操作，是在当前记录的最新值上更新的，并不是在历史数据上更新的，否则会丢失事务 B 的更新操作。其实，更新数据都是先读后写的，而且这个读，是读的当前值，称为“当前读”。</p>
<p>如果是在「读提交」的隔离级别下，处理逻辑类似，只是生成一致性视图的情况不同：</p>
<ul>
<li>在「可重复度」隔离级别下，只需要在事务开始的时间创建一致性视图，之后事务里的其他查询都共用这个一致性视图</li>
<li>在「读提交」隔离级别下，每一个语句执行前都会重新算出一个新的视图</li>
</ul>
<p>所以上述例子，如果是在「读提交」隔离级别下，事务 A 在执行查询语句时，会创建新的一致性视图，此时一致性视图中的活跃事务ID数组是 [99, 100, 101]，其查找过程如下，读取当前记录事务 ID（101），在视图数组中，不可见，取出上一个历史版本记录，读取事务ID（102），介于低水位和高水位之间，且不在视图数组中，可见，所以返回记录的 k 值 2。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>四种隔离级别，只有「读提交」和「可重复度」两个隔离级别能够使用 MVCC，因此也只有这两个隔离级别会创建一致性视图（read-view）。因为「读提交」隔离级别下每次都是读取的最新记录，所以不用 MVCC，也不用创建一致性视图；「串行化」隔离级别，则是用加锁方式来实现并发的，也不用 MVCC ，所以也不用创建一致性视图。关于「可重复度」和「读提交」两个隔离级别下一致性视图的差别，主要体现在：「可重复度」隔离级别下的一致性视图是在启动事务时创建的，创建后，本事务共用一个视图；而「可读提交」隔离级别下的一致性视图是在执行 SQL 时创建的，每一个 SQL 都会单独创建一个视图，并不会共用。</li>
<li>当前读（current read），每次读取的都是记录的最新数据，主要包含以下 SQL 语句<ul>
<li>select … lock in share mode</li>
<li>select … for update</li>
<li>insert</li>
<li>update</li>
<li>delete</li>
</ul>
</li>
<li>快照读（snapshot read），可能读取记录的历史版本数据，主要用于 MVCC 中的简单的 select （不包括 select … lock in share mode，select … for update），保证事务读取的一致性。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 林晓斌. 事务隔离：为什么你改了我还看不见？[J&#x2F;OL].  <a href="https://time.geekbang.org/column/article/68963">https://time.geekbang.org/column/article/68963</a> ，2018-11-19<br>[2] 林晓斌. 事务隔离：事务到底是隔离的还是不隔离的？[J&#x2F;OL].   <a href="https://time.geekbang.org/column/article/70562">https://time.geekbang.org/column/article/70562</a>  ，2018-11-30<br>[3] MySQL官方文档： <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html</a> </p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 索引介绍</title>
    <url>/mysql-index/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MySQL 索引是为了帮助 MySQL 更快的查找数据而建立的一种数据结构，大部分的索引都是通过 B+ 树来实现的。由于 B+ 树内部维护着有序的数据结构，因此当查找某些具体的值时，通过索引能够快读定位到对应的行数据，从而避免顺序读取或全表扫描。通过这种方式，可以减少磁盘 IO 的次数，从而提高查询效率。</p>
<span id="more"></span>

<h1 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h1><ul>
<li><p>优点</p>
<p>索引是结合了排序和查找两大功能的数据结构（针对 B+ 树），通过索引，可以快速提高检索效率，减少服务器需要扫描的数据量，减少了磁盘 IO。另一方面，由于索引内部是有序的结构，可以利用排好序的索引避免一些重复的排序操作，降低数据排序的成本，减低了 CPU 的消耗。</p>
</li>
<li><p>缺点</p>
<p>由于索引内部需要维护有序的结构（针对 B+ 树），所以插入、更新或删除操作都需要同步维护索引数，这会降低这些操作的执行效率。另一方面，索引文件需要保存到磁盘中，因此如果建立的索引过大或过多，会占用比较多的磁盘空间。</p>
</li>
</ul>
<h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><h2 id="按数据结构进行分类"><a href="#按数据结构进行分类" class="headerlink" title="按数据结构进行分类"></a>按数据结构进行分类</h2><p>按索引实现的数据结构进行分类，可以将索引分为：B+ 树索引，哈希索引、R 树索引、倒排索引（反向索引）。</p>
<ul>
<li><p>B+ 树索引</p>
<p>这是最常见的索引类型，基于 B 树数据结构实现的，也是 InnoDB 存储引擎默认采用的的索引类型。B+ 树是一种排好序的数据结构，因此可以用来对某个值进行精确查找或范围查找。</p>
<p>在 InnoDB 存储引擎中，B+ 树索引还可以细分为聚簇索引和非聚餐索引。</p>
<ul>
<li><p>聚簇索引</p>
<p>树的叶子节点的内容存放的是整行的数据，也就是使用聚簇索引查找到叶子节点后，可以直接拿出需要的其他列的数据。常用于主键索引。如果一张表中没有指定主键，MySQL 会自动为每一行生成一个唯一的标识符。</p>
</li>
<li><p>非聚簇索引</p>
<p>树的叶子节点的内容存放的是主键 ID（如果表没有设置主键，则存的是 MySQL 自动生成的类似主键的标识符）。使用这种索引进行查找，当查找到叶子节点后，如果需要查询的数据不是主键列，则需要拿到主键 ID 后回到主键索引数上再次进行查找以获取其他的数据，此时就需要两次查找，这种查询方式也称为「回表扫描」。当然，如果查找的列刚好就包含在索引中，就可以直接取出索引的值而不用回到主键树上再进行扫描了，这种也称为「覆盖索引」。</p>
</li>
</ul>
</li>
<li><p>哈希索引</p>
<p>基于哈希表实现，当用于精确查找时，其速度由于 B+ 索引树，但是由于哈希表是无序的，因此哈希索引也只能用于精确查找，不支持范围查找，也就是说如果使用哈希索引，则使用 <code>order by</code> 或 <code>group by</code> 时需要在 server 层进行排序，而无法利用索引在存储引擎中将数据准备好。</p>
</li>
<li><p>R 树索引</p>
<p>也称为空间（spatial）索引，基于 R 树实现的索引方式，常用于表示空间数据结构的类型。</p>
</li>
<li><p>倒排索引</p>
<p>主要用于全文（FULLTEXT）索引的构建，是一种快速匹配文档的方式。</p>
</li>
</ul>
<h2 id="按创建方式进行分类"><a href="#按创建方式进行分类" class="headerlink" title="按创建方式进行分类"></a>按创建方式进行分类</h2><p>根据创建时的不同做法，可以将索引分成：单值索引和复合索引。</p>
<ul>
<li><p>单值索引</p>
<p>一个索引只包含数据表中的一个列，一个表可以存在多个不同的单值索引。如果在创建索引时加上 <code>unique</code> ，则成为唯一索引，要求索引值必须唯一不能重复，但允许有空值。</p>
</li>
<li><p>复合索引</p>
<p>一个索引包含多个列。与单值索引相同，也可以在创建索引时加上 <code>unique</code> ，使其成为唯一索引。</p>
</li>
</ul>
<h1 id="索引基本用法"><a href="#索引基本用法" class="headerlink" title="索引基本用法"></a>索引基本用法</h1><ul>
<li><p>查看表上的索引</p>
<p>使用 <code>show index from $&#123;tableName&#125;</code> 命令可以查看 <code>$&#123;tableName&#125;</code> 表上有哪些索引，以及索引的类型等</p>
</li>
<li><p>为表的字段建索引</p>
<p>创建索引有两种方式，一种是 <code>create</code> 命令，一种是 <code>alter</code> 命令</p>
<ul>
<li><p><code>create</code> 方式</p>
<p>使用命令 <code>create [unique|fulltext|spatial] index $&#123;indexName&#125; on $&#123;tableName&#125; ($&#123;colName1&#125;, $&#123;colName2&#125;)</code> 可以为表 <code>$&#123;tableName&#125;</code> 的 <code>$&#123;colName1&#125;, $&#123;colName2&#125;</code> 字段建立名称为 <code>$&#123;indexName&#125;</code> 的索引。其中 <code>unique</code> 表示建立的是唯一索引，<code>fulltext</code> 表示建立的是全文索引，<code>spatial</code> 表示建立的是空间索引。</p>
</li>
<li><p><code>alter</code> 方式</p>
<p>使用命令 <code>alter table $&#123;tableName&#125; add [unique|fulltext|spatial] index $&#123;indexName&#125; ($&#123;colName1&#125;, $&#123;colName2&#125;)</code> 可以为表 <code>$&#123;tableName&#125;</code> 的 <code>$&#123;colName1&#125;, $&#123;colName2&#125;</code> 字段建立名称为 <code>$&#123;indexName&#125;</code> 的索引。其中 <code>unique</code> 表示建立的是唯一索引，<code>fulltext</code> 表示建立的是全文索引，<code>spatial</code> 表示建立的是空间索引。</p>
</li>
</ul>
</li>
<li><p>删除表上的索引</p>
<p>创建索引有两种方式，一种是 <code>drop</code> 命令，一种是 <code>alter</code> 命令</p>
<ul>
<li><p><code>drop</code> 方式</p>
<p>使用 <code>drop index $&#123;indexName&#125; on $&#123;tableName&#125;</code> 命令可以将  <code>$&#123;tableName&#125;</code> 表上的 <code>$&#123;indexName&#125;</code> 的索引删除</p>
</li>
<li><p><code>alter</code> 方式</p>
<p>使用命令 <code>alter table $&#123;tableName&#125; drop index $&#123;indexName&#125;</code> 可以将  <code>$&#123;tableName&#125;</code> 表上的 <code>$&#123;indexName&#125;</code> 的索引删除</p>
</li>
</ul>
</li>
</ul>
<h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><h2 id="explain-使用"><a href="#explain-使用" class="headerlink" title="explain 使用"></a>explain 使用</h2><p>explain 是查看 MySQL 执行计划的命令，通过该命令可以查看表的执行顺序和索引的使用情况，常用于分析 SQL 语句执行效率。使用 explain 只需要在 SQL 语句前加上关键字 <code>explain</code> 即可。如下图所示</p>
<p><img src="/images/mysql-index-1.png" alt="mysql explain"></p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>执行计划中，第一列是 id，可以是一个数字也可以是 <code>NULL</code>。如果是数字，则数字越大优先级越高（先被执行），如果是相同数字，则按顺序从上到下执行。如果是 <code>NULL</code> 表示该查询的结果来自于其他其他几个查询结果的并集。此时 <code>table</code> 列显示 <code>&lt;union M,N&gt;</code> 表示此结果来自于 <code>id</code> 是 <code>M</code> 和 <code>N</code> 的查询结果的并集。如下所示，表示 <code>NULL</code> 列是最后的结果集，表示其结果来自 <code>id</code> 为 <code>1</code> (tb1 表查询结果) 和 <code>2</code> （tb2 表查询结果）的融合。</p>
<p><img src="/images/mysql-index-2.png" alt="mysql explain id"></p>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>表明查询的类型，主要用于区别普通查询、子查询和联合查询，常见的有：SIMPLE、PRIMARY、UNION、UNION RESULT、SUBQUERY、DEPENDENT SUBQUERY、DERIVED。更多的请参考 <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_select_type">MySQL官方文档</a></p>
<ul>
<li>SIMPLE：表明这是一个简单查询，不包含子查询或 UNION</li>
<li>PRIMARY：查询中如果包含子查询或 UNION 等复杂查询，最外层的查询标记为 PRIMARY</li>
<li>UNION：UNION 关键字连接的后面的查询语句</li>
<li>UNION RESULT：从 UNION 结果集中获取查询结果的语句</li>
<li>SUBQUERY：子查询列表中的第一个 select 语句</li>
<li>DEPENDENT SUBQUERY：字查询列表中的第一个 select 语句，且使用外部的字段进行过滤操作</li>
<li>DERIVED：在 FROM 列表中保护的子查询被标记为 DERIVED，MySQL 会递归执行这些子查询，把结果放在临时表中</li>
</ul>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表明该查询使用的是哪张表的数据。一般情况下显示表名，有时也显示 &lt;union**M**,**N**&gt;、&lt;derived**N**&gt;、&lt;subquery**N**&gt;。其中 M 和 N 都表示 id 列的数字，表示这是来自于 id  为 M 或 N 的查询结果集。如 &lt;union**M**,**N**&gt; 表示这个查询的数据来自于 id 为 M 和 N 的查询结果的并集，&lt;derived**N**&gt; 表示这个查询的数据来自于 id 为 N 的查询结果集。</p>
<h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>表明该查询语句使用了哪个分区进行查询。如果表没有建立分区，则值是 NULL</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>表示 MySQL 在表中找到所需行的方式，也称 “访问类型”。值有：system、const、eq_ref、ref、fulltext、ref_or_null、index_merge、unique_subquery、index_subquery、range、index、ALL。这些值从左到右的查询性能越来越差。</p>
<p>常见的有以下几种</p>
<ul>
<li>system：表中只有一条数据（基本上是系统表），是 const 的一种特殊类型。</li>
<li>const：只需要通过一次查找就能获取相应的记录（最多只有一行）。一般是根据主键或唯一索引进行的查找。</li>
<li>eq_ref：唯一性索引扫描，每次组合查询时，对该表只查询一次，只有一条记录与之匹配。与 const 的区别是，eq_ref 常出现在多表的关联查询中，而 const 常出现的单表的查询中。</li>
<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行。一般是使用部分索引（最左前缀）进行查找，或者使用非唯一性索引进行匹配返回多行数据。</li>
<li>range：使用索引进行范围匹配返回符合结果的所有行。此时 key 列表明使用了哪个索引进行范围查找。常见的范围查找的运算符有：<code>&lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、is null、between、like、in</code>。与 ref 的区别是，ref 使用的是具体的值进行查找，而 range 使用的范围值进行查找。</li>
<li>index：使用索引进行全表扫描，只扫描索引树。与 range 的区别在于 range 是使用索引进行范围查找（部分查找），index 需要遍历索引树（全部查找）</li>
<li>ALL：没有使用索引进行全表扫描。</li>
</ul>
<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>指出 MySQL 能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>显示 MySQL 实际决定使用的索引，如果没有选择索引，值是 NULL</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示使用的索引的长度，通过这个值可以算出有多少个索引被使用。如果 key 列是 NULL，此列的值也是 NULL</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>表示表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>表示 MySQL 根据表统计信息及索引选用情况，估算的找到所需的记录所需要扫描的行数，这是一个估算值，并不是真正查询时扫描的行数。一般情况下，这个值越小，查询性能越好</p>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>查询的额外信息（也很重要）。常见的有以下几个值，详情请看<a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information">MySQL官方文档</a></p>
<ul>
<li>Using filesort：表示 MySQL 会对数据使用一次外部的排序（没有使用索引树的排序结构，也就是说，要么没有索引，要么索引的顺序和排序的顺序不对）。当出现这个值时，就需要引起注意了，如果数据量大时，查询性能会大大降低，需要调整索引进行优化。</li>
<li>Using temporary：表明查询使用了临时表来存储临时的数据。常见于包含 group by 或 order by 的查询。当出现这个值时，更需要引起注意了，如果数据量大时，查询性能会大大降低，需要调整索引进行优化。</li>
<li>Using index：表明使用了覆盖索引，可以直接从索引树中取出相关的数据，不需要回表扫描。当出现这个值时，一般表明这是一个高效率的查询语句。</li>
<li>Using where：表明使用了 where 进行条件过滤。</li>
<li>Using join buffer(Block Nested Loop)、Using join buffer(Batched Key Access)：表明使用了连接缓存，Block Nested Loop 表明使用 Block Nested-Loop 算法，Batched Key Access 表明使用了 Batched Key Access 算法。</li>
</ul>
<h2 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h2><ul>
<li>在环境上单独运行 sql，看是否真的“慢”，排除其他因素（CPU、IO等）的影响。</li>
<li>执行 explain 查看执行计划，重点关注 type、key、rows、Extra 几个字段的值，看是否使用了索引，以及是否选择了正确的索引执行该查询语句。</li>
<li>参考<a href="#%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">建索引的几个注意事项</a>，新建或调整索引。</li>
<li>重新运行 sql 语句观察执行结果，不符合预期则重复执行以上操作。</li>
</ul>
<h2 id="建索引的几个注意事项"><a href="#建索引的几个注意事项" class="headerlink" title="建索引的几个注意事项"></a>建索引的几个注意事项</h2><ul>
<li><p>时刻铭记并用好最左前缀匹配原则，去除多余的索引。比如同一个表有两个索引：a 和 (a,b)，则根据最左前缀匹配原则，当单独使用 a 列进行查找时，是能够用上 (a,b) 这个复合索引，此时 a 的索引就没有存在的必要，可以删除，这样也能减少维护索引的成本。</p>
<p>最左前缀匹配原则：MySQL 会一直对索引列进行向右精确查找，直到遇到了范围查找后，范围查找列之后的索引列将无法使用。比如：有索引（a,b,c），如果使用条件 a &#x3D; 1 and b &gt; 2 and c &#x3D; 3，则只能使用 a、b两个索引列，c 这一列是无法使用索引的。</p>
</li>
<li><p><code>%like%</code> 和 <code>%like</code> 无法使用索引，<code>like%</code> 可以使用索引（相当于范围查找）。</p>
<p>如果一定要使用 <code>%like%</code>，并且要使用索引，可以使用覆盖索引避免其发生全表扫描。如下图所示，对 <code>col_2</code> 进行 <code>like %a%</code> 查找，没有使用覆盖索引时，走全表扫描，使用覆盖索引查询后，用上了索引。</p>
<p><img src="/images/mysql-index-3.png" alt="mysql index like"></p>
<p><img src="/images/mysql-index-4.png" alt="mysql index like"></p>
<p><img src="/images/mysql-index-5.png" alt="mysql index like"></p>
</li>
<li><p>不要对索引列进行运算或隐式转换，否则索引失效无法使用，从而导致全表扫描。如存在索引 a，如果使用 <code>select * from tableName where concat(a, &#39;b&#39;) = &#39;ab&#39;</code>，则 a 列上的索引无法使用。如果 a 字段是纯数字的字符型，则使用  <code>select * from tableName where a = 5</code> 会导致 a 字段隐式转换，也无法使用索引。</p>
<p><img src="/images/mysql-index-9.png" alt="mysql index implict cast"></p>
</li>
<li><p>对于 <code>in</code> 条件查询，如果 <code>or</code> 连接的列上都有索引，则可以用上索引，否则只有其中部分列有索引的话，会导致索引失效。如果 <code>or</code> 连接的条件列只有一部分有索引，但是又想使用索引，可以使用 <code>union all</code> 代替 <code>or</code> 的写法。</p>
<p><img src="/images/mysql-index-10.png" alt="mysql index implict cast"></p>
<p><img src="/images/mysql-index-11.png" alt="mysql index implict cast"></p>
</li>
<li><p>选择区分度大的列建立索引。如果列的值区分度不大，则使用索引过滤掉的记录很少，效果也不大。</p>
</li>
<li><p>查询中经常使用到的字段以及与其他表进行关联的字段，考虑建立索引。</p>
</li>
<li><p>对 order by 和 group by（隐藏操作：分组前必排序） 中的字段，考虑建立索引，避免发生 <code>Using filesort</code>、<code>Using temporary</code> 操作。同时需要注意排序和查询使用相同的索引（包括排序列的升序或降序，要么全使用升序，要么全使用降序，不能部分使用升序部分使用降序），否则也容易产生  <code>Using filesort</code>。对于复合索引的情况，允许部分前缀以常量的方式出现在 where 条件中同时 order by不用以该列作为第一个排序字段。如下图所示</p>
<p><img src="/images/mysql-index-6.png" alt="mysql index order by"></p>
<p><img src="/images/mysql-index-7.png" alt="mysql index order by"></p>
<p><img src="/images/mysql-index-8.png" alt="mysql index order by"></p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>MySQL官方文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/">https://dev.mysql.com/doc/refman/8.0/en/</a></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/red-black-tree/</url>
    <content><![CDATA[<h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><ul>
<li>所有的节点必须是红节点或黑节点</li>
<li>根节点是黑色</li>
<li>每个空叶子节点（不同于二叉搜索树，红黑树的叶子节点均为空，即只有黑颜色属性，无其他属性）为黑色</li>
<li>红节点的子节点为黑色（即：不能连续两个父子节点均为红节点）</li>
<li>从任意节点到其叶子节点经过的路径的黑节点数相同，即拥有相同的黑路径</li>
</ul>
<span id="more"></span>

<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>首先根据二叉搜索树的插入方式找到要插入的位置，然后将新插入的节点标为红色。此处约定：要插入的节点为N，N的父节点为P，N的祖父节点（即P的父节点）为G，N的叔父节点（即P的兄弟节点）为U。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start=&gt;start: Start</span><br><span class="line">hasFather=&gt;condition: 有无父节点P</span><br><span class="line">isFatherNodeColorRed=&gt;condition: 父节点P为红色</span><br><span class="line">isUncleNodeColorBlack=&gt;condition: 叔父节点U为黑色</span><br><span class="line">isNewNodeInside=&gt;condition: 节点N是否在树的内侧</span><br><span class="line">						  （G[左] - &gt; P[右] - &gt; N</span><br><span class="line">						  或G[右] - &gt; P[左] - &gt; N）</span><br><span class="line">handleCase4_1=&gt;operation: 对P进行左旋转或右旋转</span><br><span class="line">						左旋：G[左] - &gt; P[右] - &gt; N</span><br><span class="line">						右旋：G[右] - &gt; P[左] - &gt; N</span><br><span class="line">						旋转完后，P在树的外侧，即</span><br><span class="line">						G[左] - &gt; N[左] - &gt; P</span><br><span class="line">						或G[右] - &gt; N[右] - &gt; P</span><br><span class="line">						将P当成N，N当成P</span><br><span class="line">handleCase4_2=&gt;operation: 对G进行左旋转或右旋转</span><br><span class="line">						右旋：G[左] - &gt; P[左] - &gt; N</span><br><span class="line">						左旋：G[右] - &gt; P[右] - &gt; N</span><br><span class="line">						将父节点、祖父节点颜色反转</span><br><span class="line">						（即P改为黑色，G改为红色）</span><br><span class="line">handleCase3=&gt;operation: 将父节点、叔父节点、祖父节</span><br><span class="line">					  点颜色反转（即P改为黑色，</span><br><span class="line">					  U改成黑色，G改为红色）</span><br><span class="line">					  将G当成新插入的节点N</span><br><span class="line">handleCase1=&gt;operation: 将节点N颜色变为黑色</span><br><span class="line">handleCase2=&gt;operation: 直接插入不用其他处理</span><br><span class="line">end=&gt;end: End</span><br><span class="line"></span><br><span class="line">start-&gt;hasFather</span><br><span class="line">hasFather(yes)-&gt;isFatherNodeColorRed</span><br><span class="line">isFatherNodeColorRed(yes)-&gt;isUncleNodeColorBlack</span><br><span class="line">isUncleNodeColorBlack(no)-&gt;handleCase3-&gt;hasFather</span><br><span class="line">isUncleNodeColorBlack(yes)-&gt;isNewNodeInside</span><br><span class="line">isNewNodeInside(yes)-&gt;handleCase4_1-&gt;handleCase4_2-&gt;end</span><br><span class="line">isNewNodeInside(no)-&gt;handleCase4_2</span><br><span class="line">hasFather(no)-&gt;handleCase1-&gt;end</span><br><span class="line">isFatherNodeColorRed(no)-&gt;handleCase2-&gt;end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>类似二叉搜索树，先找到要删除的数所在的节点V，对以这个节点为根节点的左子树进行搜索找到左子树的最大值所在的节点N（此处均以N在V的左子树进行讨论），将N节点的值覆盖到V节点上，然后将N节点进行删除。根据二叉搜索树的定义，可知，N节点最多有一个非叶子节点，对于搜索二叉树而言，直接删除N节点，将N节点的父节点P指向N节点即可。对于红黑树而言，除了执行跟搜索二叉树一样的操作外，还需要进行额外的调整使得整颗树仍然符合红黑树的特征，以下是进行调整的过程，约定如下：</p>
<ul>
<li>N：要删除的节点</li>
<li>C：要删除的节点的子节点（排除另一个必为叶子的子节点，此子节点可能为叶子节点也可能非叶子节点）</li>
<li>P：要删除的节点的父节点</li>
<li>S：要删除的节点的兄弟节点</li>
<li>SL：要删除的节点的兄弟节点的左节点</li>
<li>SR：要删除的节点的兄弟节点的右节点</li>
<li>每一轮循环都根据N重新计算C、P、S、SL、SR节点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start=&gt;start: Start</span><br><span class="line">isNodeBlack=&gt;condition: N为黑色</span><br><span class="line">isChildBlack=&gt;condition: C为黑色</span><br><span class="line">isChildLeaf=&gt;condition: C为叶子节点</span><br><span class="line">handleCase1=&gt;operation: C颜色改为黑色</span><br><span class="line">isNodeNotRoot=&gt;condition: N非根节点</span><br><span class="line">isSiblingNodeBlack=&gt;condition: S节点为黑色</span><br><span class="line">handleCase2=&gt;operation: 反转P和S的颜色</span><br><span class="line">					  （P为红，S为黑）,</span><br><span class="line">					  左旋或右旋P</span><br><span class="line">isSRNodeBlack=&gt;condition: SR为黑色</span><br><span class="line">handleCase3=&gt;operation: 将P和S颜色对换，</span><br><span class="line">					  SR设为黑色，旋转</span><br><span class="line">					  P让S成为P的父节点</span><br><span class="line">isSLNodeBlack=&gt;condition: SL为黑色</span><br><span class="line">handleCase4=&gt;operation: 旋转S让SL成为S的父节点</span><br><span class="line">isParentNodeRed=&gt;condition: P节点为红色</span><br><span class="line">handleCase5=&gt;operation: P改成黑色，</span><br><span class="line">					  S改成红色</span><br><span class="line">handleCase6=&gt;operation: S改成红色，</span><br><span class="line">				       将P当成N</span><br><span class="line">				       （P = N）</span><br><span class="line">end=&gt;end: End</span><br><span class="line">end1=&gt;end: End</span><br><span class="line">end2=&gt;end: End</span><br><span class="line"></span><br><span class="line">start-&gt;isNodeBlack</span><br><span class="line">isNodeBlack(no)-&gt;end1</span><br><span class="line">isNodeBlack(yes)-&gt;isChildLeaf</span><br><span class="line">isChildLeaf(no)-&gt;handleCase1-&gt;end</span><br><span class="line">isChildLeaf(yes)-&gt;isNodeNotRoot</span><br><span class="line">isNodeNotRoot(yes)-&gt;isSiblingNodeBlack</span><br><span class="line">isNodeNotRoot(no)-&gt;end2</span><br><span class="line">isSiblingNodeBlack(no)-&gt;handleCase2-&gt;isNodeNotRoot</span><br><span class="line">isSiblingNodeBlack(yes)-&gt;isSRNodeBlack</span><br><span class="line">isSRNodeBlack(no)-&gt;handleCase3-&gt;end</span><br><span class="line">isSRNodeBlack(yes)-&gt;isSLNodeBlack</span><br><span class="line">isSLNodeBlack(no)-&gt;handleCase4-&gt;isNodeNotRoot</span><br><span class="line">isSLNodeBlack(yes)-&gt;isParentNodeRed</span><br><span class="line">isParentNodeRed(yes)-&gt;handleCase5-&gt;end</span><br><span class="line">isParentNodeRed(no)-&gt;handleCase6-&gt;isNodeNotRoot</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/qingergege/p/7351659.html">https://www.cnblogs.com/qingergege/p/7351659.html</a></p>
<p><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">https://en.wikipedia.org/wiki/Red–black_tree</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射基本用法</title>
    <url>/reflection-basic-usage/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java反射允许程序在运行时获取类的相关信息并动态的调用类实例的函数（包括私有函数），设置成员变量的值等。java反射在很多地方都有应用，例如，通过配置项调用对应的类中的函数。在写单元测试时，有时需要对私有方法进行单独的测试，此时也可以使用反射调用私有的方法。</p>
<span id="more"></span>

<h1 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h1><p>通过反射获取类对象主要有三种方式</p>
<ul>
<li>通过实例：instance.getClass()，此种方式需要有一个类实例。如<code>person.getClass()</code>，其中person是Person的实例</li>
<li>通过类名：className.class，此种方式需要导入类。如：<code>Person.class</code></li>
<li>通过类全路径名：Class.forName(classFullPathName)，此种方式需要写类的全路径名（包含包路径）。如<code>Class.forName(&quot;reflect.Person&quot;)</code></li>
</ul>
<h1 id="获取构造函数"><a href="#获取构造函数" class="headerlink" title="获取构造函数"></a>获取构造函数</h1><ul>
<li>使用getConstructors()获取所有的public构造函数</li>
<li>使用getDeclaredConstructors()获取所有的private、protected、public构造函数</li>
<li>使用getConstructors(obj.class…)获取特定的public构造函数</li>
<li>使用getDeclaredConstructors(obj.class…)获取特定的private、protected、public方法</li>
<li>通过constructors.newInstance可以创建类实例</li>
<li>访问private和protected构造函数需要设置<code>accessible</code>值为true，如<code>constructor2.setAccessible(true)</code></li>
</ul>
<h1 id="获取成员函数"><a href="#获取成员函数" class="headerlink" title="获取成员函数"></a>获取成员函数</h1><ul>
<li>使用getMethods()获取所有的public方法，包括从父类继承过来的方法</li>
<li>使用getDeclaredMethods()获取本类所有的private、protected、public方法，不包含从父类继承过来的方法</li>
<li>使用getMethod(name, obj.class…)获取特定public方法</li>
<li>使用getDeclaredMethod(name, obj.class…)获取特定的private、protected、public方法</li>
<li>调用方法用method.invoke(instance, param…)，可以有返回值，是Object对象，如果需要指定类型要进行转换</li>
<li>访问private和protected方法需要设置<code>accessible</code>值为true，如<code>method2.setAccessible(true)</code></li>
</ul>
<h1 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h1><ul>
<li>使用getFields()获取所有public变量</li>
<li>使用getDeclaredFields()获取所有private、protected、public变量</li>
<li>使用getField(fieldName)获取特定的public变量</li>
<li>使用getDeclaredField(fieldName)获取特定的private、protected、public变量</li>
<li>设置成员变量用field.set(instance, value)</li>
<li>访问private和protected方法需要设置<code>accessible</code>值为true，如<code>field2.setAccessible(true)</code></li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><h2 id="基础类"><a href="#基础类" class="headerlink" title="基础类"></a>基础类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;String&gt; aliasNames;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call constructor: private Person()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Person</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;call constructor: protected Person(String name)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, List&lt;String&gt; aliasNames)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.aliasNames = aliasNames;</span><br><span class="line">        System.out.println(<span class="string">&quot;call constructor: public Person(int age, List&lt;String&gt; aliasNames)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call method: private int getAge()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">addAliasName</span><span class="params">(String aliasName)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call method: protected List&lt;String&gt; addAliasName(String aliasName)&quot;</span>);</span><br><span class="line">        aliasNames.add(aliasName);</span><br><span class="line">        <span class="keyword">return</span> aliasNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call method: public void setName(String name)&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, aliasNames=&quot;</span> + aliasNames + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 三种方式获取类</span></span><br><span class="line">        <span class="comment">// 1. 通过实例：instance.getClass()，此种方式需要有一个类实例</span></span><br><span class="line">        <span class="comment">// 2. 通过类名：Class.class，此种方式需要导入类</span></span><br><span class="line">        <span class="comment">// 3. 通过类全路径名：Class.forName()，此种方式需要写类的全路径名（包含包路径）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;======获取类======&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; personClass1 = person.getClass();</span><br><span class="line">        Class&lt;?&gt; personClass2 = Person.class;</span><br><span class="line">        Class&lt;?&gt; personClass3 = Class.forName(<span class="string">&quot;reflect.Person&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;person.getClass() == Person.class? &quot;</span> + (personClass1 == personClass2));</span><br><span class="line">        System.out.println(<span class="string">&quot;Person.class == Class.forName(\&quot;Person\&quot;)? &quot;</span> + (personClass2 == personClass3));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用getConstructors()获取所有的public构造函数</span></span><br><span class="line">        <span class="comment">// 使用getDeclaredConstructors()获取所有的private、protected、public构造函数</span></span><br><span class="line">        <span class="comment">// 使用getConstructors(obj.class...)获取特定的public构造函数，通过newInstance可以创建实例</span></span><br><span class="line">        <span class="comment">// 使用getDeclaredConstructors(obj.class...)获取特定的private、protected、public构造函数，通过newInstance可以创建实例</span></span><br><span class="line">        System.out.println(<span class="string">&quot;======获取构造函数======&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------1. 使用getConstructors()获取所有的public构造函数------&quot;</span>);</span><br><span class="line">        Constructor[] allPublicContructors = personClass3.getConstructors();</span><br><span class="line">        Arrays.stream(allPublicContructors).forEach(c -&gt; System.out.println(c));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;------2. 使用getDeclaredConstructors()获取所有的private、protected、public构造函数------&quot;</span>);</span><br><span class="line">        Constructor[] allDeclareContructorss = personClass3.getDeclaredConstructors();</span><br><span class="line">        Arrays.stream(allDeclareContructorss).forEach(c -&gt; System.out.println(c));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;------3. 使用getConstructors(obj.class...)获取特定的public构造函数，并调用------&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> personClass3.getConstructor(<span class="type">int</span>.class, List.class);</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">        List&lt;String&gt; aliasNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        aliasNames.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> (Person)constructor.newInstance(<span class="number">9</span>, aliasNames);</span><br><span class="line">        System.out.println(person2);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;------4. 使用getDeclaredConstructors(obj.class...)获取特定的private、protected、public构造函数,并调用------&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor2</span> <span class="operator">=</span> personClass3.getDeclaredConstructor();  <span class="comment">// 获取无参构造函数时，可以不用传参数</span></span><br><span class="line">        constructor2.setAccessible(<span class="literal">true</span>);  <span class="comment">// 访问private和protected构造函数需要设置为true</span></span><br><span class="line">        System.out.println(constructor2);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">person3</span> <span class="operator">=</span> constructor2.newInstance();</span><br><span class="line">        System.out.println(person3);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用getMethods()获取所有的public方法，包括从父类继承过来的方法</span></span><br><span class="line">        <span class="comment">// 使用getDeclaredMethods()获取本类所有的private、protected、public方法，不包含从父类继承过来的方法</span></span><br><span class="line">        <span class="comment">// 使用getMethod(name, obj.class...)获取特定public方法</span></span><br><span class="line">        <span class="comment">// 使用getDeclaredMethod(name, obj.class...)获取特定的private、protected、public方法</span></span><br><span class="line">        <span class="comment">// 调用方法用method.invoke(instance, param...)，可以有返回值，是Object对象，如果需要指定类型要进行转换</span></span><br><span class="line">        System.out.println(<span class="string">&quot;======获取方法======&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------1. 使用getMethods()获取所有的public方法，包括从父类继承过来的方法------&quot;</span>);</span><br><span class="line">        Method[] allPublicMethods = personClass2.getMethods();</span><br><span class="line">        Arrays.stream(allPublicMethods).forEach(x -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;------2. 使用getDeclaredMethods()获取本类所有的private、protected、public方法，不包含从父类继承过来的方法------&quot;</span>);</span><br><span class="line">        Method[] allDeclaredMethods = personClass2.getDeclaredMethods();</span><br><span class="line">        Arrays.stream(allDeclaredMethods).forEach(x -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;------3. 使用getMethod(name, obj.class...)获取特定public方法，并使用------&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> personClass2.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        System.out.println(method);</span><br><span class="line">        System.out.println(<span class="string">&quot;before change name: &quot;</span> + person);</span><br><span class="line">        method.invoke(person, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;after change name: &quot;</span> + person);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;------4. 使用getDeclaredMethod(name, obj.class...)获取特定的private、protected、public方法，并使用-----&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span> personClass2.getDeclaredMethod(<span class="string">&quot;addAliasName&quot;</span>, String.class);</span><br><span class="line">        method2.setAccessible(<span class="literal">true</span>);  <span class="comment">// 访问private和protected方法需要设置为true</span></span><br><span class="line">        System.out.println(method2);</span><br><span class="line">        System.out.println(<span class="string">&quot;before add alias name: &quot;</span> + person2);</span><br><span class="line">        List&lt;String&gt; retVal = (List&lt;String&gt;)method2.invoke(person2, <span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;after add alias name: &quot;</span> + person2);</span><br><span class="line">        System.out.println(<span class="string">&quot;the return value is &quot;</span> + retVal);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用getFields()获取所有public变量</span></span><br><span class="line">        <span class="comment">// 使用getDeclaredFields()获取所有private、protected、public变量</span></span><br><span class="line">        <span class="comment">// 使用getField(fieldName)获取特定的public变量</span></span><br><span class="line">        <span class="comment">// 使用getDeclaredField(fieldName)获取特定的private、protected、public变量</span></span><br><span class="line">        <span class="comment">// 设置成员变量用field.set(instance, value)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;======获取变量======&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------1. 使用getFields()获取所有public变量------&quot;</span>);</span><br><span class="line">        Field[] allPublicFields = personClass1.getFields();</span><br><span class="line">        Arrays.stream(allPublicFields).forEach(x -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;------2. 使用getDeclaredFields()获取所有private、protected、public变量------&quot;</span>);</span><br><span class="line">        Field[] allDeclaredFields = personClass1.getDeclaredFields();</span><br><span class="line">        Arrays.stream(allDeclaredFields).forEach(x -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;------3. 使用getField(fieldName)获取特定的public变量，并设置值------&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> personClass1.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(field);</span><br><span class="line">        System.out.println(<span class="string">&quot;before change age: &quot;</span> + person);</span><br><span class="line">        field.set(person, <span class="number">99</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;after change age: &quot;</span> + person);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;------4. 使用getDeclaredField(fieldName)获取特定的private、protected、public变量，并设置值------&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> personClass1.getDeclaredField(<span class="string">&quot;aliasNames&quot;</span>);</span><br><span class="line">        field2.setAccessible(<span class="literal">true</span>);  <span class="comment">// 访问private和protected成员变量需要设置为true</span></span><br><span class="line">        System.out.println(field2);</span><br><span class="line">        System.out.println(<span class="string">&quot;before change alaisNames: &quot;</span> + person2);</span><br><span class="line">        List&lt;String&gt; newVal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        newVal.add(<span class="string">&quot;ppp&quot;</span>);</span><br><span class="line">        field2.set(person2, newVal);</span><br><span class="line">        System.out.println(<span class="string">&quot;after change alaisNames: &quot;</span> + person2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">======获取类======</span><br><span class="line">call constructor: protected Person(String name)</span><br><span class="line">person.getClass() == Person.class? true</span><br><span class="line">Person.class == Class.forName(&quot;Person&quot;)? true</span><br><span class="line">======获取构造函数======</span><br><span class="line">------1. 使用getConstructors()获取所有的public构造函数------</span><br><span class="line">public reflect.Person(int,java.util.List)</span><br><span class="line">------2. 使用getDeclaredConstructors()获取所有的private、protected、public构造函数------</span><br><span class="line">public reflect.Person(int,java.util.List)</span><br><span class="line">protected reflect.Person(java.lang.String)</span><br><span class="line">private reflect.Person()</span><br><span class="line">------3. 使用getConstructors(obj.class...)获取特定的public构造函数，并调用------</span><br><span class="line">public reflect.Person(int,java.util.List)</span><br><span class="line">call constructor: public Person(int age, List&lt;String&gt; aliasNames)</span><br><span class="line">Person [name=null, age=9, aliasNames=[bbb]]</span><br><span class="line">------4. 使用getDeclaredConstructors(obj.class...)获取特定的private、protected、public构造函数,并调用------</span><br><span class="line">private reflect.Person()</span><br><span class="line">call constructor: private Person()</span><br><span class="line">Person [name=null, age=0, aliasNames=null]</span><br><span class="line">======获取方法======</span><br><span class="line">------1. 使用getMethods()获取所有的public方法，包括从父类继承过来的方法------</span><br><span class="line">public java.lang.String reflect.Person.toString()</span><br><span class="line">public void reflect.Person.setName(java.lang.String)</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">------2. 使用getDeclaredMethods()获取本类所有的private、protected、public方法，不包含从父类继承过来的方法------</span><br><span class="line">public java.lang.String reflect.Person.toString()</span><br><span class="line">public void reflect.Person.setName(java.lang.String)</span><br><span class="line">protected java.util.List reflect.Person.addAliasName(java.lang.String)</span><br><span class="line">private int reflect.Person.getAge()</span><br><span class="line">------3. 使用getMethod(name, obj.class...)获取特定public方法，并使用------</span><br><span class="line">public void reflect.Person.setName(java.lang.String)</span><br><span class="line">before change name: Person [name=aaa, age=0, aliasNames=null]</span><br><span class="line">call method: public void setName(String name)</span><br><span class="line">after change name: Person [name=ccc, age=0, aliasNames=null]</span><br><span class="line">------4. 使用getDeclaredMethod(name, obj.class...)获取特定的private、protected、public方法，并使用-----</span><br><span class="line">protected java.util.List reflect.Person.addAliasName(java.lang.String)</span><br><span class="line">before add alias name: Person [name=null, age=9, aliasNames=[bbb]]</span><br><span class="line">call method: protected List&lt;String&gt; addAliasName(String aliasName)</span><br><span class="line">after add alias name: Person [name=null, age=9, aliasNames=[bbb, ddd]]</span><br><span class="line">the return value is [bbb, ddd]</span><br><span class="line">======获取变量======</span><br><span class="line">------1. 使用getFields()获取所有public变量------</span><br><span class="line">public int reflect.Person.age</span><br><span class="line">------2. 使用getDeclaredFields()获取所有private、protected、public变量------</span><br><span class="line">private java.lang.String reflect.Person.name</span><br><span class="line">public int reflect.Person.age</span><br><span class="line">protected java.util.List reflect.Person.aliasNames</span><br><span class="line">------3. 使用getField(fieldName)获取特定的public变量，并设置值------</span><br><span class="line">public int reflect.Person.age</span><br><span class="line">before change age: Person [name=ccc, age=0, aliasNames=null]</span><br><span class="line">after change age: Person [name=ccc, age=99, aliasNames=null]</span><br><span class="line">------4. 使用getDeclaredField(fieldName)获取特定的private、protected、public变量，并设置值------</span><br><span class="line">protected java.util.List reflect.Person.aliasNames</span><br><span class="line">before change alaisNames: Person [name=null, age=9, aliasNames=[bbb, ddd]]</span><br><span class="line">after change alaisNames: Person [name=null, age=9, aliasNames=[ppp]]</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078">https://blog.csdn.net/sinat_38259539&#x2F;article&#x2F;details&#x2F;71799078</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀表达式</title>
    <url>/rpn/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>后缀表达式也叫逆波兰表达式，主要是用来进行表达式运算的。数学中对表达式进行求解，都是使用中缀表达式，如：<code>2 * (3 + 4) - 5</code> 这易于人们理解，但是不易于程序编写。在编写程序进行表达式求解时，一般都是先将表达式由中缀表达式转成后缀表达式，再结合栈进行求解。因为后缀表达式可以直接取出括号而对结果没有影响。例如：中缀表达式 <code>2 * (3 + 4) - 5</code> ，其对应的后缀表达式为 <code>2 ( 3 4 + ) * 5 -</code>，可以简写为 <code>2 3 4 + * 5 -</code></p>
<span id="more"></span>

<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>将中缀表达式转成后缀表达式的算法如下：</p>
<ul>
<li><p>用一个栈来存储操作运算符：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>(</code></p>
</li>
<li><p>遍历中缀表达式字符串，针对每个元素（数字、小括号或运算符，这里数字可以是多位数字），进行以下操作</p>
<ul>
<li>如果是数字，直接输出</li>
<li>如果是括号或运算符<ul>
<li>如果栈为空，直接进栈</li>
<li>如果栈不为空，获取栈顶元素与当前元素判断<ul>
<li>如果当前元素是 <code>(</code> 或者当前元素的优先级大于栈顶元素的优先级，则将当前元素进栈</li>
<li>如果当前元素是 <code>)</code>，则从栈中循环取出栈顶元素输出，直到遇到 <code>(</code>，将 <code>(</code> 弹出（不输出）</li>
<li>如果当前元素优先级不大于栈顶元素优先级，则从栈中循环取出栈顶元素输出，直到栈顶元素优先级小于当前元素或栈为空（定义左小括号的优先级最低），然后将当前元素入栈</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>待遍历结束后，判断栈中元素是否为空，如果非空，则将栈中元素依次弹出输出</p>
</li>
</ul>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>一个简单的例子代码如下，假设输入的表达式是合法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRpn</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序表达式转后序表达式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exp 中序表达式，只包含数字，+，-，*，/，(，)，且保证表达式合法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后序表达式元素列表，每个元素按顺序组合就能形成后序表达式字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">convertInOrder2PostOrder</span><span class="params">(String exp)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Stack&lt;Character&gt; opStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isAddNum</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNegative</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; exp.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> exp.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(ch))</span><br><span class="line">            &#123;</span><br><span class="line">                isAddNum = <span class="literal">true</span>;</span><br><span class="line">                num = num * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isAddNum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNegative)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.add(String.valueOf(-num));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    result.add(String.valueOf(num));</span><br><span class="line">                &#125;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                isAddNum = <span class="literal">false</span>;</span><br><span class="line">                isNegative = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                opStack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (!opStack.isEmpty() &amp;&amp; opStack.peek() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.add(String.valueOf(opStack.pop()));</span><br><span class="line">                &#125;</span><br><span class="line">                opStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || (!Character.isDigit(exp.charAt(i - <span class="number">1</span>)) &amp;&amp; exp.charAt(i - <span class="number">1</span>) != <span class="string">&#x27;)&#x27;</span>)))</span><br><span class="line">                &#123;</span><br><span class="line">                    isNegative = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!opStack.isEmpty() &amp;&amp; !isHigh(ch, opStack.peek()))</span><br><span class="line">                &#123;</span><br><span class="line">                    result.add(String.valueOf(opStack.pop()));</span><br><span class="line">                &#125;</span><br><span class="line">                opStack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isAddNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isNegative)</span><br><span class="line">            &#123;</span><br><span class="line">                result.add(String.valueOf(-num));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result.add(String.valueOf(num));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!opStack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(String.valueOf(opStack.pop()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断第一个操作符的优先级是否高于第二个操作符</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstOp  第一个操作符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secondOp 第二个操作符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true，第一个操作符优先级高于第二个操作符，false：第一个操作符优先级小于等于第二个操作符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isHigh</span><span class="params">(<span class="type">char</span> firstOp, <span class="type">char</span> secondOp)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (secondOp == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (firstOp == <span class="string">&#x27;*&#x27;</span> || firstOp == <span class="string">&#x27;/&#x27;</span>) &amp;&amp; (secondOp == <span class="string">&#x27;+&#x27;</span> || secondOp == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="string">&quot;32*9/3+(233-31)*8&quot;</span>;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">TestRpn</span>().convertInOrder2PostOrder(exp));</span><br><span class="line">        <span class="comment">// 输出如下</span></span><br><span class="line">        <span class="comment">// [32, 9, *, 3, /, 233, 31, -, 8, *, +]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构与算法</tag>
        <tag>后缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈线程池</title>
    <url>/thread-pool/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>多线程是 java 并发编程中的一个重要特性，最简单的用法是在需要使用多线程的地方 new 一个新的线程让其异步运行。但是，线程的创建是一个比较大的开销，如果有多个任务需要频繁间歇地异步执行，为每个任务单独创建一个线程就显得有点浪费。因此，可以考虑使用线程池的做法，在线程池中保持一定数量的线程，当有任务需要异步执行时，直接让线程池中的空闲线程获取该任务进行执行。这样就能避免每次创建线程的开销。</p>
<span id="more"></span>

<h1 id="线程池的基本概念"><a href="#线程池的基本概念" class="headerlink" title="线程池的基本概念"></a>线程池的基本概念</h1><p>当创建一个线程池的时候，需要传入以下参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> corePoolSize                  <span class="comment">// 核心线程数量，即线程池中所有线程都空闲时，允许存活的线程数量（allowCoreThreadTimeOut 为 true 时，存活线程数量允许为 0）</span></span><br><span class="line"><span class="type">int</span> maximumPoolSize               <span class="comment">// 线程池中线程的最大数量，超过这个数量时，线程池不会再接受新的任务</span></span><br><span class="line"><span class="type">long</span> keepAliveTime                <span class="comment">// 线程空闲时，允许存活的时间</span></span><br><span class="line">TimeUnit unit                     <span class="comment">// 线程空闲时，允许存活的时间的时间单位</span></span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue <span class="comment">// 工作队列（也称阻塞队列），当提交的任务数量多于核心线程数量时，会将新提交的任务放入此队列中</span></span><br><span class="line">ThreadFactory threadFactory       <span class="comment">// 创建线程的工厂</span></span><br><span class="line">RejectedExecutionHandler handler  <span class="comment">// 线程池拒绝接受新任务的处理器</span></span><br></pre></td></tr></table></figure>

<h1 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h1><p>一般情况下，我们使用 <code>Executors</code> 类中的工厂类创建所需要的线程池，常用的两种线程池是 <code>Executors.newCachedThreadPool()</code> 、<code>Executors.newFixedThreadPool()</code>，其构造函数如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newCachedThreadPool 使用的是 SynchronousQueue 工作队列</span></span><br><span class="line"><span class="comment">// 当提交一个任务时，如果线程池中刚好有一个线程处理完其他的任务空闲下来，就将任务交给这个线程进行处理</span></span><br><span class="line"><span class="comment">// 否则，创建一个新的线程处理该任务</span></span><br><span class="line"><span class="comment">// 由于 corePoolSize 为 0，所以当线程空闲一段时间后，会被销毁</span></span><br><span class="line"><span class="comment">// 由于 maximumPoolSize 为 Integer.MAX_VALUE，因此当任务很多时，也能创建相应的线程及时地处理任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newFixedThreadPool 会设置 corePoolSize 和 maximumPoolSize 相等，从而保证固定的线程数</span></span><br><span class="line"><span class="comment">// 同时传入的是一个无边界的阻塞队列，最大限度下保证所有任务都能被处理（任务过多时，内存耗尽溢出）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h1><p>线程池中定义了 5 个状态：<code>RUNNING</code>、<code>SHUTDOWN</code>、<code>STOP</code>、<code>TIDYING</code>、<code>TERMINATED</code>。</p>
<p><code>RUNNING</code>：表示线程池处于运行状态</p>
<p><code>SHUTDOWN</code>：表示线程池处于关闭状态，可调用 <code>shutdown</code> 函数将线程池的状态由 <code>RUNNING</code> 变成此状态。当线程池处于此状态下时，线程池不再接受新的任务，但是对于已经提交的任务和正在运行的任务，会继续执行。</p>
<p><code>STOP</code>：表示线程池处于停止状态，可调用 <code>shutdownNow</code> 函数将线程池的状态由 <code>RUNNING</code> 或 <code>SHUTDOWN</code> 变成此状态。当线程处于此状态时，线程池不在接受新的任务，同时会中断正在执行的任务，而对于工作队列中等待执行的任务，将不再调用执行。</p>
<p><code>TIDYING</code>：表示线程池处于「纯净待结束」状态。此状态可由 <code>SHUTDOWN</code> 状态或 <code>STOP</code> 状态转换而来。对于状态 <code>SHUTDOWN</code>，如果其工作队列中没有等待的线程，同时没有线程在运行时，将其状态变为 <code>TIDYING</code>。对于状态 <code>STOP</code>，当线程池中没有线程在运行时，将其状态转变为 <code>TIDYING</code>。当线程池转换此状态时，会调用可扩展的<code>terminated</code> 函数。</p>
<p><code>TERMINATED</code>：表示线程池处于结束状态。此状态由 <code>TIDYING</code> 转换而来。当执行完 <code>terminated</code> 后线程池变为此状态。</p>
<p>其各个状态之间的转换关系大致如下图所示</p>
<p><img src="/images/thread-pool-state.png" alt="线程池状态转换图"></p>
<h1 id="线程池的运行过程"><a href="#线程池的运行过程" class="headerlink" title="线程池的运行过程"></a>线程池的运行过程</h1><p>当我们执行 <code>execute.submit(task)</code>向线程池中提交任务时，其会先判断当前运行线程是否小于核心线程数量，如果是，则新建一个线程运行，否则判断任务是否能放入工作队列（阻塞队列）中，如果可以，则放入阻塞队列中等待调度执行，否则继续判断当前运行线程数量是否大于最大线程数量，如果小于则新建线程运行任务，否则执行拒绝策略。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>提交任务后线程池的处理过程，大致流程图如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start=&gt;start: start</span><br><span class="line">submit=&gt;operation: 提交一个任务</span><br><span class="line">lessThanCoreSize=&gt;condition: 运行的线程数量</span><br><span class="line">							 小于 corePoolSize</span><br><span class="line">newThread=&gt;operation: 新建一个线程运行任务</span><br><span class="line">isQueueFull=&gt;condition: 阻塞队列是否已满</span><br><span class="line">waitRun=&gt;operation: 等待调度执行</span><br><span class="line">lessThanMaxSize=&gt;condition: 运行的线程数量小于 </span><br><span class="line">							maximumPoolSize</span><br><span class="line">executeRejection=&gt;operation: 执行拒绝策略</span><br><span class="line">end=&gt;end: end</span><br><span class="line">start-&gt;submit-&gt;lessThanCoreSize(no)-&gt;isQueueFull(yes)-&gt;lessThanMaxSize(no)-&gt;executeRejection-&gt;end</span><br><span class="line">lessThanCoreSize(yes, right)-&gt;newThread-&gt;end</span><br><span class="line">isQueueFull(no, right)-&gt;waitRun-&gt;end</span><br><span class="line">lessThanMaxSize(yes)-&gt;newThread-&gt;end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="部分源码解析"><a href="#部分源码解析" class="headerlink" title="部分源码解析"></a>部分源码解析</h2><p>当执行 <code>submit</code> 函数时，会调用 <code>execute</code> 函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>execute</code> 函数中，会依次对线程数量是否小于核心线程数量、是否能加入阻塞队列、线程数量是否小于最大线程数量进行判断。当线程数量小于核心线程数量时，会新建一个线程运行当前任务，否则加入阻塞队列，当加入阻塞队列失败时，会判断线程数量是否小于最大线程数量，如果小于则新建线程运行当前任务，否则执行拒绝策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ctl 变量是一个 AtomicInteger 类型的整数，存储着当着线程池的状态，以及线程池中线程的数量</span></span><br><span class="line">    <span class="comment">// 线程池的状态用整数的最高 3 位表示</span></span><br><span class="line">    <span class="comment">// 整数的低 29 位表示线程数量，即线程池中线程数量最多只能是 2^29 - 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 如果线程池中的数量小于核心线程数量，则新建一个线程执行该任务</span></span><br><span class="line">    <span class="comment">// 线程池内部维护一个 worker 变量，表示正在运行的线程</span></span><br><span class="line">    <span class="comment">// addWorker 函数内部会对线程池的状态及线程数量进行判断，满足条件后会创建一个新的线程运行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 程序运行到此处，意味这线程池中线程数量大于核心线程数量</span></span><br><span class="line">    <span class="comment">// 此处判断线程池状态是否是运行状态，如果是运行状态，则尝试将任务放入工作队列（阻塞队列）中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 此处再次对线程池的状态进行判断，主要是考虑并发的情况</span></span><br><span class="line">        <span class="comment">// 可能存在一个线程提交任务放入阻塞队列成功后，另一个线程提交了 shutdonw 请求关闭线程池</span></span><br><span class="line">        <span class="comment">// 因此此处再次判断状态，如果不是运行状态，则将任务从阻塞队列中移除</span></span><br><span class="line">        <span class="comment">// 因为执行了 shutdonw 或shutdownNow 后不允许提交新的任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 此处判断线程数量是否为 0，如果为 0，则新建一个线程，并且让这个线程从阻塞队列中拉取任务运行</span></span><br><span class="line">        <span class="comment">// 这种考虑是因为线程池中 allowCoreThreadTimeOut 可能被设置为 true</span></span><br><span class="line">        <span class="comment">// 那么，可能存在一种情况：在将任务放入阻塞队列后，核心线程因为空闲的时间达到阈值而被回收</span></span><br><span class="line">        <span class="comment">// 此时，如果不新建一个线程，那么阻塞队列中的任务将不能及时得到处理</span></span><br><span class="line">        <span class="comment">// 由于已经将任务放入阻塞队列中，因此此处不能直接处理当前提交的任务，而应该按照规则从队列中拉取</span></span><br><span class="line">        <span class="comment">// 因此，此处 addWorker 函数传入的是 null 而不是当前的任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 程序运行到此处，说明任务放入阻塞队列失败（阻塞队列满了）</span></span><br><span class="line">    <span class="comment">// 直接执行 addWorker 函数，在函数中判断线程数量是否达到 maximumPoolSize</span></span><br><span class="line">    <span class="comment">// 如果小于，则新建一个线程，运行当前的任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        <span class="comment">// 程序运行到这里，说明线程池中线程数量已经等于 maximumPoolSize，执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看看 <code>addWorker</code> 函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数 firstTask：表示新建线程后要运行的任务，如果为空，则从阻塞队列中拉取一个任务运行</span></span><br><span class="line"><span class="comment">// 第二个参数 core：表示是否用核心线程数与线程池中的线程数量进行比较</span></span><br><span class="line"><span class="comment">//                true：表示用 corePoolSize (核心线程数) 与线程池中线程数进行比较</span></span><br><span class="line"><span class="comment">//                false：表示用 maximumPoolSize （最大线程数）与线程池中线程数进行比较</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断线程池的状态</span></span><br><span class="line">        <span class="comment">// 如果线程池状态不是运行状态，即 SHUTDOWN、STOP、TIDYING、TERMINATED，则不再新建线程</span></span><br><span class="line">        <span class="comment">// 只有一种例外，即在SHUTDOWN状态并且工作队列（阻塞队列）中有未处理的任务，并且firstTask为空</span></span><br><span class="line">        <span class="comment">// 因为在 SHUTDOWN 状态，不允许提交新的任务，当时对于已经存在工作队列中的任务，必须处理完毕</span></span><br><span class="line">        <span class="comment">// 从 worker 类中的 run 函数中可知，当 firstTask 为空时，getTask 函数会从工作队列中获取任务</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">// 此处对线程池中的线程数量进行判断</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 此处用 CAS 判断是否增加数量成功</span></span><br><span class="line">            <span class="comment">// 增加成功，则跳出循环，进行后续的新建线程操作</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 一般情况下，上述 CAS 增加不成功时，只需要在内部继续循环即可</span></span><br><span class="line">            <span class="comment">// 当是考虑到可能线程池状态发现改变，因此此处对线程池状态进行判断</span></span><br><span class="line">            <span class="comment">// 如果线程池的状态发生了改变，则跳出内部循环，开始下一轮的外层循环</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以上是对线程池状态以及线程数量的判断</span></span><br><span class="line">    <span class="comment">// 以下是新建线程并开始执行任务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 用 worker 封装任务，worker 中的 thread 就是传入的 firstTask 参数</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 新建的线程开始执行，传入的任务也在此处开始执行</span></span><br><span class="line">                <span class="comment">// 此方法会调用 worker 中的 run 方法</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果线程没有启动成功，需要进行一些清理操作</span></span><br><span class="line">        <span class="comment">// 例如将前面放入 workers 的元素移除</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池中新建线程会执行 <code>worker</code> 的 <code>run</code> 方法，<code>run</code> 方法中只是简单的调用 <code>runWorker</code> 方法，因此，接下来看下 <code>runWorker</code> 的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    runWorker(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是循环获取任务并执行任务</span></span><br><span class="line">        <span class="comment">// task 可以是 worker 中的 firstTask，即新建线程时传入的要执行的任务</span></span><br><span class="line">        <span class="comment">// 如果 task 为空，则执行 getTask 函数从工作队列中获取</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 可扩展的函数，在执行任务前运行</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 此处是任务真正执行的地方</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 可扩展的函数，在执行任务后运行</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 任务执行完毕后，重置 task 为空，使其可以继续从工作队列中获取新的任务</span></span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看下 <code>getTask</code> 的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此函数从工作队列中获取任务，首先会执行状态检查</span></span><br><span class="line"><span class="comment">// 如果是 STOP、TIDYING、TERMINATED 状态，则返回 null。对于 TIDYING、TERMINATED 状态，工作队列肯定是空的，对于 STOP 状态，其会放弃工作队列中的任务，因此也不用从工作队列中获取任务</span></span><br><span class="line"><span class="comment">// 如果是 SHUTDOWN 状态，则判断工作队列是否为空，如果为空，则返回 null</span></span><br><span class="line"><span class="comment">// 在通过状态检查后，会进行线程数量判断，如果线程数量大于 maximumPoolSize（可以通过 setMaximumPoolSize 函数动态设置），则返回 null</span></span><br><span class="line"><span class="comment">// 在通过线程数量检查后，会根据是否要超时等待从工作队列中获取任务，如果设置了超时，则超时后返回 null，否则从工作队列中获取任务返回</span></span><br><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池状态检查</span></span><br><span class="line">        <span class="comment">// 如果是 SHUTDOWN 状态，则判断工作队列是否为空，如果为空，则返回 null</span></span><br><span class="line">        <span class="comment">// 如果是 STOP、TIDYING、TERMINATED 状态，则返回 null</span></span><br><span class="line">        <span class="comment">// 对于 TIDYING、TERMINATED 状态，工作队列肯定是空的，所以直接返回 null</span></span><br><span class="line">        <span class="comment">// 对于 STOP 状态，其会放弃工作队列中的任务，因此也不用从工作队列中获取任务</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 到工作队列中获取任务</span></span><br><span class="line">            <span class="comment">// 如果设置了超时机制，则等待一定时间后返回，否则阻塞等待直到取到任务为止</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">            workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>execute</code> 的函数大致解析完毕。</p>
<h1 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h1><p>当线程池中的线程数量大于 <code>maximumPoolSize</code> 时，再次提交任务，会执行拒绝策略。线程池中提供了四种拒绝策略可以供我们直接使用。当然，也可以自定义拒绝策略，在创建线程池中传入即可。线程池中定义的四种拒绝策略如下</p>
<table>
<thead>
<tr>
<th>拒绝策略</th>
<th>处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>CallerRunsPolicy</td>
<td>如果线程池没有关闭，由提交任务的线程自己执行这个任务</td>
</tr>
<tr>
<td>AbortPolicy</td>
<td>抛出 RejectedExecutionException 异常，这是默认的拒绝策略，如果在创建线程池的时候不传入参数指定拒绝策略，会默认使用这个拒绝策略</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>不做任何处理，直接丢弃这个任务</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>如果线程池没有关闭，从工作队列（阻塞队列）中取出队头的任务丢弃，然后重新尝试提交任务。此策略不建议与使用优先级队列（PriorityQueue）的工作队列结合使用</td>
</tr>
</tbody></table>
<h1 id="自定义线程池示例"><a href="#自定义线程池示例" class="headerlink" title="自定义线程池示例"></a>自定义线程池示例</h1><p>本例自定义一个线程池，其中 corePoolSize 为 3，maximumPoolSize 为 5，工作队列（阻塞队列）是长度为 2 的有界阻塞队列，拒绝策略采用默认的抛 RejectedExecutionException 异常的方式 。在创建线程池后，向线程提交 10 个任务进行运行。刚开始，由于线程池中线程数量小于 3，所以会创建 3 个线程用于运行提交的任务，当任务继续提交时，会将任务放入阻塞队列中等待运行，当提交任务达到 5 个时，阻塞队列已满，此时再提交任务，会继续创建新的线程运行刚刚提交的任务。当提交任务达到 7 个时（3 个在核心线程中运行，2 个在阻塞队列中，另外 2 个是由于线程数小于 maximumPoolSize 而新创建的线程执行的），再提交任务，会执行拒绝策略，抛出 RejectedExecutionException 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Push task count: &quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> <span class="string">&quot;TTT&quot;</span> + (i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                threadPoolExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Run thread &quot;</span> + threadName);</span><br><span class="line">                        <span class="keyword">try</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                        &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Submit thread &quot;</span> + threadName + <span class="string">&quot; error&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;Pool size: &quot;</span> + threadPoolExecutor.getPoolSize());</span><br><span class="line">            System.out.println(<span class="string">&quot;Queue count: &quot;</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">            System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Push task count: 1</span><br><span class="line">Pool size: 1</span><br><span class="line">Queue count: 0</span><br><span class="line">-----------------</span><br><span class="line">Push task count: 2</span><br><span class="line">Run thread TTT1</span><br><span class="line">Pool size: 2</span><br><span class="line">Queue count: 0</span><br><span class="line">Run thread TTT2</span><br><span class="line">-----------------</span><br><span class="line">Push task count: 3</span><br><span class="line">Pool size: 3</span><br><span class="line">Queue count: 0</span><br><span class="line">-----------------</span><br><span class="line">Push task count: 4</span><br><span class="line">Pool size: 3</span><br><span class="line">Run thread TTT3</span><br><span class="line">Queue count: 1</span><br><span class="line">-----------------</span><br><span class="line">Push task count: 5</span><br><span class="line">Pool size: 3</span><br><span class="line">Queue count: 2</span><br><span class="line">-----------------</span><br><span class="line">Push task count: 6</span><br><span class="line">Pool size: 4</span><br><span class="line">Queue count: 2</span><br><span class="line">-----------------</span><br><span class="line">Push task count: 7</span><br><span class="line">Pool size: 5</span><br><span class="line">Run thread TTT6</span><br><span class="line">Queue count: 2</span><br><span class="line">-----------------</span><br><span class="line">Push task count: 8</span><br><span class="line">Run thread TTT7</span><br><span class="line">Submit thread TTT8 error</span><br><span class="line">java.util.concurrent.RejectedExecutionException: Task thread.TestThreadPool$1@55f96302 rejected from java.util.concurrent.ThreadPoolExecutor@3d4eac69[Running, pool size = 5, active threads = 5, queued tasks = 2, completed tasks = 0]</span><br><span class="line">Pool size: 5</span><br><span class="line">Queue count: 2</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(Unknown Source)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.reject(Unknown Source)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source)</span><br><span class="line">	at thread.TestThreadPool.main(TestThreadPool.java:18)</span><br><span class="line">-----------------</span><br><span class="line">Push task count: 9</span><br><span class="line">Submit thread TTT9 error</span><br><span class="line">java.util.concurrent.RejectedExecutionException: Task thread.TestThreadPool$1@75b84c92 rejected from java.util.concurrent.ThreadPoolExecutor@3d4eac69[Running, pool size = 5, active threads = 5, queued tasks = 2, completed tasks = 0]</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(Unknown Source)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.reject(Unknown Source)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source)</span><br><span class="line">	at thread.TestThreadPool.main(TestThreadPool.java:18)</span><br><span class="line">Pool size: 5</span><br><span class="line">Queue count: 2</span><br><span class="line">-----------------</span><br><span class="line">Push task count: 10</span><br><span class="line">Submit thread TTT10 error</span><br><span class="line">java.util.concurrent.RejectedExecutionException: Task thread.TestThreadPool$1@232204a1 rejected from java.util.concurrent.ThreadPoolExecutor@3d4eac69[Running, pool size = 5, active threads = 5, queued tasks = 2, completed tasks = 0]</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(Unknown Source)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.reject(Unknown Source)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source)</span><br><span class="line">	at thread.TestThreadPool.main(TestThreadPool.java:18)</span><br><span class="line">Pool size: 5</span><br><span class="line">Queue count: 2</span><br><span class="line">-----------------</span><br><span class="line">Run thread TTT4</span><br><span class="line">Run thread TTT5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从输出结果中可以看出</p>
<ul>
<li>当提交任务数不超过 3 时，线程池立刻创建新线程执行任务。这从<code>Run Thread TTT1</code> 到 <code>Run Thread TTT3</code> 这一段的输出结果可以看出</li>
<li>当提交任务数是 <code>(3, 5]</code> 个时，提交的任务放如阻塞队列中等待执行。这从最后最后的两行输出 <code>Run thread TTT4</code>、<code>Run thread TTT5</code> 以及这两行在 <code>Run thread TTT7</code> 后面可以看出。</li>
<li>当提交任务数是<code>(5, 7]</code>个时，线程池立刻创建新的线程执行任务。这从输出 <code>Run Thread TTT3</code> 后直接输出  <code>Run Thread TTT6</code>  和  <code>Run Thread TTT7</code> 而后才输出  <code>Run thread TTT4</code>、<code>Run thread TTT5</code>  可以看出</li>
<li>当提交任务数是 <code>(7, 10]</code> 个时，线程池执行拒绝策略抛出异常。这从 <code>Submit thread TTT8 error</code>、<code>Submit thread TTT9 error</code>、<code>Submit thread TTT10 error</code> 可以看出</li>
</ul>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://javadoop.com/post/java-thread-pool"><a href="https://javadoop.com/post/java-thread-pool">https://javadoop.com/post/java-thread-pool</a></a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 javadoc2 插件快速生成 javadoc 注释</title>
    <url>/tools-javadoc2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近项目新增一个指标：代码中每个 protected、public 方法和成员变量都必须有 javadoc 注释，由于存在大量不符合规范的历史代码。如果一个个找出手工添加，必将花费大量的精力。所以寻求插件批量解决。javadoc2 插件刚好可以匹配这些要求。</p>
<span id="more"></span>

<h1 id="Javadoc2-插件使用"><a href="#Javadoc2-插件使用" class="headerlink" title="Javadoc2 插件使用"></a>Javadoc2 插件使用</h1><p>在 <code>File -&gt; Settings -&gt; Plugin</code> 中搜索 <code>javadoc2</code>，点击安装，重启 Intellij IDEA。</p>
<p><img src="/images/javadoc2-1.png" alt="javadoc2 plugin"></p>
<p>在 settings 中找到 javadoc2，根据自己需要进行设置调整</p>
<p><img src="/images/javadoc2-2.png" alt="javadoc2 setting"></p>
<p>选中要生成 javadoc 注释的包或文件，右键，在弹出菜单中，选择 <code>JavaDocs -&gt; Create JavaDocs for all elements</code></p>
<p><img src="/images/javadoc2-3.png" alt="javadoc2 create javadoc"></p>
<p>修改前后对比截图如下</p>
<p>修改前</p>
<p><img src="/images/javadoc2-4.png" alt="javadoc2 before update"></p>
<p>修改后</p>
<p><img src="/images/javadoc2-5.png" alt="javadoc2 after update"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>javadoc</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/union-find/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>并查集是一种树状结构，主要用于处理集合的合并和查找问题，其能在较低的时间复杂度内完成对集合元素的判断，常用于判断某些元素是否属于同个集合。</p>
<span id="more"></span>

<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>并查集是一种树状结构，但是跟一般的树形结构不太一样。平常的树结构主要是从上往下进行查找，所以数据结构中也经常有用于表示左右孩子的指针，但是并查集主要是从下往上进行查找，并不需要从上往下的查找，所以在并查集中并没有左右孩子的指针，取而代之的是用于表示当前节点的父节点的数组（当节点简单可以用数组下标表示所有节点时）或 <code>map</code> （当节点比较复杂，无法用数组的下标表示所有节点时，用 <code>map</code> 结构来表示节点的父节点）</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>并查集的主要操作有三个：初始化、查找、合并。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化，是设置每个节点的父节点为自己的本身（当然，为了方便计算，也可以设置成其他值，如 <code>0</code> 或 <code>null</code>）。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parents.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    parents[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找，主要是根据输入的节点依次遍历查找其父节点，知道找到当前分支的根节点为止。这是判断两个节点是否属于同个集合的关键所在。查找的过程是一个递归的过程。其代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递推版</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">while</span> (parents[current] != current)</span><br><span class="line">    &#123;</span><br><span class="line">        current = parents[current];</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == parents[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> find(parents, parents[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>普通的查找是循着路径一层层向上查找，如果树的深度过大，每次都沿着底层向上查找会变得很慢，如果在查找的过程中，将查找路径上的节点都直接指向根节点，则下次再查找路径上的节点时，就能直接获取到结果，而不用遍历查找了，这样就能提高查找速度。这就是路径压缩。其效果如下图所示：</p>
<p><img src="https://guozhchun.github.io/images/union-find-1.png" alt="路径压缩"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == parents[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> find(parents, parents[i]);</span><br><span class="line">    parents[i] = root;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>在构建集合的过程中，如果已经明确两个元素属于同一个集合，当时当前这两个元素的根节点并不相同，那么就要将这两个元素的根节点进行关联，这就是合并操作，其主要动作是将某个节点的父节点指向另一个根节点，至于哪个根节点作为父节点，这个可以自己根据规则进行定义，一般情况下，无特殊要求，也可以随机指定。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] parents)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">iParent</span> <span class="operator">=</span> parents[i];</span><br><span class="line">    <span class="type">int</span> <span class="variable">jParent</span> <span class="operator">=</span> parents[j];</span><br><span class="line">    <span class="keyword">if</span> (iParent != jParent)</span><br><span class="line">    &#123;</span><br><span class="line">        parents[iParent] = jParent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h1><p>上述的并查集，只是一种简单的判断元素是否在集合中，对于一些稍微复杂一点的情况，如两点之间的距离，就需要在边上记录额外的信息，在查找和合并的同时也需要进行对应边的值的更新操作，这样才能保证最终结果的正确性。</p>
<p>假设用 <code>values[i]</code> 表示当前节点到父节点的路径（边的值），在查找过程的路径压缩过程中，需要实时更新边值，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span> i, <span class="type">int</span>[] values)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == parents[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> find(parents, parents[i], values);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新边的值，这是递归的返回动作，必须在路径压缩前，这样才能保证值的准确性</span></span><br><span class="line">    values[i] = values[parents[i]] + values[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 路径压缩</span></span><br><span class="line">    parents[i] = root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于合并操作，由于需要把某个节点的根节点指向另一个根节点（即：将某个根节点变成其他节点的子节点），此时需要更新变动的根节点的边值（不再指向自己，而是执行其他节点，边值从 <code>0 值（广义的 0 值，并不是真正的数字 0，其具体值根据题目不同而不同）</code> 变成 <code>非 0 值</code>）。其代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] parents, <span class="type">int</span>[] values, <span class="type">int</span> currentEdgeValue)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">iParent</span> <span class="operator">=</span> parents[i];</span><br><span class="line">    <span class="type">int</span> <span class="variable">jParent</span> <span class="operator">=</span> parents[j];</span><br><span class="line">    <span class="keyword">if</span> (iParent != jParent)</span><br><span class="line">    &#123;</span><br><span class="line">        parents[iParent] = jParent;</span><br><span class="line">        <span class="comment">// currentEdgeValue 是 i 到 j 的边的值</span></span><br><span class="line">        values[iParent] = currentEdgeValue + values[j] - values[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://guozhchun.github.io/images/union-find-2.png" alt="路径压缩"></p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="普通并查集"><a href="#普通并查集" class="headerlink" title="普通并查集"></a>普通并查集</h2><p><a href="https://guozhchun.github.io/leetCode/leetCode-547/">LeetCode-547：朋友圈</a></p>
<h2 id="带权并查集-1"><a href="#带权并查集-1" class="headerlink" title="带权并查集"></a>带权并查集</h2><p><a href="https://guozhchun.github.io/leetCode/leetCode-399/">LeetCode-399：除法求值</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] iteye_9214.并查集详解[J&#x2F;OL]. <a href="https://blog.csdn.net/iteye_9214/article/details/82099516">https://blog.csdn.net/iteye_9214/article/details/82099516</a>, 2011-07-29</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构与算法</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>一个微型项目中期总结</title>
    <url>/vue-springboot-demo-sumup-1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之所以叫「微型项目」，是因为这个项目页面和功能都很单一，只满足基本功能的增删改查，并没有其他额外的考虑，如：国际化、安全性。因为做这个项目的初衷就是为了将部门内机器的使用情况进行汇总公开，方便后续的管理。为了能够快速完成开发，就只完成了基本的主要的功能，放弃了一些非功能性要求和交互性。这也是将其称为「微型项目」而不是「小型项目」的原因。</p>
<span id="more"></span>

<p>虽然，目前项目还没有全部开发完成，只完成了一部分主要功能，但是在这过程中也遇到了一些问题，担心积累到后面会遗忘，所以先在此做一部分回顾与总结。</p>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>虽然是自己折腾，但是也得有个目的，以下功能就是本次项目需要实现的。</p>
<ul>
<li>能够对物理机进行增删改查</li>
<li>能够对物理机上的虚拟机进行增删改查</li>
<li>能够通过某些查询条件（机器使用者，资产编号，机器挂账人等）进行查询得到结果</li>
<li>只有特定的人才能对机器进行增删改，普通人只能进行查询</li>
</ul>
<h1 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h1><ul>
<li><p>CSS框架：<del>Bootstrap</del> Element</p>
<p>因为以前只对 Bootstrap 有过了解，觉得其封装了一些组件挺好的，不用自己调样式，所以，刚开始就想用 Bootstrap 来配合使用搭建页面。后面发现 Bootstrap 封装还是过于简单，一些弹窗什么的都需要自己另外写，太麻烦了。同时又了解到 Element 配合 Vue 封装了大量常用的组件，极大地方便了页面的开发，所以就从 Bootstrap 切换到 Element</p>
</li>
<li><p>前端框架：Vue</p>
<p>其实现在项目中用的是公司自己封装过 Angularjs 的一个框架，理论上我用 Angularjs 能够更加快速地上手和开发，但是我却选择用 Vue，一个原因是想趁着这次折腾自己的机会学习下 Vue，另一个原因是项目组中曾经有想过要切换框架到 Vue，所以也可以提前了解准备下。</p>
</li>
<li><p>后端框架：Springboot</p>
<p>选择这个的原因就很简单了，就是图方便快捷。直接配置 maven 就能运行，不能额外弄其他的东西。</p>
</li>
<li><p>数据库框架：MyBatis</p>
<p>选择这个框架是因为可以直接写 sql，不用在 java 代码中动态拼接，也不用写很多的配置文件，看起来比较直观。</p>
</li>
<li><p>数据库：mysql</p>
</li>
</ul>
<h1 id="遇到的问题及解决方案"><a href="#遇到的问题及解决方案" class="headerlink" title="遇到的问题及解决方案"></a>遇到的问题及解决方案</h1><h2 id="Vue-整合到-Springboot-中"><a href="#Vue-整合到-Springboot-中" class="headerlink" title="Vue 整合到 Springboot 中"></a>Vue 整合到 Springboot 中</h2><p>由于本次使用 Vue 进行开发是通过引用 CDN 文件的形式，不是通过模块化的方式进行操作的，而网上的 Vue 和 Springboot 的整合基本上都是基于模块化的 Vue 进行操作的。这就导致我不知道如何将两者进行整合运行。在进行了一番搜索后，知道 Spring 默认会读取 static 目录下的 index.html 文件，因此将 Vue 的文件命名为 index.html 然后放入 static 目录下，启动 springboot 即可通过浏览器访问。</p>
<h2 id="Vue-中函数调用函数问题"><a href="#Vue-中函数调用函数问题" class="headerlink" title="Vue 中函数调用函数问题"></a>Vue 中函数调用函数问题</h2><p>正常情况下，需要通过  <code>this</code>  来调用，如下所示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">submitVirtualMachine</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">virtualMachineDialog</span>.<span class="property">type</span> == <span class="string">&quot;add&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">addVirtualMachine</span>(<span class="variable language_">this</span>.<span class="property">virtualMachineDialog</span>.<span class="property">virtualMachine</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">updateVirtualMachine</span>(<span class="variable language_">this</span>.<span class="property">virtualMachineDialog</span>.<span class="property">virtualMachine</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是当发起异步请求的处理结果过程中，通过 <code>this</code> 也无法调用实例中的函数。此时，需要在发起异步请求前用一个变量将 <code>this</code> 对象保存起来，在对发起异步后得到的返回结果进行处理时，使用保存的 <code>this</code> 值的变量来调用函数。如下所示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">updateVirtualMachine</span>(<span class="params">virtualMachine</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="variable language_">this</span>;    <span class="comment">// 保存 this 对象</span></span><br><span class="line">    axios.<span class="title function_">put</span>(<span class="string">&quot;/virtualMachine&quot;</span>, virtualMachine).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (response.<span class="property">data</span> == <span class="string">&quot;SUCCESS&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过 _this 对象而不是 this 对象来调用</span></span><br><span class="line">            <span class="comment">// 通过 this 对象调用函数会报错</span></span><br><span class="line">            _this.<span class="title function_">handleVirtualMachineSuccess</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _this.<span class="title function_">handleMachineError</span>(response.<span class="property">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">        _this.<span class="title function_">handleMachineError</span>(<span class="string">&quot;OPERATION_FAIL&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vue-页面初始化问题"><a href="#Vue-页面初始化问题" class="headerlink" title="Vue 页面初始化问题"></a>Vue 页面初始化问题</h2><p>想要在页面加载时调用某个函数，可以将函数写在 mounted 中，如下所示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">mounted</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getAllMachines</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="axios-delete-请求报没有-requestbody-问题"><a href="#axios-delete-请求报没有-requestbody-问题" class="headerlink" title="axios.delete 请求报没有 requestbody 问题"></a>axios.delete 请求报没有 requestbody 问题</h2><p>使用<code>axios.post(url, jsonData)</code>、 <code>axios.put(url, jsonData)</code> 都没有问题，但是使用 <code>axios.delete(url, jsonData)</code> 就会报 <code>Required request body is missing</code>  的错误，需要使用 <code>axios.delete(url, &#123;data: jsonData&#125;)</code> 来传递 request body 的内容。另外，如果需要使用类似 <code>http://IP:PORT/XXX?param1=x&amp;param2=xx</code> 的请求传递 URL 参数，则需要使用 <code>axios.delete(url, &#123;params: param&#125;)</code> </p>
<h2 id="本地后台调试问题"><a href="#本地后台调试问题" class="headerlink" title="本地后台调试问题"></a>本地后台调试问题</h2><p>在 maven 配置文件中加入 <code>jvmArguments</code> 配置项，并将其值设为： <code>-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005</code>，然后在 IDE 上配置 IP 和端口号，即可启动调试。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jvmArguments</span>&gt;</span></span><br><span class="line">                    -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005</span><br><span class="line">                <span class="tag">&lt;/<span class="name">jvmArguments</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h1><p>当前已经以下两个内容的开发</p>
<ul>
<li>能够对物理机进行增删改查</li>
<li>能够对物理机上的虚拟机进行增删改查</li>
</ul>
<p>部分效果图如下</p>
<p><img src="/images/machine-management-1.png" alt="首页"></p>
<p><img src="/images/machine-management-2.png" alt="增加机器"></p>
<p><img src="/images/machine-management-3.png" alt="增加虚拟机"></p>
<h1 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h1><p>后续计划继续完成以下内容开发</p>
<ul>
<li>能够通过某些查询条件（机器使用者，资产编号，机器挂账人等）进行查询得到结果</li>
<li>只有特定的人才能对机器进行增删改，普通人只能进行查询</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>表结构的设计很重要，在明确需求后，要先设计好数据结构。在开发前，需要先在脑海中或纸上预演一遍，看设计的表结构是否能够满足所有的流程。否则开发到一半时，需要修改表结构甚至推到重来，是很痛苦的事。</li>
<li>在进行技术选型时，除了自身原因的考虑（想要自己瞎折腾），要广泛搜索业界常用的搭配及使用方式，然后结合自身找到一个合适的框架进行开发，这样能够极大地提升开发效率。</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>项目地址：<a href="https://github.com/guozhchun/vue-springboot-demo">https://github.com/guozhchun/vue-springboot-demo</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>vue</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>一个微型项目总结</title>
    <url>/vue-springboot-demo-sumup-2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经过几个周末的学习和编码，终于把「微型项目：机器管理系统」给搭建起来了。本文是对本次开发过程中遇到的问题以及一些知识点的总结。</p>
<span id="more"></span>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>首先，开发这个系统的目的主要是记录部门机器的使用情况，并提供公示（查询）的能力，方便机器管理，提高机器有效使用率。所以，项目一开始就本着快速搭建的初衷进行，这也使得在一些功能的实现上选择了简单轻便的方式进行处理，而这也会导致一些非功能性需求的缺失（如：性能、安全）。</p>
<h2 id="系统功能"><a href="#系统功能" class="headerlink" title="系统功能"></a>系统功能</h2><ul>
<li>普通用户（非登录用户）可以对机器进行查询，包括按一定条件搜索机器</li>
<li>管理员（登录用户，系统有且只有一个账号）可以对机器（宿主机和虚拟机）进行管理，包括：增加、编辑、删除</li>
<li>支持中英文两种语言切换</li>
</ul>
<h2 id="系统截图"><a href="#系统截图" class="headerlink" title="系统截图"></a>系统截图</h2><ul>
<li>普通用户中文界面</li>
</ul>
<p><img src="/images/machine-management-4.png" alt="普通用户中文界面"></p>
<ul>
<li>普通用户英文界面</li>
</ul>
<p><img src="/images/machine-management-5.png" alt="普通用户英文界面"></p>
<ul>
<li>登录界面</li>
</ul>
<p><img src="/images/machine-management-6.png" alt="登录界面"></p>
<ul>
<li>管理员界面</li>
</ul>
<p><img src="/images/machine-management-7.png" alt="管理员界面"></p>
<ul>
<li>增加机器界面</li>
</ul>
<p><img src="/images/machine-management-2.png" alt="增加机器界面"></p>
<ul>
<li>增加虚拟机界面</li>
</ul>
<p><img src="/images/machine-management-3.png" alt="增加虚拟机j界面"></p>
<h1 id="知识点及问题"><a href="#知识点及问题" class="headerlink" title="知识点及问题"></a>知识点及问题</h1><h2 id="vue-组件"><a href="#vue-组件" class="headerlink" title="vue 组件"></a>vue 组件</h2><p>这个主要是用在登录模块和条件查询模块。刚开始以为这是一个很小的系统，代码量应该很少，可以直接放在一个文件中。后面随着功能的增加和完善，代码越来越多，如果全部放入一个文件，将显得臃肿难看。所以就学习应用 vue 组件的思想和功能，将比较独立的「登录」和「条件查询」这两个功能抽成「组件」进行使用。</p>
<p>vue 组件有三个主要点：定义组件、注册组件、使用组件、组件通信</p>
<ul>
<li><p>定义组件</p>
<p>组件定义跟 vue 实例的定义类似，不同的是相关的 html 代码写在 <code>template</code> 元素中，data 元素是一个函数，这样才能保证各个组件之间不会相互影响。以下代码是条件查询的组件定义相关代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var queryBlock = &#123;</span><br><span class="line">    props: [&quot;machineKinds&quot;],</span><br><span class="line">    data: function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            queryCondition: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        query() &#123;</span><br><span class="line">            this.queryCondition.startPageNum = 1;</span><br><span class="line">            this.queryCondition.pagePerCount = 10;</span><br><span class="line">            this.$emit(&quot;get-data&quot;, this.queryCondition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;el-collapse accordion&gt;</span><br><span class="line">            &lt;el-collapse-item :title=&quot;$t(&#x27;message.query&#x27;)&quot;&gt;</span><br><span class="line">                &lt;el-form :model=&quot;queryCondition&quot; label-position=&quot;right&quot; label-width=&quot;120px&quot;&gt;</span><br><span class="line">                    &lt;el-row :gutter=&quot;20&quot;&gt;</span><br><span class="line">                        &lt;el-col :span=&quot;12&quot; &gt;</span><br><span class="line">                            &lt;el-form-item :label=&quot;$t(&#x27;message.serialNumber&#x27;)&quot;&gt;</span><br><span class="line">                                &lt;el-input clearable v-model=&quot;queryCondition.serialNumber&quot; :placeholder=&quot;$t(&#x27;message.tips.input.serialNumber&#x27;)&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">                            &lt;/el-form-item&gt;</span><br><span class="line">                            &lt;el-form-item :label=&quot;$t(&#x27;message.type&#x27;)&quot; required&gt;</span><br><span class="line">                                &lt;el-select v-model=&quot;queryCondition.kind&quot; clearable :placeholder=&quot;$t(&#x27;message.tips.input.type&#x27;)&quot;&gt;</span><br><span class="line">                                    &lt;el-option v-for=&quot;item in machineKinds&quot; :key=&quot;item&quot; :label=&quot;item&quot; :value=&quot;item&quot;&gt;&lt;/el-option&gt;</span><br><span class="line">                                &lt;/el-select&gt;</span><br><span class="line">                            &lt;/el-form-item&gt;</span><br><span class="line">                        </span><br><span class="line">                            &lt;el-form-item label=&quot;BMCIP&quot;&gt;</span><br><span class="line">                                &lt;el-input clearable v-model=&quot;queryCondition.bmcIP&quot; :placeholder=&quot;$t(&#x27;message.tips.input.BMCIP&#x27;)&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">                            &lt;/el-form-item&gt;</span><br><span class="line">                            &lt;el-form-item :label=&quot;$t(&#x27;message.machineIP&#x27;)&quot;&gt;</span><br><span class="line">                                &lt;el-input clearable v-model=&quot;queryCondition.businessIP&quot; :placeholder=&quot;$t(&#x27;message.tips.input.machineIP&#x27;)&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">                            &lt;/el-form-item&gt;</span><br><span class="line">                        &lt;/el-col&gt;</span><br><span class="line">                        &lt;el-col :span=&quot;12&quot; &gt;</span><br><span class="line">                            &lt;el-form-item :label=&quot;$t(&#x27;message.owner&#x27;)&quot;&gt;</span><br><span class="line">                                &lt;el-input clearable v-model=&quot;queryCondition.owner&quot; :placeholder=&quot;$t(&#x27;message.tips.input.owner&#x27;)&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">                            &lt;/el-form-item&gt;</span><br><span class="line">                            &lt;el-form-item :label=&quot;$t(&#x27;message.machineUser&#x27;)&quot;&gt;</span><br><span class="line">                                &lt;el-input clearable v-model=&quot;queryCondition.user&quot; :placeholder=&quot;$t(&#x27;message.tips.input.machineUser&#x27;)&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">                            &lt;/el-form-item&gt;</span><br><span class="line">                        </span><br><span class="line">                            &lt;el-form-item :label=&quot;$t(&#x27;message.address&#x27;)&quot;&gt;</span><br><span class="line">                                &lt;el-input clearable v-model=&quot;queryCondition.virtualMachineIP&quot; :placeholder=&quot;$t(&#x27;message.tips.input.address&#x27;)&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">                            &lt;/el-form-item&gt;</span><br><span class="line">                        &lt;/el-col&gt;</span><br><span class="line">                    &lt;/el-row&gt;</span><br><span class="line">                    &lt;el-form-item align=&quot;right&quot;&gt;</span><br><span class="line">                        &lt;el-button type=&quot;primary&quot; @click=&quot;query()&quot;&gt;&#123;&#123;$t(&#x27;message.query&#x27;)&#125;&#125;&lt;/el-button&gt;</span><br><span class="line">                        &lt;el-button @click=&quot;queryCondition=&#123;&#125;&quot;&gt;&#123;&#123;$t(&#x27;message.reset&#x27;)&#125;&#125;&lt;/el-button&gt;</span><br><span class="line">                    &lt;/el-form-item&gt;</span><br><span class="line">                &lt;/el-form&gt;</span><br><span class="line">            &lt;/el-collapse-item&gt;</span><br><span class="line">        &lt;/el-collapse&gt;</span><br><span class="line">        `</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册组件</p>
<p>组件注册有两种，一种是全局注册，一种是局部注册。由于全局注册的组件影响范围较广，所以一般采用局部注册。本项目中的条件查询模块就是采用局部注册，其代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    components: &#123;</span><br><span class="line">    	&quot;query-block&quot;: queryBlock</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用组件</p>
<p>使用组件很简单，只需要像正常的 html 元素调用即可。如下是对条件查询组件的调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;query-block :machine-kinds=&quot;machineKinds&quot; v-on:get-data=&quot;getData&quot;&gt;&lt;/query-block&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件通信</p>
<ul>
<li><p>通过 prop 向子组件传值</p>
<p>在子组件中定义 prop 元素，这样父组件就可以通过定义的 prop 元素将父组件的值传递到子组件中，子组件使用这个值就像使用 data 元素里面的变量一样。需要注意的是，prop 元素在父组件的 html 相关代码中需要转成小写字母加横线的写法。如下代码是条件查询组件的 prop 传值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;query-block :machine-kinds=&quot;machineKinds&quot;&gt;&lt;/query-block&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var queryBlock = &#123;</span><br><span class="line">    props: [&quot;machineKinds&quot;]   // 也可以写成 props: [&quot;machine-kinds&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 $emit 函数向父组件传值</p>
<p>在子组件中，调用 emit 函数，传入一个标志符和相应的值，然后在父组件中通过传递的标识符获取相应的值。如下所示，子组件传递 <code>get-data</code> 标识符，其值为子组件的 <code>queryCondition</code>，在父组件中通过<code>v-on:get-data</code> 调用相应的函数获取子组件传递的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$emit(&quot;get-data&quot;, this.queryCondition);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;query-block v-on:get-data=&quot;getData&quot;&gt;&lt;/query-block&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    method: &#123;</span><br><span class="line">        getData(queryCondition) &#123;</span><br><span class="line">            this.queryCondition = this.copyObject(queryCondition);</span><br><span class="line">            this.currentPage = 1;</span><br><span class="line">            this.getMachines(this.queryCondition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>关于组件更多的内容，请参考 <a href="https://cn.vuejs.org/v2/guide/components.html">vue 官网</a></p>
<h2 id="用户-token-认证"><a href="#用户-token-认证" class="headerlink" title="用户 token 认证"></a>用户 token 认证</h2><p>这个主要是用在登录模块中的，主要用于判断用户是否登录。同时，由于系统只有一个用户，所以，也用这个 token 进行了权限的控制（对机器的增、删、改的权限控制）。</p>
<ul>
<li><p>token 的产生</p>
<p>在用户登录成功是，在后台产生一个 token 返回给前台，后续前台发起相关请求时携带此 token 进行身份验证。出于简便的目的，直接用 UUID 的方式产生随机 token</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure>
</li>
<li><p>token 的维护</p>
<ul>
<li><p>用户退出登录时，清除 token</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/logout&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(HttpServletRequest request, HttpServletRequest reponse)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    TokenUtil.removeToken(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户在登录后每发起一个请求，就更新 token 的时间，否则可能会出现用户在操作（非退出登录）过程中突然 token 失效导致无法使用系统</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateTime</span><span class="params">(String token)</span></span><br><span class="line">&#123;</span><br><span class="line">    tokenMap.replace(token, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>前台在获取到后台返回的 token 时，将 token 保存到 cookie 中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;token&quot;</span>, response.<span class="property">data</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>前台发起请求携带 token</p>
<p>本项目使用的 axios 向后台发送请求，axios 允许在所有请求的头部中增加相关信息。如下代码是在请求头中加入 token 信息，这样设置之后，所有的 axios 请求都会在 <code>Request Headers</code>  加入 token 信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置请求头中增加token，用于认证是否登录</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    config.<span class="property">headers</span>.<span class="property">token</span> = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>关于 axios 的详细使用可以参考<a href="http://www.axios-js.com/zh-cn/docs/">在线文档</a></p>
</li>
<li><p>后台对 token 的校验</p>
<p>由于对登录过后的用户发起的每个请求都需要更新 token 时间，所有最简单的做法是增加一个过滤器，拦截所有的请求，对每个请求中的 token 进行判断，存在系统中则进行时间的更新。同时，也可以在过滤器中对 token 的有效性进行校验。判断 token 的有效性主要是该 token 是否存在系统中以及是否过期。如果 token 不合法，则抛异常，这样就不会执行真正的业务代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validateToken</span><span class="params">(String token)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (TokenUtil.isTokenExpired(token))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;The token is invalid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isTokenExpired</span><span class="params">(String token)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(token))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;The token is invalid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> tokenMap.get(token);</span><br><span class="line">    <span class="keyword">if</span> (date == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;The token is invalid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Date</span> <span class="variable">currentDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (date.getTime() + DURATION_TIME &lt; currentDate.getTime())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于并不是所有的请求都要求登录，所以也并不是所有的请求都需要进行 token 的校验，因此，在进行 token   校验前，需要对请求进行判断，只有对机器的增删改的请求才进行校验，查询操作没有权限控制，不用进行 token 校验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">needAuth</span><span class="params">(HttpServletRequest request)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">    <span class="type">String</span> <span class="variable">requestMethod</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;/machine&quot;</span>, requestURI))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;POST&quot;</span>, requestMethod)</span><br><span class="line">            || StringUtils.equals(<span class="string">&quot;PUT&quot;</span>, requestMethod)</span><br><span class="line">            || StringUtils.equals(<span class="string">&quot;DELETE&quot;</span>, requestMethod))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;/virtualMachine&quot;</span>, requestURI))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p>国际化主要涉及两方面，一个是使用 Element 框架组件自身的国际化，另一个是业务产生所需的国际化。</p>
<ul>
<li><p>业务代码国际化</p>
<p>国际化主要使用的是 vue 的插件 <code>vue-i18n</code>, 需要引入<code>&lt;script src=&quot;https://unpkg.com/vue-i18n/dist/vue-i18n.js&quot;&gt;&lt;/script&gt;</code> 文件。</p>
<p>其定义如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> messages = &#123;</span><br><span class="line">    <span class="attr">zh</span>: &#123;</span><br><span class="line">        <span class="attr">message</span>: &#123;</span><br><span class="line">            <span class="attr">delete</span>: <span class="string">&quot;删除&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">en</span>: &#123;</span><br><span class="line">        <span class="attr">message</span>: &#123;</span><br><span class="line">            <span class="attr">delete</span>: <span class="string">&quot;delete&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i18n = <span class="keyword">new</span> <span class="title class_">VueI18</span>n(&#123;</span><br><span class="line">    <span class="attr">locale</span>: <span class="string">&quot;zh&quot;</span>, <span class="comment">// set locale</span></span><br><span class="line">    messages, <span class="comment">// set locale messages</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    i18n,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用时，分三种情况，有不同的用法</p>
<ul>
<li><p>html 元素</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;$t(&#x27;message.item&#x27;)&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-button type=&quot;primary&quot; @click=&quot;login()&quot;&gt;&#123;&#123;$t(&#x27;message.login&#x27;)&#125;&#125;&lt;/el-button&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Element元素传值</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$t(&#x27;message.item&#x27;)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-input v-model=&quot;user.name&quot; :placeholder=&quot;$t(&#x27;message.tips.input.username&#x27;)&quot; &gt;&lt;/el-input&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$t(&#x27;message.item&#x27;)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$alert(errorMessage, <span class="variable language_">this</span>.$t(<span class="string">&#x27;message.error&#x27;</span>), &#123;</span><br><span class="line">    <span class="attr">confirmButtonText</span>: <span class="variable language_">this</span>.$t(<span class="string">&#x27;message.confirm&#x27;</span>),</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;error&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>关于 vue-i18n 的更多内容，可以参考 <a href="http://kazupon.github.io/vue-i18n/zh/introduction.html">vue-i18n官网</a></p>
</li>
<li><p>Element 组件国际化</p>
<p>Element 组件默认使用中文，当将语言切换成英文时，需要将 Element 组件的语言也切换成英文。需要引入两个 Element 国际化相关的文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/element-ui/lib/umd/locale/zh-CN.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/umd/locale/en.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>在定义业务代码国际化时，将 Element 组件的国际化包含进去。如下所示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> messages = &#123;</span><br><span class="line">    <span class="attr">zh</span>: &#123;</span><br><span class="line">        <span class="attr">message</span>: &#123;</span><br><span class="line">            <span class="attr">delete</span>: <span class="string">&quot;删除&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        ...<span class="variable constant_">ELEMENT</span>.<span class="property">lang</span>.<span class="property">zhCN</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">en</span>: &#123;</span><br><span class="line">        <span class="attr">message</span>: &#123;</span><br><span class="line">            <span class="attr">delete</span>: <span class="string">&quot;delete&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        ...<span class="variable constant_">ELEMENT</span>.<span class="property">lang</span>.<span class="property">en</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i18n = <span class="keyword">new</span> <span class="title class_">VueI18</span>n(&#123;</span><br><span class="line">    <span class="attr">locale</span>: <span class="string">&quot;zh&quot;</span>, <span class="comment">// set locale</span></span><br><span class="line">    messages, <span class="comment">// set locale messages</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// very important for element i18n</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="variable constant_">ELEMENT</span>, &#123;</span><br><span class="line">    <span class="attr">i18n</span>: <span class="function">(<span class="params">key, value</span>) =&gt;</span> i18n.<span class="title function_">t</span>(key, value)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>关于 Element 框架国际化的内容，请浏览 <a href="https://element.eleme.cn/#/zh-CN/component/i18n">Element 官网</a></p>
</li>
<li><p>语言间切换</p>
<p>vue-i18n 提供了 <code>$i18n.locale</code> 变量来设置国际化语言。因此可以通过改变这个变量的值来达到切换语言的目的。代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-button type=&quot;text&quot; @click=&quot;changeLanguaue(&#x27;zh&#x27;)&quot; :disabled=&quot;$i18n.locale==&#x27;zh&#x27;&quot;&gt;中文&lt;/el-button&gt;</span><br><span class="line">&lt;el-button type=&quot;text&quot; @click=&quot;changeLanguaue(&#x27;en&#x27;)&quot; :disabled=&quot;$i18n.locale==&#x27;en&#x27;&quot;&gt;English&lt;/el-button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">changeLanguaue</span>(<span class="params">lang</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$i18n</span>.<span class="property">locale</span> = lang;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>请见：<a href="https://guozhchun.github.io/vue-springboot-demo-sumup-1/">一个微型项目中期总结</a> 中 「遇到的问题及解决方案」章节</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>vue 官网：<a href="https://cn.vuejs.org/v2/guide/">https://cn.vuejs.org/v2/guide/</a></li>
<li>axios 在线文档：<a href="http://www.axios-js.com/zh-cn/docs/">http://www.axios-js.com/zh-cn/docs/</a></li>
<li>vue-i18n 官网：<a href="http://kazupon.github.io/vue-i18n/zh/introduction.html">http://kazupon.github.io/vue-i18n/zh/introduction.html</a></li>
<li>Element 官网：<a href="https://element.eleme.cn/#/zh-CN/component/i18n">https://element.eleme.cn/#/zh-CN/component/i18n</a></li>
</ol>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>项目地址：<a href="https://github.com/guozhchun/vue-springboot-demo">https://github.com/guozhchun/vue-springboot-demo</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>vue</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/design-pattern/adapter-pattern/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<p>适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;——《Head First 设计模式》</p>
</blockquote>
<p>也就是说，适配器模式是让适配类在目标类和被适配者类中间做一个桥梁的转换，在不改变适目标类和被适配者类代码的情况下让两者可以互相调用。和命令模式的“中介”作用有点类似，甚至在实现上可以说命令模式的一部分功能是用适配器模式实现的（后续分析），但是从目的上来讲两者还是有差别的，命令模式是对“请求”的封装，让调用者对实现者无感知，而适配器模式是对接口的转换，是为了在让接口不变的情况下能够通信。</p>
<p>适配器有两种，一种是对象适配器，一种是类适配器。</p>
<span id="more"></span>

<h1 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h1><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="/images/designPattern/adapterPattern/adapterPatternUML.png" alt="适配器模式类图"></p>
<blockquote>
<p>说明：此图参考《Head First 设计模式》画出</p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>此处以射击类游戏为例。假设有两种武器：刀和枪，刀有刺杀（stab）功能，枪有开枪（fire）的功能，现在用枪的开枪功能模拟刀的刺杀功能，也就是在调用stab函数时实际上是调用的fire函数。</p>
<h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="/images/designPattern/adapterPattern/adapterPatternSampleUML.png" alt="适配器模式例子类图"></p>
<h3 id="目标接口"><a href="#目标接口" class="headerlink" title="目标接口"></a>目标接口</h3><p>此处是用枪来模拟刀，所以目标接口是刀的接口。此处用StabAction接口类来表示，接口中只有一个stab抽象函数，用来表示刺杀行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StabAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stab</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="目标接口实现类"><a href="#目标接口实现类" class="headerlink" title="目标接口实现类"></a>目标接口实现类</h3><p>目标接口实现类是Knife类，实现stab接口，表示刀的刺杀行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Knife</span> <span class="keyword">implements</span> <span class="title class_">StabAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stab</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Knife stabbing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="被适配者接口类和实现类"><a href="#被适配者接口类和实现类" class="headerlink" title="被适配者接口类和实现类"></a>被适配者接口类和实现类</h3><p>被适配者是枪的开枪行为接口类FireAction，该类的一个实现是Gun</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">FireAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span> <span class="keyword">implements</span> <span class="title class_">FireAction</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Gun firing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>适配器要求实现目标接口，同时要求拥有一个被适配者对象属性。在stab方法中，通过调用被适配者gun的fire方法从而完成stab方法到fire方法的转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GunAdapter</span> <span class="keyword">implements</span> <span class="title class_">StabAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> FireAction gun;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GunAdapter</span><span class="params">(FireAction gun)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.gun = gun;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stab</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gun.fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证程序"><a href="#验证程序" class="headerlink" title="验证程序"></a>验证程序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAdapter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化类对象</span></span><br><span class="line">        <span class="type">StabAction</span> <span class="variable">knife</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Knife</span>();</span><br><span class="line">        <span class="type">FireAction</span> <span class="variable">gun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gun</span>();</span><br><span class="line">        <span class="type">StabAction</span> <span class="variable">gunAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GunAdapter</span>(gun);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----Knife stab----&quot;</span>);</span><br><span class="line">        knife.stab();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----Gun fire----&quot;</span>);</span><br><span class="line">        gun.fire();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----GunAdapter stab: it call stab method and print &#x27;Gun firing...&#x27;----&quot;</span>);</span><br><span class="line">        gunAdapter.stab();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/designPattern/adapterPattern/adapterPatternSampleOutput.png" alt="适配器模式例子输出结果"></p>
<h1 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h1><h2 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h2><p><img src="/images/designPattern/adapterPattern/classAdapterPatternUML.png" alt="类适配器模式类图"></p>
<blockquote>
<p>说明：此图参考《Head First 设计模式》画出</p>
</blockquote>
<p>对比类图可以发现，类适配器主要是使用继承实现的，即让适配器类继承被适配器类；而对象适配器主要是使用组合实现的，即让适配器拥有被适配者类。</p>
<h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p>此处仍以对象适配器的例子进行说明比较。</p>
<h3 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h3><p><img src="/images/designPattern/adapterPattern/classAdapterPatternSampleUML.png" alt="类适配器模式例子类图"></p>
<h3 id="目标接口-1"><a href="#目标接口-1" class="headerlink" title="目标接口"></a>目标接口</h3><p>与对象适配器中例子的目标接口相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StabAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stab</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="目标接口实现类-1"><a href="#目标接口实现类-1" class="headerlink" title="目标接口实现类"></a>目标接口实现类</h3><p>与对象适配器中例子的目标接口实现类相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Knife</span> <span class="keyword">implements</span> <span class="title class_">StabAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stab</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Knife stabbing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="被适配者接口类和实现类-1"><a href="#被适配者接口类和实现类-1" class="headerlink" title="被适配者接口类和实现类"></a>被适配者接口类和实现类</h3><p>与对象适配器中例子的被适配者接口类和实现类相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">FireAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span> <span class="keyword">implements</span> <span class="title class_">FireAction</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Gun firing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="适配器-1"><a href="#适配器-1" class="headerlink" title="适配器"></a>适配器</h3><p>此处使用继承被适配器的方法完成适配器类，在stab方法中直接调用继承过来Gun对象中的fire方法，从而完成stab方法到fire方法的转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GunAdapter</span> <span class="keyword">extends</span> <span class="title class_">Gun</span> <span class="keyword">implements</span> <span class="title class_">StabAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stab</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证程序-1"><a href="#验证程序-1" class="headerlink" title="验证程序"></a>验证程序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAdapter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化类对象</span></span><br><span class="line">        <span class="type">StabAction</span> <span class="variable">knife</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Knife</span>();</span><br><span class="line">        <span class="type">FireAction</span> <span class="variable">gun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gun</span>();</span><br><span class="line">        <span class="type">StabAction</span> <span class="variable">gunAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GunAdapter</span>();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----Knife stab----&quot;</span>);</span><br><span class="line">        knife.stab();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----Gun fire----&quot;</span>);</span><br><span class="line">        gun.fire();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----GunAdapter stab: it call stab method and print &#x27;Gun firing...&#x27;----&quot;</span>);</span><br><span class="line">        gunAdapter.stab();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/designPattern/adapterPattern/classAdapterPatternSampleOutput.png" alt="类适配器模式例子输出结果"></p>
<p>可以看出，类适配器和对象适配器的输出结果是相同的</p>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>对象适配器和类适配器都能在不改变原有接口的情况下实现接口的通信，完成一个接口到另一个接口的转换。但是对象适配器使用的是组合，而类适配器使用的是继承。使用组合不仅可以适配某个类，也可以适配该类的任何子类，而使用继承则可以覆盖被适配者的行为。然而，由于java不支持多继承，且本着“组合优于继承”的原则，还是建议多使用对象适配器的方式，少使用类适配器的方式。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="与命令模式比较"><a href="#与命令模式比较" class="headerlink" title="与命令模式比较"></a>与命令模式比较</h2><p>命令模式是将“请求”封装成一个命令对象，让调用者持有这个命令对象，调用者通过调用命令对象提供的接口让命令对象持有的实现者完成特定的操作。这个过程中，命令对象就相当于一个适配器的作用，对比命令模式的类图和适配器的类图也可以看出，调用者 -&gt; 命令对象 -&gt; 实现者 这三者就是一个适配器模式的类图，如下图所示</p>
<p><img src="/images/designPattern/adapterPattern/adapterPatternCompareWithCommandPatternUML.png" alt="命令模式与适配器模式类图比较"></p>
<h2 id="与装饰者模式比较"><a href="#与装饰者模式比较" class="headerlink" title="与装饰者模式比较"></a>与装饰者模式比较</h2><p>装饰者模式是对一个装饰对象新增功能，用来装饰的对象不但继承了装饰者对象，同时也拥有装饰者对象作为一个属性。对于适配者模式而言，适配器实现目标接口，同时继承或组合被装饰者。即装饰者模式对同一个对象同时应用了继承和组合，而适配器模式对同一个对象只会运用继承或组合中的一种。另外，从功能角度而言，装饰者模式是为对象附上新的功能，不会进行接口的转换，而适配器模式一定会对接口进行转换，不会为对象附上新的功能。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Eric Freeman等，Head First 设计模式（中文版）[M]，北京：中国电力出版社，2007</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>构建者模式</title>
    <url>/design-pattern/builder-pattern/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>构建者模式将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。这个定义看起来文绉绉的不好理解。其实就是在创建对象时可以“按需”使用对象的的某个（某几个）属性，并在必要时对这些属性进行校验。</p>
<span id="more"></span>

<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>构建者模式是用在创建对象的时候的，在创建对象的时候同时指定一个或多个属性值。这看起来是可以通过构造函数来实现的。比如对于对于 <code>Student</code> 类，可以通过以下的方式来实现：将类中的属性进行组合，然后依次写上构造函数。不过这对属性少的对象来说还可以，对属性多的对象，组合起来就很多了，而且以后增加一个属性又得进行大改动，同时还存在一个问题，就是属性的类型可能相同，导致部分组合无法实现。另外，对于属性个数多的构造函数，调用者也不太容易区分属性的个数，也不容易扩展，因此这种方式不太好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用构造函数不满足要求，此时，我们很自然的就想到了可以是用 <code>set</code> 方法进行属性的设置。比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用的地方</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.setId(<span class="number">1</span>);</span><br><span class="line">student.setName(<span class="string">&quot;Alice&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这种方式可以让调用者自行决定设置某些值，也解决了构造函数过多组合的问题，但是这种方式存在其他的问题：</p>
<ol>
<li>不能对属性值进行校验，即：满足某种条件时允许创建对象，不满足时不允许创建</li>
<li>可能存在无效状态的问题。</li>
</ol>
<p>先说第一个问题：不能对属性值进行校验。使用 set 的方式看起来是可以对属性值进行校验的，比如对于 <code>setId</code> 这个函数，我可以在函数内部判断，如果 <code>id</code> 范围小于 <code>0</code>，则抛异常，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;id is invalid&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这是单个属性的判断，如果是多个属性联合判断就不满足了。比如要判断 <code>id</code> 小于 <code>100</code> 时，<code>name</code> 只能以 <code>A</code> 开头，这样在 <code>Student</code> 类内部就无法完成判断，只能让调用者进行判断，也就是说将这个控制权交给了调用方，万一调用者不进行判断，那这个限制条件就相当于无效了。</p>
<p>再说第二个问题，因为使用 <code>set</code> 的方式是先 <code>new</code> 一个空对象，再依次设置属性值的，那就存在一种情况，在 <code>new</code> 和 <code>set</code> 的过程中，对象是无效的（因为其他的属性值并没有设置好），此时如果获取到这个对象就可能出错。</p>
<p>针对以上几个问题，就产生了构建者模式的方式来创建对象。构建者模式是先将属性值设置好，然后最后按照这些值进行判断（如果需要的化），然后创建出具体的对象。</p>
<p>构建者模式也很简单，只需要在需要使用构建者模式的类创建一个内部类，然后对每个属性产生一个方法，最后统一暴露对外 <code>build</code> 方法即可。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>上文 <code>Student</code> 类的构建者代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;id is invalid&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Student <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 在构建最后一步，进行必要的校验</span></span><br><span class="line">            <span class="keyword">if</span> (id &lt; <span class="number">100</span> &amp;&amp; !name.startsWith(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The id or name is invalid&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(id, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的地方</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>.Builder()</span><br><span class="line">                .setId(<span class="number">1</span>)</span><br><span class="line">                .setName(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>构建者模式代码还是比较多的，如果构造函数或 <code>set</code> 方式能够满足要求，就没必要写太多代码用上构造者模式，或者使用 <code>lombok</code> 插件的 <code>Builder</code> 注解自动生成，不过使用 <code>lombok</code> 就需要项目组中所有成员都使用，不然就很乱。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>王争，《设计模式之美》</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/design-pattern/command-pattern/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<p>命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;——《Head First 设计模式》</p>
</blockquote>
<p>也就是说，命令者模式是让命令对象充当调用者（请求命令方）和接收者（执行命令方）中间的桥梁，调用者（请求命令方）拥有一个命令对象，命令对象拥有一个接收者（执行命令方），当调用者需要调用接收者的命令时，不是直接调用接收者，而是先通过调用命令对象的接口，由命令对象去内部的逻辑去调用接收方相应的操作，从而完成整个过程。因为命令对象的存在，调用者不需要知道接收者提供的接口，甚至可以无视接收者，因为调用者只和命令对象打交道。通过命令对象的隔离，可以使调用者和接收者进行解耦，后续接收者发生相应的变动也对调用者无感知。</p>
<span id="more"></span>

<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/designPattern/commandPattern/commandPatternUML.png" alt="命令模式类图"></p>
<blockquote>
<p>说明：此图参考《Head First 设计模式》画出</p>
</blockquote>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>此处以射击类游戏为例，假设有一个角色，两种武器：刀和枪，角色使用武器进行攻击。在使用枪时需要先装子弹，然后才能攻击，而使用刀可以直接攻击。</p>
<h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><p><img src="/images/designPattern/commandPattern/commandPatternSampleUML.png" alt="命令模式例子类图"></p>
<h2 id="接收方类"><a href="#接收方类" class="headerlink" title="接收方类"></a>接收方类</h2><p>接收方类有两个（模拟武器）：Knife和Gun，Knife中只有有一个方法stab，用于模拟刀的攻击，Gun中有两个方法，其中loadBullets用于模拟装子弹，fire用于模拟开枪，只有两个方法连起来才能模拟一次枪的攻击。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Knife</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stab</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Knife stabbing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBullets</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Loading bullets...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Gun firing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Command接口类"><a href="#Command接口类" class="headerlink" title="Command接口类"></a>Command接口类</h2><p>Command接口类很简单，只有一个execute方法，供调用者调用，执行命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Command接口实现类"><a href="#Command接口实现类" class="headerlink" title="Command接口实现类"></a>Command接口实现类</h2><p>Command接口实现类有两个：KnifeAttackCommand和GunAttackCommand，分别实现execute方法，模拟对应的攻击行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KnifeAttackCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Knife knife;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KnifeAttackCommand</span><span class="params">(Knife knife)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.knife = knife;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        knife.stab();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GunAttackCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Gun gun;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GunAttackCommand</span><span class="params">(Gun gun)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.gun = gun;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gun.loadBullets();</span><br><span class="line">        gun.fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用方类"><a href="#调用方类" class="headerlink" title="调用方类"></a>调用方类</h2><p>Person类是调用方类，在这个类中持有一个Command对象，提供一个setCommond方法用于改变命令对象，在doAttack方法中调用命令对象的execute方法完成命令调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Command command)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommond</span><span class="params">(Command command)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAttack</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="验证程序"><a href="#验证程序" class="headerlink" title="验证程序"></a>验证程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化相关对象</span></span><br><span class="line">        <span class="type">Knife</span> <span class="variable">knife</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Knife</span>();</span><br><span class="line">        <span class="type">Gun</span> <span class="variable">gun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gun</span>();</span><br><span class="line">        <span class="type">Command</span> <span class="variable">knifeAttackCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KnifeAttackCommand</span>(knife);</span><br><span class="line">        <span class="type">Command</span> <span class="variable">gunAttackCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GunAttackCommand</span>(gun);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用knifeAttackCommand初始化person对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----init person with knifeAttackCommand----&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(knifeAttackCommand);</span><br><span class="line">        person.doAttack();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----change command object to gunAttackCommand----&quot;</span>);</span><br><span class="line">        person.setCommond(gunAttackCommand);</span><br><span class="line">        person.doAttack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/designPattern/commandPattern/commandPatternSampleOutput.png" alt="命令模式例子输出结果"></p>
<h1 id="与策略模式比较"><a href="#与策略模式比较" class="headerlink" title="与策略模式比较"></a>与策略模式比较</h1><p>命令模式和策略模式都是对行为进行封装，接收者及接收者的变化对调用者均无感知。这两种模式看起来似乎是相同的，甚至命令者模式也可以用策略模式实现（文章后面会将本文的例子用策略模式实现），策略模式也可以用命令者模式实现（本文同一个例子，用命令模式和策略模式分别实现，说明两者是可以转换的），那这两种模式是不是没有区别呢。事实上，命令模式与策略模式相比，多了一个“中介”，就是命令对象。命令模式对行为的封装是在命令对象中进行的，而策略模式对行为的封装是在接收者自己对象内进行的（参考对比本文的两个例子）。另一方面，相比而言，用命令模式实现相对比较复杂，而用策略模式实现则比较简单。但是，如果要对外统一提供接口，对行为进行封装，而又不能改变接收者类的时候（这种情况下一般发生在新增统一接口而原有类没实现该接口的场景下），此时命令模式就能派上用场了；而如果允许对接收这类进行修改，让接收者类实现统一的接口（这种情况下一般发生在接收者类和统一接口都是新增的或接收者类已经实现该接口的场景下），此时选用策略模式比较好（因为简单）。</p>
<p>接下来用策略模式实现上文中的例子。</p>
<h2 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h2><p><img src="/images/designPattern/commandPattern/strategyPatternSampleUML.png" alt="策略模式实现命令模式例子类图"></p>
<p>对比这两个类图，可以发现，策略模式相比命令模式，少了命令对象，将命令对象进行的行为封装放在接收方类中，其他不变</p>
<h2 id="Command接口类-1"><a href="#Command接口类-1" class="headerlink" title="Command接口类"></a>Command接口类</h2><p>Command接口类与命令模式的Command接口类一样，只提供一个execute接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Command接口实现类（接收方类）"><a href="#Command接口实现类（接收方类）" class="headerlink" title="Command接口实现类（接收方类）"></a>Command接口实现类（接收方类）</h2><p>在策略模式中，接收方类与Command接口实现类是同一个，在接收方类中实现execute方法，完成对行为的封装。而在命令模式中，对行为的封装是在Command接口实现类中，在实现类中调用了接收方的相应方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span> <span class="keyword">implements</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBullets</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Loading bullets...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Gun firing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        loadBullets();</span><br><span class="line">        fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Knife</span> <span class="keyword">implements</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stab</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Knife stabbing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        stab();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用方类-1"><a href="#调用方类-1" class="headerlink" title="调用方类"></a>调用方类</h2><p>调用方类Person与命令模式的调用方类Person一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Command command)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommond</span><span class="params">(Command command)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAttack</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="验证程序-1"><a href="#验证程序-1" class="headerlink" title="验证程序"></a>验证程序</h2><p>策略模式中，因为少了命令模式中的“中介”命令对象，所以初始化对象也会比较少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStrategy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">gun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gun</span>();</span><br><span class="line">        <span class="type">Command</span> <span class="variable">knife</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Knife</span>();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----init person with knife----&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(knife);</span><br><span class="line">        person.doAttack();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----change command object to gun----&quot;</span>);</span><br><span class="line">        person.setCommond(gun);</span><br><span class="line">        person.doAttack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/designPattern/commandPattern/strategyPatternSampleOutput.png" alt="策略模式实现命令模式例子输出结果"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Eric Freeman等，Head First 设计模式（中文版）[M]，北京：中国电力出版社，2007</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/design-pattern/composite-pattern/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<p>组合模式允许你将对象组合成树形结构来表现“整体&#x2F;部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;——《Head First 设计模式》</p>
</blockquote>
<p>也就是说，组合模式是用来呈现树状结构的，利用组合模式，让叶子节点和非叶子节点继承同一个基础类，可以让叶子节点对象和组件（非叶子）节点对象之间的差异得以忽略，从而为客户程序提供更简单统一的调用方式。</p>
<span id="more"></span>

<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/designPattern/compositePattern/UML.png" alt="组合模式类图"></p>
<blockquote>
<p>说明：此图参考《Head First 设计模式》画出</p>
</blockquote>
<p>从类图中可以看出，组件（非叶子节点）既继承了基础类，也拥有基础类作为一个属性。继承基础类是为了和叶子节点有同一个基础类，从而对客户端屏蔽组件和叶子节点的差异，让客户端有统一接口可以调用，方便客户端程序。拥有基础类作为一个属性是因为组件类不是叶子节点，其叶子节点的数据放在这个属性中。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>此处以部门为例子进行说明。假设A部门底下有B、C、D三个部门，C部门底下有E、F部门，B、D、E、F部门都没有子部门。部门之间的层次结构如下图所示</p>
<p><img src="/images/designPattern/compositePattern/dept.png" alt="组合模式例子部门层次结构图"></p>
<h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><p><img src="/images/designPattern/compositePattern/sampleUML.png" alt="组合模式例子类图"></p>
<h2 id="抽象基础类"><a href="#抽象基础类" class="headerlink" title="抽象基础类"></a>抽象基础类</h2><p>抽象类Dept中有一个抽象函数description，用于描述本部门的信息。另外三个函数add、remove、getChild在抽象基础类中提供默认实现，主要是考虑到叶子类的情况，这样叶子类继承后只需要实现description函数即可。而非叶子类需要重写这四个函数。因为add、remove、getChild这三个函数对非叶子类有意义而对叶子类无意义。</p>
<p>当然，对于add、remove、getChild这三个函数，也可以定义成抽象的，然后再在叶子类和非叶子类中分别对其进行特殊的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dept</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">description</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抽象类中提供默认实现，叶子类可以直接继承不用重写，非叶子类进行重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Dept dept)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;No support method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抽象类中提供默认实现，叶子类可以直接继承不用重写，非叶子类进行重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Dept dept)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;No support method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抽象类中提供默认实现，叶子类可以直接继承不用重写，非叶子类进行重写</span></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;No support method.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="叶子类"><a href="#叶子类" class="headerlink" title="叶子类"></a>叶子类</h2><p>叶子类DeptLeaf中有一个属性name用于表示部门的名字，重写了description函数用于输出本部门的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeptLeaf</span> <span class="keyword">extends</span> <span class="title class_">Dept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeptLeaf</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">description</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非叶子类"><a href="#非叶子类" class="headerlink" title="非叶子类"></a>非叶子类</h2><p>非叶子类DeptComposite有一个属性name用于表示本部门的名字，有一个属性deptList用于存储子部门，并重写了抽象类中的所有方法。对于description方法，主要是依次调用deptList属性中元素的description方法，这样就形成了递归调用，从而能够将本类及本类的所有子类遍历到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeptComposite</span> <span class="keyword">extends</span> <span class="title class_">Dept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Dept&gt; deptList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeptComposite</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非叶子类，依次递归调用叶子类对应方法完成遍历</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">description</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DeptComposite &quot;</span> + name + <span class="string">&quot; begin&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Dept dept : deptList)</span><br><span class="line">        &#123;</span><br><span class="line">            dept.description();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;DeptComposite &quot;</span> + name + <span class="string">&quot; end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非叶子类，需要对此方法进行重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Dept dept)</span></span><br><span class="line">    &#123;</span><br><span class="line">        deptList.add(dept);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非叶子类，需要对此方法进行重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Dept dept)</span></span><br><span class="line">    &#123;</span><br><span class="line">        deptList.remove(dept);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非叶子类，需要对此方法进行重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> deptList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="验证程序"><a href="#验证程序" class="headerlink" title="验证程序"></a>验证程序</h2><p>在此程序中，先构造了部门B、部门D、部门E、部门F、然后用部门E、部门F组成部门C、再用部门B、部门C、部门D组成部门A，从而完成部门的层次结构构造。然后遍历输出部门A的组织结构，再遍历输出部门B的组织结构，最后遍历输出部门C的组织结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestComposite</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化叶子类</span></span><br><span class="line">        <span class="type">Dept</span> <span class="variable">deptB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeptLeaf</span>(<span class="string">&quot;Deptartment B&quot;</span>);</span><br><span class="line">        <span class="type">Dept</span> <span class="variable">deptD</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeptLeaf</span>(<span class="string">&quot;Deptartment D&quot;</span>);</span><br><span class="line">        <span class="type">Dept</span> <span class="variable">deptE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeptLeaf</span>(<span class="string">&quot;Deptartment E&quot;</span>);</span><br><span class="line">        <span class="type">Dept</span> <span class="variable">deptF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeptLeaf</span>(<span class="string">&quot;Deptartment F&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化非叶子类</span></span><br><span class="line">        <span class="type">Dept</span> <span class="variable">deptC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeptComposite</span>(<span class="string">&quot;Deptartment C&quot;</span>);</span><br><span class="line">        deptC.add(deptE);</span><br><span class="line">        deptC.add(deptF);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Dept</span> <span class="variable">deptA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeptComposite</span>(<span class="string">&quot;Deptartment A&quot;</span>);</span><br><span class="line">        deptA.add(deptB);</span><br><span class="line">        deptA.add(deptC);</span><br><span class="line">        deptA.add(deptD);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对非叶子类A、叶子类B、非叶子类C进行遍历。可以看出，调用的是同一个接口</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----traversal Department A----&quot;</span>);</span><br><span class="line">        deptA.description();</span><br><span class="line">        System.out.println(<span class="string">&quot;----traversal Department B----&quot;</span>);</span><br><span class="line">        deptB.description();</span><br><span class="line">        System.out.println(<span class="string">&quot;----traversal Department C----&quot;</span>);</span><br><span class="line">        deptC.description();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/designPattern/compositePattern/sampleOutput.png" alt="组合模式例子输出结果"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Eric Freeman等，Head First 设计模式（中文版）[M]，北京：中国电力出版社，2007</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰者模式</title>
    <url>/design-pattern/decorator-pattern/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方法。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;——《Head First 设计模式》</p>
</blockquote>
<p>也就是说，装饰者模式是对原有功能类增加一些新的功能（行为）。但是为原有功能类增加新的功能行为，继承或组合也能做法，为什么要使用装饰者模式呢？这是因为要对原有功能类动态地同时增加多个功能行为（包括相同行为或不同行为），单独使用继承或组合实现将产生大量的子类（“类爆炸”），而使用装饰者模式则可以在保持良好的扩展性的同时避免“类爆炸”情况的出现。</p>
<span id="more"></span>

<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul>
<li>装饰者和被装饰者继承同一个基类。因为装饰者必须能够取代被装饰者，这里利用继承达到“类型匹配”，而不是利用继承获取“行为”</li>
<li>装饰者拥有(has a)一个与被装饰者相同的基类类型属性</li>
<li>可以用一个或多个装饰者类包装同一个对象</li>
<li>装饰者可以在所委托被装饰者的行为之前或行为之后或行为之前与之后加上自己的行为，以达到特定的目的</li>
</ul>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/decoratorPatternUML.png" alt="装饰者模式类图"></p>
<blockquote>
<p>说明：此图来源于《Head First 设计模式》</p>
</blockquote>
<p>为什么装饰者类和被装饰者需要继承同一个基础类呢？主要有两个方面的原因。第一，装饰者必须能够取代被装饰者；第二，如果需要多个装饰对象对被装饰对象进行装饰（假设A是被装饰者，B和C用来装饰A），如果不使用继承，则先用B装饰A再用C装饰B时，需要B拥有A的对象，C拥有B的对象；而先用C装饰A再用B装饰C时，需要C拥有A的对象，B拥有C的对象，这使得装饰的顺序依赖于类的实现。而如果使用了继承，则只需要B和C同时拥有A的对象，然后在使用的地方用调用的顺序来完成装饰的顺序，这样不用破坏原有的类，有良好的扩展性。</p>
<p>为什么装饰者需要拥有(has a)一个和被装饰者相同的基础类类型作为自己属性呢？主要是考虑多个不同的被装饰者的情况，如果使用继承，则装饰者必须继承自被装饰者，此时只能装饰一个类，而使用组合，则装饰者可以同时装饰多个类。这里也算是应用了策略模式吧。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>此处以射击类游戏为例。假设游戏中有Alice和Bob两名游戏玩家，有刀和枪两种武器，一个游戏玩家可以装备相同或不同的武器，进而攻击其他人。</p>
<h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><p><img src="/images/decoratorPatternSampleUML.png" alt="装饰者模式例子类图"></p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>Person类是所有类的基类，主要提供两个抽象方法，供子类具体实现。当然，这个抽象类也可以用接口表示，但是装饰者模式中一般用抽象类当基类，所以此处也用抽象基类表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;   <span class="comment">// 描述装备信息</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;             <span class="comment">// 攻击行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="角色类"><a href="#角色类" class="headerlink" title="角色类"></a>角色类</h2><p>有两个角色，Alice和Bob，分别继承抽象基类Person，实现自己的独特行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Alice</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Alice: &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Alice attacking with: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bob</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bob: &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Bob attacking with: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="装饰者基类"><a href="#装饰者基类" class="headerlink" title="装饰者基类"></a>装饰者基类</h2><p>WeaponDecorator是装饰者基类，其他的装饰者类继承此类。此类拥有Person类作为一个属性，这样就能对具体的person子类进行额外的封装， 加上额外的功能，以达到目的。</p>
<p>当然，也可以不使用此类，直接让装饰者子类继承自Person，并在每个装饰者子类中独自维护Person属性，这样也能达到同样的目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeaponDecorator</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Person person;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeaponDecorator</span><span class="params">(Person person)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> person.getDescription() + <span class="string">&quot;[no weapons!] &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        person.attack();</span><br><span class="line">        System.out.print(<span class="string">&quot;[bare arms]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="武器类"><a href="#武器类" class="headerlink" title="武器类"></a>武器类</h2><p>武器类有两个，Gun和Knife，这两个类都继承了装饰者基类WeaponDecorator，并使用从WeaponDecorator继承的person属性得到要装饰的具体对象，从而获取要装饰的具体对象的具体行为，并在此基础上增加额外的操作达到扩展不同功能的目的。</p>
<p>当然，也可以不继承装饰者基类WeaponDecorator，直接继承自Person类，并在各自的类中维护person属性，这样也能得到同样的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span> <span class="keyword">extends</span> <span class="title class_">WeaponDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Gun</span><span class="params">(Person person)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(person);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> person.getDescription() + <span class="string">&quot;[gun] &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        person.attack();</span><br><span class="line">        System.out.print(<span class="string">&quot;[gun] &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Knife</span> <span class="keyword">extends</span> <span class="title class_">WeaponDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Knife</span><span class="params">(Person person)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(person);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> person.getDescription() + <span class="string">&quot;[knife] &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        person.attack();</span><br><span class="line">        System.out.print(<span class="string">&quot;[knife] &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="验证程序"><a href="#验证程序" class="headerlink" title="验证程序"></a>验证程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化角色</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Game Begin!----&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">alice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Alice</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">bob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bob</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Alice装备了一把刀</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Alice take a knife----&quot;</span>);</span><br><span class="line">        alice = <span class="keyword">new</span> <span class="title class_">Knife</span>(alice);</span><br><span class="line">        System.out.println(alice.getDescription());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Bob装备了一支枪</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Bob take a gun----&quot;</span>);</span><br><span class="line">        bob = <span class="keyword">new</span> <span class="title class_">Gun</span>(bob);</span><br><span class="line">        System.out.println(bob.getDescription());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Alice用现有的装备攻击了Bob</span></span><br><span class="line">        alice.attack();</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Bob用现有装备对Alice进行反击</span></span><br><span class="line">        bob.attack();</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Alice发现地上有一把枪，拿起枪，和刀同时攻击Bob</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Alice take a gun----&quot;</span>);</span><br><span class="line">        alice = <span class="keyword">new</span> <span class="title class_">Gun</span>(alice);</span><br><span class="line">        System.out.println(alice.getDescription());</span><br><span class="line">        alice.attack();</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Bob发现地上还有一把枪，也拿起了枪，用两把枪同时攻击Alice，给Alice致命一击</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Bob take a gun----&quot;</span>);</span><br><span class="line">        bob = <span class="keyword">new</span> <span class="title class_">Gun</span>(bob);</span><br><span class="line">        System.out.println(bob.getDescription());</span><br><span class="line">        bob.attack();</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----Game Over! Bob Win!----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/decoratorPatternSampleOutput.png" alt="装饰者模式例子输出结果"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>装饰者模式在避免“类爆炸”的同时保持扩展性，但是也有可能产生多个小的装饰者类，在对被装饰者运用多个装饰者对象进行连续组合时，不能很清晰地看出这是运用了装饰者模式。即便装饰者模式存在者一些不足，但是其仍然是软件设计开发中的一种良好的实践。java类库中的IO流也使用了装饰者模式进行流功能的扩展，如下图所示</p>
<p><img src="/images/decoratorPatternIOUML.png" alt="java类库中IO流的装饰者模式"></p>
<blockquote>
<p>说明：此图来源于《Head First 设计模式》</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Eric Freeman等，Head First 设计模式（中文版）[M]，北京：中国电力出版社，2007</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/design-pattern/facade-pattern/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<p>外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;——《Head First 设计模式》</p>
</blockquote>
<p>外观模式并没有“封装”子系统，只是额外增加一个类，在类中提供简化的接口完成对子系统中某些功能的实现，在提供简化接口的同时，并没有限制对子系统的访问，其依然将系统完整的功能暴露出来，供有需要的程序采用比较负载的方式访问子系统。</p>
<span id="more"></span>

<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/designPattern/facadePattern/UML.png" alt="外观模式类图"></p>
<blockquote>
<p>说明：此图来源于《Head First 设计模式》</p>
</blockquote>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>此处以竞技类游戏为例，假设游戏中有两种武器：刀和枪。刀有刺杀行为，枪有装弹和开枪行为。假设要杀死一个人需要先用刀刺杀对方，然后装弹开枪，最后再补上一刀。</p>
<h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><p><img src="/images/designPattern/facadePattern/facadePatternSampleUML.png" alt="外观模式例子类图"></p>
<h2 id="子系统中的类"><a href="#子系统中的类" class="headerlink" title="子系统中的类"></a>子系统中的类</h2><p>子系统中有两个类：Knife和Gun，分别表示刀和枪两种武器。在Knife类中有一个stab方法用来表示刺杀行为，在Gun类中有loadBullets表示装子弹行为，用fire表示开枪行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Knife</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stab</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Knife stabbing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBullets</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Loading bullets...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Gun firing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="外观类"><a href="#外观类" class="headerlink" title="外观类"></a>外观类</h2><p>外观类提供了一个attack的接口供外部调用，该接口实现了杀死一个人的功能：先用刀刺杀，然后装弹开枪，最后再补上一刀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MurderFacade</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Knife knife;</span><br><span class="line">    <span class="keyword">private</span> Gun gun;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MurderFacade</span><span class="params">(Knife knife, Gun gun)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.knife = knife;</span><br><span class="line">        <span class="built_in">this</span>.gun = gun;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        knife.stab();</span><br><span class="line">        gun.loadBullets();</span><br><span class="line">        gun.fire();</span><br><span class="line">        knife.stab();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="验证程序"><a href="#验证程序" class="headerlink" title="验证程序"></a>验证程序</h2><p>在不使用外观模式的情况下，要完整杀死一个人需要四个步骤：knife.stab()、gun.loadBullets()、gun.fire()、knife.stab()，涉及两个类：Gun和Knife。而使用外观模式则只需要一个步骤：murderFacade.attack()，涉及一个类MurderFacade。显然，使用外观模式会让调用者更方便。另外，即使提供了外观模式，调用者也可以不使用外观类提供的接口，直接调用子系统的相应的方法进行组合完成目的（虽然有点繁琐）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFacade</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Knife</span> <span class="variable">knife</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Knife</span>();</span><br><span class="line">        <span class="type">Gun</span> <span class="variable">gun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gun</span>();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----without using facade pattern----&quot;</span>);</span><br><span class="line">        knife.stab();</span><br><span class="line">        gun.loadBullets();</span><br><span class="line">        gun.fire();</span><br><span class="line">        knife.stab();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----using facade pattern----&quot;</span>);</span><br><span class="line">        <span class="type">MurderFacade</span> <span class="variable">murderFacade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MurderFacade</span>(knife, gun);</span><br><span class="line">        murderFacade.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/designPattern/facadePattern/sampleOutput.png" alt="外观模式例子输出结果"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>外观模式虽然在提供简化接口的同时并不限制外界对子系统的直接访问，但是如果外界直接调用的是外观类提供的接口而不是直接访问的子系统，这样就能将外部程序与子系统的实现进行解耦，当子系统发生变化时，只需要改变外观类接口的实现，不用让外部调用程序也相应发生改变。</p>
<p>更进一步，如果提供了外观类接口，同时让外部调用程序只调用外观类的接口而不直接调用子系统中的接口，这样就能很好地将系统进行隔离。这很适合用于将restful接口封装成一个外观类提供给外部调用，从而隔离本系统，达到系统（模块）之间的解耦。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Eric Freeman等，Head First 设计模式（中文版）[M]，北京：中国电力出版社，2007</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/design-pattern/factory-pattern/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>工厂模式主要是将创建对象这一个步骤进行封装，从而将客户程序从具体类中解耦。工厂模式主要有三种：简单工厂、工厂方法模式、抽象工程模式。</p>
<span id="more"></span>

<h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><p>严格来说，简单工厂并不是真正的设计模式，但是由于其也封装了对象的创建，解耦了客户程序与具体实现类，且日常中也将此种情况作为工厂模式的一种，因此这里也将其归类为工厂模式并一起介绍比较。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="/images/designPattern/factoryPattern/simpleFactoryUML.png" alt="简单工厂类图"></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>此处以生产服装为例，假设有两种类型的服装，一种是衬衣，一种是裤子。服装的工厂类根据接收的参数判断是生产一件衬衣还是生产一件裤子。</p>
<h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="/images/designPattern/factoryPattern/simpleFactorySampleUML.png" alt="简单工厂例子类图"></p>
<h3 id="Clothes抽象类"><a href="#Clothes抽象类" class="headerlink" title="Clothes抽象类"></a>Clothes抽象类</h3><p>Clothes抽象类主要是定义了两个常量用于判断服装的类型，一个私有变量用于保存服装的类型，一个protected变量用于在子类中对其进行修改，同时定义了一个抽象方法用于子类的重写，最后重写了toString方法输出类的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLOTHES_TYPE_TROUSERS</span> <span class="operator">=</span> <span class="string">&quot;trousers&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLOTHES_TYPE_SHIRT</span> <span class="operator">=</span> <span class="string">&quot;shirt&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> price;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initPrice</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Clothes</span><span class="params">(String type)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Clothes [type=&quot;</span> + type + <span class="string">&quot;, price=&quot;</span> + price + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Clothes子类"><a href="#Clothes子类" class="headerlink" title="Clothes子类"></a>Clothes子类</h3><p>Clothes有两个子类，一个用于表示裤子的Trousers，另一个用于表示衬衣的Shirt。在子类的构造函数中，调用了父类构造函数对type变量进行赋值，然后调用重写过后的initPrice方法对price进行赋值，从而达到不同子类属性不同的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trousers</span> <span class="keyword">extends</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trousers</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(Clothes.CLOTHES_TYPE_TROUSERS);</span><br><span class="line">        initPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initPrice</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        price = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shirt</span> <span class="keyword">extends</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shirt</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(Clothes.CLOTHES_TYPE_SHIRT);</span><br><span class="line">        initPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initPrice</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        price = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Clothes工厂类"><a href="#Clothes工厂类" class="headerlink" title="Clothes工厂类"></a>Clothes工厂类</h3><p>Clothes工厂类只有一个方法<code>makeClothes</code>，这个方法接收一个参数，用于判断生产服装的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClothesFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Clothes <span class="title function_">makeClothes</span><span class="params">(String type)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果新增了服装类型，需要在此增加条件判断分支</span></span><br><span class="line">        <span class="keyword">if</span> (Clothes.CLOTHES_TYPE_SHIRT.equals(type))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Shirt</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Clothes.CLOTHES_TYPE_TROUSERS.equals(type))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Trousers</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证程序"><a href="#验证程序" class="headerlink" title="验证程序"></a>验证程序</h3><p>首先，获取一个工厂类，然后用工厂类生产一件衬衣，再用工厂类生产一件裤子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果要获取新增的服装类型，只需要将新的参数值传给makeClothes方法，其他保持不变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----init clothesFactory----&quot;</span>);</span><br><span class="line">        <span class="type">ClothesFactory</span> <span class="variable">clothesFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClothesFactory</span>();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----making a shirt----&quot;</span>);</span><br><span class="line">        <span class="type">Clothes</span> <span class="variable">shirt</span> <span class="operator">=</span> clothesFactory.makeClothes(Clothes.CLOTHES_TYPE_SHIRT);</span><br><span class="line">        System.out.println(shirt);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----making a trousers----&quot;</span>);</span><br><span class="line">        <span class="type">Clothes</span> <span class="variable">trousers</span> <span class="operator">=</span> clothesFactory.makeClothes(Clothes.CLOTHES_TYPE_TROUSERS);</span><br><span class="line">        System.out.println(trousers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/designPattern/factoryPattern/simpleFactorySampleOutput.png" alt="简单工厂例子输出结果"></p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类将实例化推迟到子类。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;——《Head First 设计模式》</p>
</blockquote>
<p>相比简单工厂，工厂方法模式比简单工厂多了一个工厂抽象类，在工厂抽象类中定义了创建工厂的方法，在工厂子类中实现创建工厂的方法，在实现创建工厂的方法里面再实现创建具体对象的功能。</p>
<h2 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h2><p><img src="/images/designPattern/factoryPattern/factoryMethodUML.png" alt="工厂方法模式类图"></p>
<blockquote>
<p>说明：此图来源于《Head First 设计模式》</p>
</blockquote>
<h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p>此处仍以简单工厂中的例子进行说明，只不过生产服装的工厂定义成一个抽象的类，再增加生产衬衫的工厂子类和生产裤子的工厂子类。</p>
<h3 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h3><p><img src="/images/designPattern/factoryPattern/factoryMethodSampleUML.png" alt="工厂方法模式例子类图"></p>
<h3 id="Clothes抽象类-1"><a href="#Clothes抽象类-1" class="headerlink" title="Clothes抽象类"></a>Clothes抽象类</h3><p>此类与简单工厂中的例子一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLOTHES_TYPE_TROUSERS</span> <span class="operator">=</span> <span class="string">&quot;trousers&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLOTHES_TYPE_SHIRT</span> <span class="operator">=</span> <span class="string">&quot;shirt&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> price;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initPrice</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Clothes</span><span class="params">(String type)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Clothes [type=&quot;</span> + type + <span class="string">&quot;, price=&quot;</span> + price + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Clothes子类-1"><a href="#Clothes子类-1" class="headerlink" title="Clothes子类"></a>Clothes子类</h3><p>这两类与简单工厂中的例子一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trousers</span> <span class="keyword">extends</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trousers</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(Clothes.CLOTHES_TYPE_TROUSERS);</span><br><span class="line">        initPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initPrice</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        price = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shirt</span> <span class="keyword">extends</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shirt</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(Clothes.CLOTHES_TYPE_SHIRT);</span><br><span class="line">        initPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initPrice</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        price = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Clothes工厂抽象类"><a href="#Clothes工厂抽象类" class="headerlink" title="Clothes工厂抽象类"></a>Clothes工厂抽象类</h3><p>与简单工厂的例子不同，Clothes工厂是一个抽象类，而不是一个具体的实现类，此抽象类中只有一个抽象方法用于表示创建一件服装，而具体的实现放在工厂子类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当然，也可以使用interface</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClothesFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果新增了服装类型，需要增加新的子类工厂实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Clothes <span class="title function_">makeClothes</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Clothes工厂子类"><a href="#Clothes工厂子类" class="headerlink" title="Clothes工厂子类"></a>Clothes工厂子类</h3><p>ShirtFactory和TrousersFactory是ClothesFactory的子类，分别实现工厂抽象方法makeClothes产生不同类型的服装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShirtFactory</span> <span class="keyword">extends</span> <span class="title class_">ClothesFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Clothes <span class="title function_">makeClothes</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Shirt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrousersFactory</span> <span class="keyword">extends</span> <span class="title class_">ClothesFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Clothes <span class="title function_">makeClothes</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Trousers</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证程序-1"><a href="#验证程序-1" class="headerlink" title="验证程序"></a>验证程序</h3><p>首先，获取衬衣工厂类，然后用衬衣工厂类生产一件衬衣；然后获取裤子工厂类，再用裤子工厂类生产一件裤子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果要获取新的衣服类型，只需要创建新衣服类型的工厂，其他保持不变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----init shirtFactory----&quot;</span>);</span><br><span class="line">        <span class="type">ClothesFactory</span> <span class="variable">shirtFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShirtFactory</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;---making a shirt----&quot;</span>);</span><br><span class="line">        <span class="type">Clothes</span> <span class="variable">shirt</span> <span class="operator">=</span> shirtFactory.makeClothes();</span><br><span class="line">        System.out.println(shirt);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----init trousersFactory----&quot;</span>);</span><br><span class="line">        <span class="type">ClothesFactory</span> <span class="variable">trousersFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrousersFactory</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;----making a trousers----&quot;</span>);</span><br><span class="line">        <span class="type">Clothes</span> <span class="variable">trousers</span> <span class="operator">=</span> trousersFactory.makeClothes();</span><br><span class="line">        System.out.println(trousers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/designPattern/factoryPattern/factoryMethodSampleOutput.png" alt="工厂方法模式例子输出结果"></p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;——《Head First 设计模式》</p>
</blockquote>
<p>与工厂方法不同的时，抽象工厂模式提供的是一个接口，里面包含了一组（多个）接口方法用于表示创建具体对象需要的一组方法（该对象需要由多个子对象组合而成），实现类需要同时实现这一组方法才能创建出具体的对象</p>
<h2 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h2><p><img src="/images/designPattern/factoryPattern/abstractFactoryUML.png" alt="抽象工厂模式类图"></p>
<blockquote>
<p>说明：此图来源于《Head First 设计模式》</p>
</blockquote>
<h2 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h2><p>此处仍以生产服装为例，只是此时生产一件服装后会附加赠送一件礼物，衬衣赠送领带，裤子赠送皮带，只有将服装和礼物同时弄好后才算一件服装商品真正完成。</p>
<h3 id="类图-5"><a href="#类图-5" class="headerlink" title="类图"></a>类图</h3><p><img src="/images/designPattern/factoryPattern/abstractFactorySampleUML.png" alt="抽象工厂模式例子类图"></p>
<h3 id="Clothes抽象类-2"><a href="#Clothes抽象类-2" class="headerlink" title="Clothes抽象类"></a>Clothes抽象类</h3><p>此类与前面简单工厂和工厂方法模式的例子相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLOTHES_TYPE_TROUSERS</span> <span class="operator">=</span> <span class="string">&quot;trousers&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLOTHES_TYPE_SHIRT</span> <span class="operator">=</span> <span class="string">&quot;shirt&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> price;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initPrice</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Clothes</span><span class="params">(String type)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Clothes [type=&quot;</span> + type + <span class="string">&quot;, price=&quot;</span> + price + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Clouthes子类"><a href="#Clouthes子类" class="headerlink" title="Clouthes子类"></a>Clouthes子类</h3><p>这两个类与前面简单工厂和工厂方法模式的例子相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trousers</span> <span class="keyword">extends</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trousers</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(Clothes.CLOTHES_TYPE_TROUSERS);</span><br><span class="line">        initPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initPrice</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        price = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shirt</span> <span class="keyword">extends</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shirt</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(Clothes.CLOTHES_TYPE_SHIRT);</span><br><span class="line">        initPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initPrice</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        price = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Gift抽象类"><a href="#Gift抽象类" class="headerlink" title="Gift抽象类"></a>Gift抽象类</h3><p>这个类是本例新增的，用于表示随服装赠送的礼物。此类只有一个抽象方法，用于描述礼物，同时重写<code>toString</code>方法用于描述具体的礼物信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Gift</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Gift [&quot;</span> + getDescription() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Gift子类"><a href="#Gift子类" class="headerlink" title="Gift子类"></a>Gift子类</h3><p>这两个子类也是本例新增的。Gift有两个子类，一个用于表示皮带的Belt，另一个用于表示领带的Tie。在子类中，分别实现了父类的抽象方法，描述自己的独特信息，供父类<code>toString</code>方法调用，从而输出具体的礼物信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Belt</span> <span class="keyword">extends</span> <span class="title class_">Gift</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Belt&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tie</span> <span class="keyword">extends</span> <span class="title class_">Gift</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Tie&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Clothes工厂抽象类-1"><a href="#Clothes工厂抽象类-1" class="headerlink" title="Clothes工厂抽象类"></a>Clothes工厂抽象类</h3><p>与工厂方法模式相比，此例的工厂抽象类新增了<code>makeGift</code>抽象方法，因此此时需要在生产服装后也生产礼物，只有当这两者完成时才算一件服装商品完成。另外，也把<code>ClothesFactory</code>由抽象类变成了接口的方式（当然，interface也可以用工厂方法模式的abstract方式替换）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当然，此处也可以用抽象类</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ClothesFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果新增了服装类型，需要增加新的子类工厂实现</span></span><br><span class="line">    Clothes <span class="title function_">makeClothes</span><span class="params">()</span>;</span><br><span class="line">    Gift <span class="title function_">makeGift</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Clothes工厂子类-1"><a href="#Clothes工厂子类-1" class="headerlink" title="Clothes工厂子类"></a>Clothes工厂子类</h3><p>与工厂方法模式相比，这两个类只是新增了实现ClothesFactory的新抽象方法，其他并无差异</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShirtFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothesFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Clothes <span class="title function_">makeClothes</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Shirt</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Gift <span class="title function_">makeGift</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tie</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrousersFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothesFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Clothes <span class="title function_">makeClothes</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Trousers</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Gift <span class="title function_">makeGift</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Belt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证程序-2"><a href="#验证程序-2" class="headerlink" title="验证程序"></a>验证程序</h3><p>首先，获取一个衬衣工厂类，用衬衣工厂类生产一件衬衣及对应的礼物（领带）；然后获取一个裤子工厂类，用裤子工厂类生产一件裤子及对应的礼物（皮带）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果要获取新的服装类型，只需要创建新服装类型的工厂，其他保持不变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----init shirtFactory----&quot;</span>);</span><br><span class="line">        <span class="type">ClothesFactory</span> <span class="variable">shirtFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShirtFactory</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;----making a shirt and giving a tie as present----&quot;</span>);</span><br><span class="line">        System.out.println(shirtFactory.makeClothes());</span><br><span class="line">        System.out.println(shirtFactory.makeGift());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----init trousersFactory----&quot;</span>);</span><br><span class="line">        <span class="type">ClothesFactory</span> <span class="variable">trousersFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrousersFactory</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;----making a trousers and giving a belt as present----&quot;</span>);</span><br><span class="line">        System.out.println(trousersFactory.makeClothes());</span><br><span class="line">        System.out.println(trousersFactory.makeGift());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/designPattern/factoryPattern/abstractFactorySampleOutput.png" alt="抽象工厂模式例子输出结果"></p>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><table>
<thead>
<tr>
<th>简单工厂</th>
<th>工厂方法模式</th>
<th>抽象工厂模式</th>
</tr>
</thead>
<tbody><tr>
<td>易于实现</td>
<td>实现起来相对繁琐</td>
<td>实现起来相对繁琐</td>
</tr>
<tr>
<td>不易扩展，需要在工厂类中增加条件判断语句</td>
<td>易于扩展，只需要继承抽象工厂，新实现工厂子类即可</td>
<td>易于扩展，只需要新建工厂子类，实现接口方法即可</td>
</tr>
<tr>
<td>无继承、无组合</td>
<td>使用继承，单一接口</td>
<td>使用组合，多个接口，将多个对象（对象家族）创建放在同一个接口中。对每个单独的接口，使用工厂方法模式实现</td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Eric Freeman等，Head First 设计模式（中文版）[M]，北京：中国电力出版社，2007</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/design-pattern/iterator-pattern/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;——《Head First 设计模式》</p>
</blockquote>
<span id="more"></span>

<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/designPattern/iteratorPattern/UML.png" alt="迭代器模式类图"></p>
<blockquote>
<p>说明：此图参考《Head First 设计模式》画出</p>
</blockquote>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>此处以衣服类中的衬衣和裤子进行遍历为例，分别用自己实现的迭代器和使用java库中提供的迭代器进行说明</p>
<h2 id="自己定义迭代器"><a href="#自己定义迭代器" class="headerlink" title="自己定义迭代器"></a>自己定义迭代器</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="/images/designPattern/iteratorPattern/sampleUML.png" alt="迭代器模式例子1类图"></p>
<h3 id="迭代器接口"><a href="#迭代器接口" class="headerlink" title="迭代器接口"></a>迭代器接口</h3><p>此处接口中有两个迭代器中的两个经典常用函数，<code>hasNext</code>用于判断是否还有下一个元素，<code>next</code>用于获取下一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    Object <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="聚合类接口"><a href="#聚合类接口" class="headerlink" title="聚合类接口"></a>聚合类接口</h3><p>聚合类接口主要提供一个函数用于获取迭代器对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line">    Iterator <span class="title function_">createIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口具体实现类"><a href="#接口具体实现类" class="headerlink" title="接口具体实现类"></a>接口具体实现类</h3><p>此处将迭代器实现类放在聚合类的实现类中作为内部类使用，方便获取聚合类中的数据结构对象数据，能够有更好地封装效果，虽然这违反了单一责任原则。</p>
<p>在Shirt类中，使用的数据结构是数组，为简单起见，在数组中只设置了三个对象。在Trousers类中，使用的数据结构是ArrayList，为简单起见，也在List只设置了三个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shirt</span> <span class="keyword">implements</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] colors = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;red&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;black&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUM</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShirtIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部类，实现Iterator接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ShirtIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentIndex &gt;= <span class="number">0</span> &amp;&amp; currentIndex &lt; MAX_NUM)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> colors[currentIndex];</span><br><span class="line">            currentIndex++;</span><br><span class="line">            <span class="keyword">return</span> color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trousers</span> <span class="keyword">implements</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; colors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trousers</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        colors.add(<span class="string">&quot;white&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;green&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TrousersIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部类，实现Iterator接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TrousersIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentIndex &gt;= <span class="number">0</span> &amp;&amp; currentIndex &lt; colors.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> colors.get(currentIndex);</span><br><span class="line">            currentIndex++;</span><br><span class="line">            <span class="keyword">return</span> color;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证程序"><a href="#验证程序" class="headerlink" title="验证程序"></a>验证程序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 遍历输出迭代器每一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printIteratorObject</span><span class="params">(Iterator iterator)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Clothes</span> <span class="variable">shirt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shirt</span>();</span><br><span class="line">        <span class="type">Clothes</span> <span class="variable">trousers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trousers</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;----traversal shirt----&quot;</span>);</span><br><span class="line">        printIteratorObject(shirt.createIterator());</span><br><span class="line">        System.out.println(<span class="string">&quot;----traversal trousers----&quot;</span>);</span><br><span class="line">        printIteratorObject(trousers.createIterator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/designPattern/iteratorPattern/sampleOutput.png" alt="迭代器模式例子1输出结果"></p>
<h2 id="使用java类库迭代器"><a href="#使用java类库迭代器" class="headerlink" title="使用java类库迭代器"></a>使用java类库迭代器</h2><p>仍然以上面的例子，使用java类库迭代器进行实现。此时不需要自己定义迭代器接口。在java类库中，List已经实现了迭代器，直接调用<code>iterator()</code>函数即可；而数组没有实现迭代器，所以仍然需要自己手动实现。改动后的Clothes接口类、Shirt类和Trousers类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用java类库中的迭代器</span></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line">    Iterator&lt;?&gt; createIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shirt</span> <span class="keyword">implements</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] colors = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;red&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;black&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUM</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;?&gt; createIterator()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShirtIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部类，实现Iterator接口，java类库中数组没有实现迭代器，需要自己手动实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ShirtIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Object&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentIndex &gt;= <span class="number">0</span> &amp;&amp; currentIndex &lt; MAX_NUM)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> colors[currentIndex];</span><br><span class="line">            currentIndex++;</span><br><span class="line">            <span class="keyword">return</span> color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trousers</span> <span class="keyword">implements</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; colors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trousers</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        colors.add(<span class="string">&quot;white&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;green&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;?&gt; createIterator()</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">// 直接调用java中list的迭代器接口</span></span><br><span class="line">        <span class="keyword">return</span> colors.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证程序跟上面的例子相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 遍历输出迭代器每一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printIteratorObject</span><span class="params">(Iterator&lt;?&gt; iterator)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Clothes</span> <span class="variable">shirt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shirt</span>();</span><br><span class="line">        <span class="type">Clothes</span> <span class="variable">trousers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trousers</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;----traversal shirt----&quot;</span>);</span><br><span class="line">        printIteratorObject(shirt.createIterator());</span><br><span class="line">        System.out.println(<span class="string">&quot;----traversal trousers----&quot;</span>);</span><br><span class="line">        printIteratorObject(trousers.createIterator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/designPattern/iteratorPattern/sample2Output.png" alt="迭代器模式例子2输出结果"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>迭代器设计模式把在元素之间游走的责任交给迭代器而不是聚合对象，这不仅让聚合的接口和实现变得更简洁，也可以让聚合更专注在它所应该专注的事情上面，而不必去理会遍历的事情。这虽然对聚合类的数据结构进行了封装，但是由于java类库中已经对集合类提供了迭代器的实现，在现实中更多的是直接调用集合类提供的迭代器方法，自己实现迭代器的场景还是比较少的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Eric Freeman等，Head First 设计模式（中文版）[M]，北京：中国电力出版社，2007</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/design-pattern/observer-pattern/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>观察者模式定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。观察者模式主要有两个对象，主题（被观察者）和订阅者（观察者），这是一个一对多的关系，同一个主题可以有多个订阅者，当主题发生改变时，每个订阅者都能收到消息通知并执行对应的逻辑。</p>
<span id="more"></span>

<p>对于主题（被观察者）而言，需要提供注册、去注册、通知观察者的功能。</p>
<p>对于订阅者（观察者）而言，需要提供统一的接口让主题在通知时调用。</p>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/observerPatternUML.png" alt="观察者设计模式类图"></p>
<blockquote>
<p>说明：此图来源于《Head First 设计模式》</p>
</blockquote>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>此处以订阅报纸为例，分别用自写的观察者模式和 java 内置的观察者模式实现。</p>
<p>假设有一份报纸Paper，有三个订阅者Tom、Amy和Alice。Tom和Amy一开始就订阅了报纸，并在报纸更新时分别输出自己获取到报纸的时间和报纸的标题。Alice在后面加入订阅报纸行列，在接收一次报纸更新后退出订阅。</p>
<h2 id="自己实现观察者模式"><a href="#自己实现观察者模式" class="headerlink" title="自己实现观察者模式"></a>自己实现观察者模式</h2><h3 id="定义观察者接口"><a href="#定义观察者接口" class="headerlink" title="定义观察者接口"></a>定义观察者接口</h3><p>此接口只有一个函数，用于主题更新通知观察者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String title, String content)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义主题接口"><a href="#定义主题接口" class="headerlink" title="定义主题接口"></a>定义主题接口</h3><p>此接口主要有三个函数，一个用于注册增加观察者，一个用户退订移除观察者，一个用户改变时通知所有观察者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现Paper类"><a href="#实现Paper类" class="headerlink" title="实现Paper类"></a>实现Paper类</h3><p>Paper类作为被观察的对象，需要实现主题接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Paper</span> <span class="keyword">implements</span> <span class="title class_">Subject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 产生新报纸，通知所有订阅者取阅</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeNewPaper</span><span class="params">(String title, String content)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将订阅者加入队列中，如果已经存在则不加入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!observers.contains(observer))</span><br><span class="line">        &#123;</span><br><span class="line">            observers.add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除订阅者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有订阅者取阅报纸</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers)</span><br><span class="line">        &#123;</span><br><span class="line">            observer.update(title, content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现订阅者类"><a href="#实现订阅者类" class="headerlink" title="实现订阅者类"></a>实现订阅者类</h3><p>订阅者（Tom、Amy、Alice）需要实现Observer接口中的update函数，以便报纸更新时能获取到通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tom</span> <span class="keyword">implements</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String title, String content)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;I&#x27;m Tom. I receive a paper&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;[title: &quot;</span> + title);</span><br><span class="line">        System.out.print(<span class="string">&quot;, content: &quot;</span> + content + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot; at &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Amy</span> <span class="keyword">implements</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String title, String content)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;I&#x27;m Amy. I receive a paper&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;[title: &quot;</span> + title);</span><br><span class="line">        System.out.print(<span class="string">&quot;, content: &quot;</span> + content + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot; at &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alice</span> <span class="keyword">implements</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String title, String content)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;I&#x27;m Alice. I just try to subscribe a paper, and I receive a paper&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;[title: &quot;</span> + title);</span><br><span class="line">        System.out.print(<span class="string">&quot;, content: &quot;</span> + content + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot; at &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证程序"><a href="#验证程序" class="headerlink" title="验证程序"></a>验证程序</h3><p>首先，先让Tom和Amy订阅报纸，然后生产一份报纸，此时只有Tom和Amy收到了报纸，而Alice没有收到报纸。</p>
<p>然后，Alice觉得报纸也挺有趣的，决定订阅报纸，于是Alice加入了观察者队列中，这样生产第二份报纸时，Tom、Amy、Alice都能收到报纸。</p>
<p>接着，Alice觉得报纸不符合自己的兴趣，决定退订报纸，于是Alice从观察者队列中移除出来，这样生产第三份报纸时，Tom、Amy能收到报纸，而Alice已经收不到报纸了。</p>
<p>程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="type">Paper</span> <span class="variable">paper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paper</span>();</span><br><span class="line">        <span class="type">Tom</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tom</span>();</span><br><span class="line">        <span class="type">Amy</span> <span class="variable">amy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Amy</span>();</span><br><span class="line">        <span class="type">Alice</span> <span class="variable">alice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Alice</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Tom和Amy订阅Paper</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Tom subscribe the paper----&quot;</span>);</span><br><span class="line">        paper.registerObserver(tom);</span><br><span class="line">        System.out.println(<span class="string">&quot;----Amy subscribe the paper----&quot;</span>);</span><br><span class="line">        paper.registerObserver(amy);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产一份报纸，Tom和Amy收到报纸, Alice没订阅报纸，没收到通知</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----make first paper: Tom and Amy will receive，but Alice not----&quot;</span>);</span><br><span class="line">        paper.makeNewPaper(<span class="string">&quot;Fisrt Paper&quot;</span>, <span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Alice觉得报纸不错，要订阅报纸</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Alice subscribe the paper----&quot;</span>);</span><br><span class="line">        paper.registerObserver(alice);</span><br><span class="line">        paper.registerObserver(alice);</span><br><span class="line">        paper.registerObserver(alice);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产第二份报纸，Tom、Amy、Alice都收到报纸</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----make secode paper: Tom、Amy and Alice will receive----&quot;</span>);</span><br><span class="line">        paper.makeNewPaper(<span class="string">&quot;Second Paper&quot;</span>, <span class="string">&quot;Weclome Alice to join us!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Alice觉得报纸不适合自己，决定退订</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Alice unsubscribe the paper----&quot;</span>);</span><br><span class="line">        paper.removeObserver(alice);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产第三份报纸，Tom和Amy能收到，而Alice已经收不到了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----make third paper: Tom and Amy will receive，but Alice not----&quot;</span>);</span><br><span class="line">        paper.makeNewPaper(<span class="string">&quot;Third Paper&quot;</span>, <span class="string">&quot;Sorry for Alice leaving!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/observerPatternOutput1.png" alt="观察者模式程序输出结果"></p>
<h2 id="利用-java-内置观察者模式"><a href="#利用-java-内置观察者模式" class="headerlink" title="利用 java 内置观察者模式"></a>利用 java 内置观察者模式</h2><p>java中已经提供了Observable类和Observer接口实现观察者模式。只要被观察者对象继承Observable，观察者实现Observer接口即可。</p>
<h3 id="实现Paper"><a href="#实现Paper" class="headerlink" title="实现Paper"></a>实现Paper</h3><p>使用java内置的观察者模式时，在被观察者类中需要引入<code>java.util.Observable</code>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Paper</span> <span class="keyword">extends</span> <span class="title class_">Observable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 产生新报纸，通知所有订阅者取阅</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeNewPaper</span><span class="params">(String title, String content)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知观察者，这两个函数都是Observable类中的函数</span></span><br><span class="line">        <span class="comment">// setChanged必须调用，否则直接调用notifyObservers并不会通知观察者</span></span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下函数主要是方便观察者获取相关数据</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：在通知观察者时，需要先调用<code>setChanged</code>函数，再调用<code>notifyObservers</code>函数，否则直接调用<code>notifyObservers</code>函数将不会通知观察者。如下是<code>java.util.Observable</code>类中的部分源码，从中可以证实以上结论。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setChanged</span><span class="params">()</span> &#123;</span><br><span class="line">    changed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">    notifyObservers(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Object arg)</span> &#123;</span><br><span class="line">    Object[] arrLocal;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!changed)  <span class="comment">// 如果状态未改变，则直接返回，不会通知观察者 </span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        arrLocal = obs.toArray();</span><br><span class="line">        clearChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        ((Observer)arrLocal[i]).update(<span class="built_in">this</span>, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现订阅者类-1"><a href="#实现订阅者类-1" class="headerlink" title="实现订阅者类"></a>实现订阅者类</h3><p>使用java内置的观察者模式时，在观察者类中需要引入<code>java.util.Observer</code>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tom</span> <span class="keyword">implements</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 被观察者状态更新，调用此函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable observable, Object obj)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;I&#x27;m Tom. I receive a paper&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;[title: &quot;</span> + ((Paper)observable).getTitle());</span><br><span class="line">        System.out.print(<span class="string">&quot;, content: &quot;</span> + ((Paper)observable).getContent() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot; at &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Amy</span> <span class="keyword">implements</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 被观察者状态更新，调用此函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable observable, Object obj)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;I&#x27;m Amy. I receive a paper&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;[title: &quot;</span> + ((Paper)observable).getTitle());</span><br><span class="line">        System.out.print(<span class="string">&quot;, content: &quot;</span> + ((Paper)observable).getContent() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot; at &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alice</span> <span class="keyword">implements</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 被观察者状态更新，调用此函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable observable, Object obj)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;I&#x27;m Alice. I just try to subscribe a paper, and I receive a paper&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;[title: &quot;</span> + ((Paper)observable).getTitle());</span><br><span class="line">        System.out.print(<span class="string">&quot;, content: &quot;</span> + ((Paper)observable).getContent() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot; at &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证程序-1"><a href="#验证程序-1" class="headerlink" title="验证程序"></a>验证程序</h3><p>首先，先让Tom和Amy订阅报纸，然后生产一份报纸，此时只有Tom和Amy收到了报纸，而Alice没有收到报纸。</p>
<p>然后，Alice觉得报纸也挺有趣的，决定订阅报纸，于是Alice加入了观察者队列中，这样生产第二份报纸时，Tom、Amy、Alice都能收到报纸。</p>
<p>接着，Alice觉得报纸不符合自己的兴趣，决定退订报纸，于是Alice从观察者队列中移除出来，这样生产第三份报纸时，Tom、Amy能收到报纸，而Alice已经收不到报纸了。</p>
<p>程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="type">Paper</span> <span class="variable">paper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paper</span>();</span><br><span class="line">        <span class="type">Tom</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tom</span>();</span><br><span class="line">        <span class="type">Amy</span> <span class="variable">amy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Amy</span>();</span><br><span class="line">        <span class="type">Alice</span> <span class="variable">alice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Alice</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Tom和Amy订阅Paper</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Tom subscribe the paper----&quot;</span>);</span><br><span class="line">        paper.addObserver(tom);</span><br><span class="line">        System.out.println(<span class="string">&quot;----Amy subscribe the paper----&quot;</span>);</span><br><span class="line">        paper.addObserver(amy);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产一份报纸，Tom和Amy收到报纸, Alice没订阅报纸，没收到通知</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----make first paper: Tom and Amy will receive，but Alice not----&quot;</span>);</span><br><span class="line">        paper.makeNewPaper(<span class="string">&quot;Fisrt Paper&quot;</span>, <span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Alice觉得报纸不错，要订阅报纸</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Alice subscribe the paper----&quot;</span>);</span><br><span class="line">        paper.addObserver(alice);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产第二份报纸，Tom、Amy、Alice都收到报纸</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----make secode paper: Tom、Amy and Alice will receive----&quot;</span>);</span><br><span class="line">        paper.makeNewPaper(<span class="string">&quot;Second Paper&quot;</span>, <span class="string">&quot;Weclome Alice to join us!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Alice觉得报纸不适合自己，决定退订</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Alice unsubscribe the paper----&quot;</span>);</span><br><span class="line">        paper.deleteObserver(alice);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产第三份保证，Tom和Amy能收到，而Alice已经收不到了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----make third paper: Tom and Amy will receive，but Alice not----&quot;</span>);</span><br><span class="line">        paper.makeNewPaper(<span class="string">&quot;Third Paper&quot;</span>, <span class="string">&quot;Sorry for Alice leaving!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/observerPatternOutput2.png" alt="使用java内置观察者模式实现程序的输出"></p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>使用 java 内置的观察者模式需要<code>java.util.Observable</code>和<code>java.util.Observer</code>两者紧密结合使用，缺一不可。而被观察者只能通过继承<code>java.util.Observable</code>的方式，这对于 java 这种单继承语言来说可以说是限制了被观察者类的扩展性。而使用自己实现观察者模式的方式时，灵活性和可扩展性都比较大，但是这种方式需要编写的代码量比较多，不如 java 内置的观察者模式简便，而且在线程安全上，java 内置的观察者模式已经用<code>synchronized</code>和<code>vector</code>保证了线程安全，自己实现观察者模式则需要额外编写代码保证线程安全。</p>
<p>因此，从可扩展性和灵活性上讲，推荐自己实现观察者模式，从简便性和线程安全方面上考虑，推荐使用 java自带的观察者模式。</p>
<h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><p>很多地方使用到了观察者模式，比如JaveBeans, swing, Dubbo。它很适合用于监控某个对象的状态变化，例如监控一个文件的状态改变，当有新数据加入这个文件时，状态发生改变，可以通知其他需要读取该文件的进程读取文件内容进行相应的处理。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Eric Freeman等，Head First 设计模式（中文版）[M]，北京：中国电力出版社，2007</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/design-pattern/proxy-pattern/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<p>代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;——《Head First 设计模式》</p>
</blockquote>
<p>其实代理对象就是一个“中介”的形式，代理对象封装了目标对象，提供跟目标对象相同的接口，目标对象不直接对外暴露接口，一切操作都是代理对象进行调用的。而客户端只会看到代理对象提供的接口。整个调用过程如下：客户端调用代理对象的方法—-&gt;代理对象调用目标对象的方法—-&gt;目标对象方法执行并将返回值传给代理对象—-&gt;代理对象将目标对象的返回值传给客户端。</p>
<span id="more"></span>

<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/designPattern/proxyPattern/UML.png" alt="代理模式类图"></p>
<blockquote>
<p>说明：此图参考《Head First 设计模式》画出</p>
</blockquote>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>此处以“代购”iphone手机为例。假设要买一台iphone手机，因为香港比大陆便宜，所以想去香港买，但是自己又没时间，所以找人（代购者）替自己去香港把iphone买回来。这里代购者就是代理对象，商店就是目标对象。原先买家直接跟商店进行交互，商店直接将手机买给买家，现在买家跟代购者进行交互，代购者再跟商店进行交互，商店先将手机卖给代购者，代购者再将手机卖给买家。</p>
<p>由于代理主要分为静态代理和动态代理，所以此处也分别用静态代理和JDK动态代理方式实现此例子。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="/images/designPattern/proxyPattern/sampleUML.png" alt="代理模式类图"></p>
<h3 id="Subject接口类"><a href="#Subject接口类" class="headerlink" title="Subject接口类"></a>Subject接口类</h3><p>此处以SellAction表示Subject接口类，此接口类中只有一个方法，表示卖手机的行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SellAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RealSubject实现类"><a href="#RealSubject实现类" class="headerlink" title="RealSubject实现类"></a>RealSubject实现类</h3><p>此处以Store表示RealSubject实现类，实现其中的sell接口方法，表示商店卖出iphone手机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> <span class="keyword">implements</span> <span class="title class_">SellAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sell a iphone!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Proxy代理类"><a href="#Proxy代理类" class="headerlink" title="Proxy代理类"></a>Proxy代理类</h3><p>由于经常在代理类中创建目标对象，所以此处在Proxy中，直接new一个Store对象。当然，为了使程序有更好的扩展性，也可以通过构造函数将目标对象传进来，或者通过set函数更改目标对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellAction</span></span><br><span class="line">&#123;</span><br><span class="line">    SellAction target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 代理对象获得目标对象</span></span><br><span class="line">        target = <span class="keyword">new</span> <span class="title class_">Store</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        target.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证程序"><a href="#验证程序" class="headerlink" title="验证程序"></a>验证程序</h3><p>验证程序很简单，直接新建一个代理对象，然后调用代理对象中的方法输出结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProxy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">SellAction</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>();</span><br><span class="line">        proxy.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sell a iphone!</span><br></pre></td></tr></table></figure>

<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>静态代理需要自己实现代理类，JDK动态代理则是有JDK帮忙生产代理类，自己只需要编写一个调用处理器类实现InvocationHandler接口即可。当然，获取代理类的方式也相应的发生改变。静态代理由于是自己实现的代理类，所以可以直接new一个代理类对象，而JDK动态代理由于是JDK根据InvocationHandler接口实现类动态生成代理类及其对象的，所以需要用配套的<code>Proxy.newProxyInstance</code>方法类获取代理对象实例。此方法是静态方法，有三个参数：</p>
<ul>
<li><code>ClassLoader loader</code>：用于定义代理对象的类加载器，一般情况下与Subject接口类的加载器一致</li>
<li><code>Class&lt;?&gt;[] interfaces</code>：代理对象所需要实现的接口类（可以是多个），也就是Subject这个接口类</li>
<li><code>InvocationHandler h</code>：调用处理器，当代理方法调用时，会调用此类中的<code>invoke</code>方法，执行目标类中对应的方法。</li>
</ul>
<h3 id="Subject接口类-1"><a href="#Subject接口类-1" class="headerlink" title="Subject接口类"></a>Subject接口类</h3><p>此处与静态代理中的类Subject接口类相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SellAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RealSubject实现类-1"><a href="#RealSubject实现类-1" class="headerlink" title="RealSubject实现类"></a>RealSubject实现类</h3><p>此处与静态代理中的类RealSubject实现类相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> <span class="keyword">implements</span> <span class="title class_">SellAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sell a iphone!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用处理器"><a href="#调用处理器" class="headerlink" title="调用处理器"></a>调用处理器</h3><p>调用处理器需要知道目标对象，由于经常在代理类中创建目标对象，所以此处在InvocationHandlerProxy中，直接new一个Store对象。当然，为了使程序有更好的扩展性，也可以通过构造函数将目标对象传进来，或者通过set函数更改目标对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InvocationHandlerProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    SellAction target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvocationHandlerProxy</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        target = <span class="keyword">new</span> <span class="title class_">Store</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当代理对象调用代理方法时：proxy.sell()，会调用此方法</span></span><br><span class="line">    <span class="comment">// 此时传入此方法的参数对应关系如下:</span></span><br><span class="line">    <span class="comment">// proxy: 对应代理对象的调用实例，即proxy.sell()中的proxy</span></span><br><span class="line">    <span class="comment">// method：对应调用的代理方法，即proxy.sell()中的sell函数</span></span><br><span class="line">    <span class="comment">// args: 对应调用的代理方法的参数，即proxy.sell()中的sell函数的参数，此处为空</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证程序-1"><a href="#验证程序-1" class="headerlink" title="验证程序"></a>验证程序</h3><p>在验证程序中，需要让JDK动态创建代理类，所以先new了一个调用处理器类，然后使用<code>Proxy.newProxyInstance</code>函数动态创建代理类并获取对象实例，最后调用代理类中的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProxy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InvocationHandlerProxy</span> <span class="variable">handlerProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandlerProxy</span>();</span><br><span class="line">        <span class="type">SellAction</span> <span class="variable">proxy</span> <span class="operator">=</span> (SellAction)Proxy.newProxyInstance(SellAction.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SellAction.class&#125;, handlerProxy);</span><br><span class="line">        proxy.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sell a iphone!</span><br></pre></td></tr></table></figure>

<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>从两个例子的输出结果来看，JDK动态代理与静态代理的效果是一样的，都是对目标对象的封装，让客户端通过代理对象间接的与目标对象进行通信。但是JDK动态代理不需要自己实现代理类，但是需要实现调用处理器，从上面的例子中看，甚至JDK动态代理比静态代理还要麻烦。但是这是一个接口方法的情况，如果目标对象有多个接口方法需要代理，那静态代理需要实现每个代理方法，而JDK动态代理的代码几乎不用改变，因为调用处理器类不用改变，而代理类是由JDK动态生成的，当增加方法时，动态生成的代理类也会包含此方法，并不需要人为干预。</p>
<h1 id="与其他模式比较"><a href="#与其他模式比较" class="headerlink" title="与其他模式比较"></a>与其他模式比较</h1><table>
<thead>
<tr>
<th>代理模式</th>
<th>装饰者模式</th>
<th>适配器模式</th>
<th>策略模式</th>
<th>命令模式</th>
<th>外观模式</th>
</tr>
</thead>
<tbody><tr>
<td>封装目标对象，提供相同的接口供外部调用，一般不在代理方法中增加额外功能。可以提供访问控制权限等。接口函数名一定与目标对象相同</td>
<td>封装目标对象，为目标对象增加额外的功能，接口函数名一般与目标对象相同</td>
<td>封装目标对象，将外部对象想要的接口转换成目标对象的接口，接口函数名一般与外部对象相同，与目标对象不同</td>
<td>封装目标对象，将调用者的行为委托给目标对象进行，接口函数名一般与目标对象不同</td>
<td>封装目标对象，将调用者的行为委托给命令对象，再由命令对象委托给目标对象进行，命令对象提供统一的接口函数名，一般与目标对象不同</td>
<td>封装目标对象，将一群复杂的接口简化为简单的接口供外部调用，接口函数名称一般与目标对象不同</td>
</tr>
</tbody></table>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ol>
<li>Java的三种代理模式：<a href="https://www.cnblogs.com/cenyu/p/6289209.html">https://www.cnblogs.com/cenyu/p/6289209.html</a></li>
<li>Java设计模式——代理模式实现及原理：<a href="https://blog.csdn.net/goskalrie/article/details/52458773">https://blog.csdn.net/goskalrie/article/details/52458773</a></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Eric Freeman等，Head First 设计模式（中文版）[M]，北京：中国电力出版社，2007</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/design-pattern/singleton-pattern/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>单例模式是用得比较多的一种设计模式，也是开发人员最熟悉的一种模式，其表示一个类只有一个实例对象，在《Head First 设计模式》中，其定义如下</p>
<blockquote>
<p>单例模式确保一个类只有一个实例，并提供一个全局访问点。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;——《Head First 设计模式》</p>
</blockquote>
<p>单例有多种写法，本文主要描述单类加载器下常见的几种写法。</p>
<span id="more"></span>

<h1 id="简单方式"><a href="#简单方式" class="headerlink" title="简单方式"></a>简单方式</h1><p>此写法在单线程环境下没有任何问题，同时也是懒加载的，对性能也无太大影响，但是在多线程环境下可能出现实例化多个对象的情况。当一个线程A在<code>if (instance == null)</code>执行后切换到另一个线程B，线程B判断到此时还未实例化对象，所以新建了一个对象返回，此时，切换到线程A继续执行，由于已经判断了instance为空，所以线程A也新建了一个对象返回。这是线程A和线程B得到的是两个不同的实例对象。程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; Construct Singleton class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他函数，测试输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; do something!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序如下（如无特殊说明，本文后续的例子测试程序均为此测试程序）。主要是在每个线程中获取单例，然后调用<code>doSomething</code>函数验证输出结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSingleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 新建5个线程，每个线程都调用Singleton.getInstance()</span></span><br><span class="line">        <span class="comment">// 通过构造函数中的输出看是否是线程安全</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Singleton.getInstance().doSomething();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下（<em>注意：由于是多线程，每次输出结果可能不一致</em>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread[pool-1-thread-4,5,main] Construct Singleton class!</span><br><span class="line">Thread[pool-1-thread-2,5,main] Construct Singleton class!</span><br><span class="line">Thread[pool-1-thread-4,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-3,5,main] Construct Singleton class!</span><br><span class="line">Thread[pool-1-thread-3,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-2,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-1,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-5,5,main] do something!</span><br></pre></td></tr></table></figure>

<h1 id="同步函数方式"><a href="#同步函数方式" class="headerlink" title="同步函数方式"></a>同步函数方式</h1><p>这种方法是直接在<code>getInstance</code>函数上加上<code>synchronized</code>关键字，使其成为线程安全的函数。这样保持了其懒加载的特点，不会在类加载时就初始化整个类而可能导致资源的浪费。但是对性能有一定的影响，因为每次调用该方法都需要获取该类的锁，不能保证并行获取对象实例，而事实上，只有第一次初始化对象的时候才需要保证线程安全，后续直接调用函数获取对象的实例并不需要加锁，是可以并行获取对象实例的。程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; Construct Singleton class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他函数，测试输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; do something!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下（<em>注意：由于是多线程，每次输出结果可能不一致</em>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main] Construct Singleton class!</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">2</span>,<span class="number">5</span>,main] <span class="keyword">do</span> something!</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">4</span>,<span class="number">5</span>,main] <span class="keyword">do</span> something!</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">5</span>,<span class="number">5</span>,main] <span class="keyword">do</span> something!</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">3</span>,<span class="number">5</span>,main] <span class="keyword">do</span> something!</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main] <span class="keyword">do</span> something!</span><br></pre></td></tr></table></figure>

<h1 id="双重检查加锁方式"><a href="#双重检查加锁方式" class="headerlink" title="双重检查加锁方式"></a>双重检查加锁方式</h1><p>双重检查加锁（double-checked locking）方式是在简单写法的基础上，在<code>if (instance == null)</code>条件里增加同步代码块和空判断保证线程安全。同时，这种方法实现的单例也是懒加载的。程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 需要注意：必须使用volatile关键字保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; Construct Singleton class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 此处必须有一层判断，否则可能存在以下情况：线程A判断为空，未进入同步块，切换到线程B，</span></span><br><span class="line">                <span class="comment">// 此时对象未初始化，线程B进入同步块获取锁，并创建对象完毕，然后切换到线程A继续执行，</span></span><br><span class="line">                <span class="comment">// 线程A进入同步块，如果没有这一层空判断，此时线程A也会创建一个对象，</span></span><br><span class="line">                <span class="comment">// 导致两个线程的对象不一致，进而出现线程不安全的现象</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                &#123;                    </span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他函数，验证输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; do something!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意以下几点</p>
<ul>
<li>静态变量<code>instance</code>必须有<code>volatile</code>关键字修饰，这是为了保证可见性和避免指令重排序，只有加上这个关键字，在一个线程中对<code>instance</code>的修改会立刻反映到其他线程上，从而让其他线程在判断<code>instance</code>是否为空时能获取到准确的值，避免产生多个对象</li>
<li>在同步代码块中需要增加<code>instance</code>是否为空的判断，这样才能保证线程安全。否则，可能出现以下的情况：线程A判断为空，未进入同步块，切换到线程B，此时对象未初始化，线程B进入同步块获取锁，并创建对象完毕，然后切换到线程A继续执行，线程A进入同步块，如果没有这一层空判断，此时线程A也会创建一个对象， 导致两个线程的对象不一致，进而出现线程不安全的现象</li>
<li><code>volatile</code>关键字是在JDK1.5之前的版本中，许多JVM的实现会导致双重检查加锁的失效，因此，此种方式只适合于JDK1.5及其之后的版本</li>
</ul>
<p>程序输出如下（<em>注意：由于是多线程，每次输出结果可能不一致</em>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread[pool-1-thread-4,5,main] Construct Singleton class!</span><br><span class="line">Thread[pool-1-thread-1,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-2,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-4,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-5,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-3,5,main] do something!</span><br></pre></td></tr></table></figure>

<h1 id="静态成员变量初始化方式"><a href="#静态成员变量初始化方式" class="headerlink" title="静态成员变量初始化方式"></a>静态成员变量初始化方式</h1><p>此种方式是在类加载时就直接对整个对象进行实例化，优点是由JVM保证在任何线程访问静态变量前一定会创建该实例，从而保证线程安全。缺点是类加载时立刻进行对象实例化，可能导致整个类并没有使用却占用者资源。程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; Construct Singleton class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他函数，测试输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; do something!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下（<em>注意：由于是多线程，每次输出结果可能不一致</em>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main] Construct Singleton class!</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">4</span>,<span class="number">5</span>,main] <span class="keyword">do</span> something!</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">3</span>,<span class="number">5</span>,main] <span class="keyword">do</span> something!</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">5</span>,<span class="number">5</span>,main] <span class="keyword">do</span> something!</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">2</span>,<span class="number">5</span>,main] <span class="keyword">do</span> something!</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main] <span class="keyword">do</span> something!</span><br></pre></td></tr></table></figure>

<h1 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a>静态内部类方式</h1><p>此种方式是参考静态成员变量初始化方式实现的，因为静态成员变量只有在类加载时才会进行初始化，且由JVM保证只有一个实例。当<code>Singleton.getInstance</code>方法没调用时，不会触发静态内部类<code>Holder</code>的加载，此时也不会进行<code>Singleton</code>的实例化，只有当<code>Singleton.getInstance</code>方法没调用时才会触发内部类<code>Holder</code>的加载，进而实例化<code>Singleton</code>对象，因此这是懒加载的。程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; Construct Singleton class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> Holder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态内部类，只有Singleton.getInstance调用时才会加载此类</span></span><br><span class="line">    <span class="comment">// 在加载此类时初始化化Singleton对象，由于是静态变量，故只有一个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他函数，验证输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; do something!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下（<em>注意：由于是多线程，每次输出结果可能不一致</em>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread[pool-1-thread-2,5,main] Construct Singleton class!</span><br><span class="line">Thread[pool-1-thread-2,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-4,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-3,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-5,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-1,5,main] do something!</span><br></pre></td></tr></table></figure>

<h1 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h1><p>枚举是JDK1.5引入的新的数据结构，其由JVM保证线程安全，同时由JVM保证在反射和反序列化的情况下仍然是单例的（其他的写法并不能保证，或需要自己手动在程序中保证）。另外，枚举类是在第一次访问时才被实例化，所以这也是懒加载的。程序如下 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此函数可以不提供，而直接使用 Singleton.INSTANCE 获取Singleton实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他函数，验证输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; do something!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下（<em>注意：由于是多线程，每次输出结果可能不一致</em>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread[pool-1-thread-3,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-5,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-2,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-1,5,main] do something!</span><br><span class="line">Thread[pool-1-thread-4,5,main] do something!</span><br></pre></td></tr></table></figure>

<p>由于枚举类不用自己写构造函数，所以不会输出<code>Construct Singleton class!</code>语句，只输出了调用的函数<code>doSomething</code>中的<code>do something</code>语句。另外，在使用枚举类获取单例时，可以直接用<code>Singleton.INSTANCE</code>，更进一步，获取单例后调用对象方法可以直接写<code>Singleton.INSTANCE.doSomething</code>，这样就不用写<code>getInstance</code>方法。</p>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><table>
<thead>
<tr>
<th>简单方式</th>
<th>同步函数方式</th>
<th>双重检查加锁方式</th>
<th>静态成员变量初始化方式</th>
<th>静态内部类方式</th>
<th>枚举方式</th>
</tr>
</thead>
<tbody><tr>
<td>非线程安全</td>
<td>线程安全</td>
<td>线程安全</td>
<td>线程安全</td>
<td>线程安全</td>
<td>线程安全</td>
</tr>
<tr>
<td>懒加载</td>
<td>懒加载，但影响性能</td>
<td>懒加载</td>
<td>非懒加载，可能浪费资源</td>
<td>懒加载</td>
<td>懒加载</td>
</tr>
<tr>
<td>适用于版本 &gt;&#x3D; JDK1.0</td>
<td>适用于版本 &gt;&#x3D; JDK1.0</td>
<td>适用于版本&gt;&#x3D; JDK1.5</td>
<td>适用于版本&gt;&#x3D; JDK1.0</td>
<td>适用于版本&gt;&#x3D; JDK1.0</td>
<td>适用于版本&gt;&#x3D; JDK1.5</td>
</tr>
</tbody></table>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://www.cnblogs.com/bugly/p/6541983.html">https://www.cnblogs.com/bugly/p/6541983.html</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Eric Freeman等，Head First 设计模式（中文版）[M]，北京：中国电力出版社，2007</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/design-pattern/state-pattern/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<p>状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;——《Head First 设计模式》</p>
</blockquote>
<p>这个定义看起来晦涩难懂，其实就是把有限状态自动机中各个状态定义由一个基本数据类型变成状态类，再把对外提供的改变状态的方法中的一堆 if 条件分解到状态类中实现。</p>
<span id="more"></span>

<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/designPattern/statePattern/UML.png" alt="状态模式类图"></p>
<blockquote>
<p>说明：此图参考《Head First 设计模式》画出</p>
</blockquote>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>此处以枪的状态转移为例子进行说明。假设枪有两个状态：已装弹、未装弹，初始化时枪是未装弹的，枪只有在未装弹的情况下才能完成进行装弹，从而进入到已装弹状态，枪只有在已装弹的情况下才能开枪从而进入到未装弹的情况。其状态转移图如下所示</p>
<p><img src="/images/designPattern/statePattern/state.png" alt="状态模式例子状态图"></p>
<p>为了更加清楚地对比有限状态自动机到状态模式之间的转换，本文用有限状态机的方式实现此例，再用状态模式实现此例。</p>
<h2 id="有限状态自动机"><a href="#有限状态自动机" class="headerlink" title="有限状态自动机"></a>有限状态自动机</h2><h3 id="Gun类"><a href="#Gun类" class="headerlink" title="Gun类"></a>Gun类</h3><p>Gun类作为状态机，在对外暴露的接口<code>loadBullet</code>、<code>fire</code>中都对状态进行了判断，因此，存在这大量的 if 判断代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枪的两个状态</span></span><br><span class="line"><span class="comment">     * UNLOAD: 未装弹</span></span><br><span class="line"><span class="comment">     * LOADED: 已装弹</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 状态转移：UNLOAD（loadBullet）--&gt;LOADED(fire)--&gt;UNLOAD</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNLOAD</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOADED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对象变量，用于记录对象的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> UNLOAD;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBullet</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == UNLOAD)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Load bullets finish!&quot;</span>);</span><br><span class="line">            state = LOADED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == LOADED)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;You have loaded the bullets.Don&#x27;t need to load again!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Unknow state error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == UNLOAD)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;You can&#x27;t fire before the bullets are loaded!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == LOADED)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Fire!&quot;</span>);</span><br><span class="line">            state = UNLOAD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Unknow state error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证程序"><a href="#验证程序" class="headerlink" title="验证程序"></a>验证程序</h3><p>验证程序很简单，先实例化一个状态机（Gun），然后模拟状态机正常的走向和异常的走向</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Gun</span> <span class="variable">gun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gun</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 正常情况</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----normal state----&quot;</span>);</span><br><span class="line">        gun.loadBullet();</span><br><span class="line">        gun.fire();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不正常情况</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----abnormal state----&quot;</span>);</span><br><span class="line">        gun.fire();</span><br><span class="line">        gun.loadBullet();</span><br><span class="line">        gun.loadBullet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/designPattern/statePattern/sampleStateOutput.png" alt="状态模式-有限状态自动机例子输出结果"></p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="状态接口类"><a href="#状态接口类" class="headerlink" title="状态接口类"></a>状态接口类</h3><p>状态接口类定义了状态之间转移的动作。虽然类图中状态接口类是用抽象类表示的，但是在具体实现中也可以用接口实现。此处就是用接口进行实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">loadBullet</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态类"><a href="#状态类" class="headerlink" title="状态类"></a>状态类</h3><p>本例中有两个状态（已装弹和未装弹），所以有两个状态类，分别是Unload（表示未装弹）、Loaded（表示已装弹）。这两个状态类都实现状态接口类中的接口，由于具体状态类对应哪个状态是明确的，所以在相应的接口中不需要再次判断状态信息，只需要执行对应的动作即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Unload</span> <span class="keyword">implements</span> <span class="title class_">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Gun gun;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Unload</span><span class="params">(Gun gun)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.gun = gun;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBullet</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Load bullets finish!&quot;</span>);</span><br><span class="line">        <span class="comment">// 由于gun中已经有明确的状态定义，所以此处直接调用即可</span></span><br><span class="line">        <span class="comment">// 如果gun中没有各个状态的明确定义，此处需要new一个新的下一个状态类对象</span></span><br><span class="line">        <span class="comment">// 如gun.setState(new Loaded(gun))</span></span><br><span class="line">        gun.setState(gun.getLoadedState());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You can&#x27;t fire before the bullets are loaded!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Loaded</span> <span class="keyword">implements</span> <span class="title class_">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Gun gun;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Loaded</span><span class="params">(Gun gun)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.gun = gun;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBullet</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You have loaded the bullets.Don&#x27;t need to load again!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fire!&quot;</span>);</span><br><span class="line">        <span class="comment">// 由于gun中已经有明确的状态定义，所以此处直接调用即可</span></span><br><span class="line">        <span class="comment">// 如果gun中没有各个状态的明确定义，此处需要new一个新的下一个状态类对象</span></span><br><span class="line">        <span class="comment">// 如gun.setState(new Unload(gun))</span></span><br><span class="line">        gun.setState(gun.getUnloadState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Gun类-1"><a href="#Gun类-1" class="headerlink" title="Gun类"></a>Gun类</h3><p>由于使用了状态类，Gun类中暴露的接口实现中已经不需要大段的 if 判断来获取对应的状态从而执行对应的动作了，直接委托给状态类执行即可。而状态类在不同的时刻表示的是不同的对象，且由于有共同的接口，所以直接调用状态类对应的接口并不需要关心此时的具体状态，这一动作交给具体的状态类执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枪的两个状态</span></span><br><span class="line"><span class="comment">     * UNLOAD: 未装弹</span></span><br><span class="line"><span class="comment">     * LOADED: 已装弹</span></span><br><span class="line"><span class="comment">     * 状态转移：UNLOAD（loadBullet）--&gt;LOADED(fire)--&gt;UNLOAD</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 此处之所以用两个变量来表示两个状态，是为了在状态类中变化状态的过程中可以直接获取到下一个状态；</span></span><br><span class="line"><span class="comment">     * 当然，此处也可以不写，但是在状态类变化状态的过程中需要new一个新的下一个状态的状态类，</span></span><br><span class="line"><span class="comment">     * 如果是这样，当状态多次转移时，会产生多个实例对象，造成不必要的内存浪费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">State</span> <span class="variable">loaded</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Loaded</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">State</span> <span class="variable">unload</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Unload</span>(<span class="built_in">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对象变量，用于记录对象的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Unload</span>(<span class="built_in">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 暴露给外部调用的接口，直接委托为对象状态执行，此处不必再写一堆 if 条件判断进行状态转移</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBullet</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        state.loadBullet();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 暴露给外部调用的接口，直接委托为对象状态执行，此处不必再写一堆 if 条件判断进行状态转移</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        state.fire();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 暴露给状态类，用于改变状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 暴露给状态类，用于获取Load状态类</span></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getLoadedState</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> loaded;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 暴露给状态类，用于获取unload状态类</span></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getUnloadState</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> unload;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证程序-1"><a href="#验证程序-1" class="headerlink" title="验证程序"></a>验证程序</h3><p>验证程序同有限状态自动机中的验证程序相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Gun</span> <span class="variable">gun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gun</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 正常情况</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----normal state----&quot;</span>);</span><br><span class="line">        gun.loadBullet();</span><br><span class="line">        gun.fire();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不正常情况</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----abnormal state----&quot;</span>);</span><br><span class="line">        gun.fire();</span><br><span class="line">        gun.loadBullet();</span><br><span class="line">        gun.loadBullet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/designPattern/statePattern/samplePatternOutput.png" alt="状态模式例子输出结果"></p>
<p>对比两种实现方式的输出结果，可以看出效果是一样的。但是从实现方式而言，有限状态自动机实现比较简单，也容易理解，但是其内部存在大量的 if 条件判断，而且如果增加新的状态也需要改动多处代码，不易于扩展。而状态模式则有良好的扩展性，增加一个新状态时，只需要新增一个状态实现类，再在其他的状态实现类总对应的地方加上状态转移即可。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>状态模式和策略模式有点类似，都是对行为进行封装，将动作委托给其他类进行，对比两者的类图，可以看到两者几乎相同。但是策略模式注重的是算法的可替换性，替换算法时无需改动原有其他类的实现逻辑，但是调用者需要明确知道需要替换的算法以及进行替换的操作，换句话说，调用者知道所有可用的算法列表，甚至可能需要维护这些算法列表。而状态模式注重的是状态之间的切换，这之间的切换对调用者是无感知的，甚至调用者都不知道具体有哪些状态，当然也不用维护这些状态。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Eric Freeman等，Head First 设计模式（中文版）[M]，北京：中国电力出版社，2007</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/design-pattern/strategy-pattern/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>策略模式定义了算法族，分别分装起来，让他们之间可以互相替换，此模式让算法的变化独立与使用算法的客户。这是《Head Fisrst 设计模式》里面的定义，有点拗口不好理解。我的理解是策略模式是让一个类拥有某个接口类的变量，在调用某个函数时，调用接口类变量里的接口函数，当这个类拥有的接口类的变量所指向的具体的实现类不同时可以产生不一样的效果，这个过程中，类调用接口变量的接口函数，并不需要知道接口变量代表的是哪个具体实现，而且也可以改变接口变量所指向的具体实现类来达到不同的效果，可以很好的实现封装效果，也留下了很好的扩展性。</p>
<span id="more"></span>

<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/strategyPatternUML.png" alt="策略模式类图"></p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>此处以吃鸡游戏中的角色和武器为例。假设游戏中有两个玩家：Alice和Bob，有两种武器：枪和刀。Alice和Bob可以拿任何一种武器攻击对方，也可以在中途更换武器。</p>
<h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><p><img src="/images/strategyPatternSampleUML.png" alt="策略模式例子类图"></p>
<h2 id="Weapon接口类"><a href="#Weapon接口类" class="headerlink" title="Weapon接口类"></a>Weapon接口类</h2><p>这个接口类主要是定义行为的，主要是让持有者类通过调用接口方法实现具体行为。此例中就是让Person类持有这个接口类的引用，通过引用调用接口方法实现不同武器的不同攻击效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Weapon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Gun实现类"><a href="#Gun实现类" class="headerlink" title="Gun实现类"></a>Gun实现类</h2><p>这个类是接口类Weapon的一个实现类，用于模拟枪的攻击效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span> <span class="keyword">implements</span> <span class="title class_">Weapon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Gun Attacking...&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Knife实现类"><a href="#Knife实现类" class="headerlink" title="Knife实现类"></a>Knife实现类</h2><p>这个类是接口类Weapon的一个实现类，用于模拟刀的攻击效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Knife</span> <span class="keyword">implements</span> <span class="title class_">Weapon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Knife Attacking...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Person类"><a href="#Person类" class="headerlink" title="Person类"></a>Person类</h2><p>Person类拥有Weapon接口，方法attackOthers调用接口对象weapon中的接口函数attack实现攻击别人的目的。changeWeapon函数用于改变weapon的行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Weapon weapon;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Weapon weapon)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackOthers</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        weapon.attack();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeWeapon</span><span class="params">(Weapon weapon)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="验证程序"><a href="#验证程序" class="headerlink" title="验证程序"></a>验证程序</h2><p>首先，初始化Gun和Knife两个武器类，然后初始化Alice和Bob两个玩家。在初始化Alice时给Alice一把刀，在初始化Bob时给Bob一把枪。</p>
<p>接着，Alice使用自己的武器（刀）攻击Bob。Bob受到攻击后，也使用自己的武器（枪）进行反击。</p>
<p>最后，Alice发现刀打不过枪，决定更换武器枪，然后使用现在的武器（枪）给Bob致命一击，成功吃鸡。</p>
<p>程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStrategy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化武器和角色</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Game Begin!----&quot;</span>);</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">gun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gun</span>();</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">knife</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Knife</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;----Alice enter the game with a knife----&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">alice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(knife);</span><br><span class="line">        System.out.println(<span class="string">&quot;----Bob enter the game with a gun----&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">bob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(gun);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Alice用刀偷袭了Bob</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Alice attack Bob----&quot;</span>);</span><br><span class="line">        alice.attackOthers();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Bob发现有人偷袭，转身给对方一枪</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Bob attack Alice----&quot;</span>);</span><br><span class="line">        bob.attackOthers();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Alice发现刀的杀伤力不够，更换枪</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Alice change weapon to gun----&quot;</span>);</span><br><span class="line">        alice.changeWeapon(gun);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Alice更换枪后，给Bob致命一击</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----Alice attack Bob----&quot;</span>);</span><br><span class="line">        alice.attackOthers();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----Game Over! Alice Win!----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<p><img src="/images/strategyPatternSampleOutput.png" alt="策略模式例子输出结果"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Eric Freeman等，Head First 设计模式（中文版）[M]，北京：中国电力出版社，2007</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法模式</title>
    <url>/design-pattern/template-pattern/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;——《Head First 设计模式》</p>
</blockquote>
<p>也就是说，模板方法是在一个方法中定义了整个流程，其中部分流程是在本类实现的，部分流程是需要由具体的子类实现的。</p>
<span id="more"></span>

<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/designPattern/templatePattern/UML.png" alt="模板方法模式类图"></p>
<blockquote>
<p>说明：此图参考《Head First 设计模式》画出</p>
</blockquote>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>此处以竞技类游戏为例。假设游戏中有两种武器：刀和枪。用刀完成一次攻击需要完成以下流程：取出武器，刺杀，收回武器。用枪完成一次攻击需要完成以下流程：取出武器，装子弹，开枪，收回武器。</p>
<h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><p><img src="/images/designPattern/templatePattern/sampleUML.png" alt="模板方法模式例子类图"></p>
<h2 id="模板抽象类"><a href="#模板抽象类" class="headerlink" title="模板抽象类"></a>模板抽象类</h2><p>Weapon是模板抽象类，里面有一个模板方法doAttack，该方法定义了攻击的整个流程：取武器takeWeapon、攻击attack、收回武器putBackWeapon。其中取武器takeWeapon和收回武器putBackWeapon是武器攻击的共有特征，放在抽象类中实现，而攻击attack根据武器类别的不同而不同，故定义成抽象方法供子类实现。</p>
<p>需要另外注意的是，为了避免模板方法被子类覆盖重写，此处将其定义成final</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Weapon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这是模板方法，定义了整个攻击的流程</span></span><br><span class="line">    <span class="comment">// 将其定义为final，可以避免子类覆盖重写这个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doAttack</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        takeWeapon();</span><br><span class="line">        attack();</span><br><span class="line">        putBackWeapon();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抽象方法，供子类实现，从而实现不同的行为</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">takeWeapon</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;taking weapon...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">putBackWeapon</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;putting bakc weapon....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板具体实现类"><a href="#模板具体实现类" class="headerlink" title="模板具体实现类"></a>模板具体实现类</h2><p>模板具体实现类有两个Knife和Gun。其中Knife用于模拟刀，它有一个stab方法用于表示刀的特殊攻击行为。Gun用于模拟枪，它有loadBullets和fire方法用于表示枪的特殊攻击行为。这两个实现类分别继承了Weapon抽象类，实现attack抽象方法，在attack中实现自己独特的攻击行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Knife</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stab</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Knife stabbing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        stab();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBullets</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Loading bullets...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Gun firing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        loadBullets();</span><br><span class="line">        fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="验证程序"><a href="#验证程序" class="headerlink" title="验证程序"></a>验证程序</h2><p>验证程序很简单，直接初始化Knife和Gun，并分别调用模板方法doAttack实现一次攻击</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTemplate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">knife</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Knife</span>();</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">gun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gun</span>();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----Knife do attack----&quot;</span>);</span><br><span class="line">        knife.doAttack();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----Gun do attack----&quot;</span>);</span><br><span class="line">        gun.doAttack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下，可以看出，出了attack方法中输出不同，其他（takeWeapon和putBackWeapon方法）输出是相同的</p>
<p><img src="/images/designPattern/templatePattern/sampleOutput.png" alt="模板方法模式例子输出结果"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>模板方法模式是一种比较常用的设计，也是一种比较简单的设计模式。对于需要提供用户自定义行为的框架而言，模板方法设计模式是一种常用的也是一种合适的设计模式，因为其既保证了框架整体的流程不变性，又提供了部分子流程的可变性供客户自定义完成独特的要求。在项目中，涉及到提供定制点的功能实现，也大部分是采用模板方法设计模式来实现的。</p>
<h2 id="与策略模式比较"><a href="#与策略模式比较" class="headerlink" title="与策略模式比较"></a>与策略模式比较</h2><p>模板方法模式与策略模式都是对“算法”进行封装，但是模板方法模式侧重的是对算法整理流程的定义和不变性，暴露部分子流程接口供子类实现，从而实现不同的功能；而策略模式则注重对整套算法的封装实现，其关注的是整个算法的互换性，当对某个算法进行更改时，是更改整套算法流程而不是其中的某个子流程。另一方面，从实现的角度而言，模板方法模式使用的是继承，而策略模式使用的是组合。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Eric Freeman等，Head First 设计模式（中文版）[M]，北京：中国电力出版社，2007</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm 性能分析工具</title>
    <url>/jvm/jvm-analysis-tools/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JDK中的bin目录除了javac和java这两个经常用于编译和运行java程序的工具外，还有许多用于监控虚拟机和故障处理的工具，包括命令行工具jps、jstat、jinfo、jmap、jhat、jstack和可视化工具jconsole、jvisualvm。本文主要介绍jps、jstat、jinfo、jmap、jhat、jstack这几个命令行工具。他们的主要作用如下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>jps</td>
<td>JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td>JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jinfo</td>
<td>Configuration Info for Java，显示虚拟机配置信息</td>
</tr>
<tr>
<td>jmap</td>
<td>Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件）</td>
</tr>
<tr>
<td>jhat</td>
<td>JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP&#x2F;HTML服务器，让用户可以在浏览器上查看分析结果</td>
</tr>
<tr>
<td>jstack</td>
<td>Stack Trace for Java，显示虚拟机的线程快照</td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h1><p>jps命令主要是列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier，LVMID）。对本地虚拟机来说，LVMID与操作系统的进程ID（Process Identifier，PID）是一致的。这是使用频率最高的一个命令行工具，因为其他的命令行工具需要依赖LVMID，而LVMID可以通过jps查询得到。</p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>jps的命令格式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure>

<p>其中options选项列表如下</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-q</td>
<td>只输出LVMID，省略主类的名称</td>
</tr>
<tr>
<td>-m</td>
<td>输出虚拟机进程启动时传递给主main()函数的参数</td>
</tr>
<tr>
<td>-l</td>
<td>输出主类的全名，如果进程执行的是jar包，输出jar路径</td>
</tr>
<tr>
<td>-v</td>
<td>输出虚拟机进程启动时JVM参数</td>
</tr>
</tbody></table>
<p>hostid是可选参数，不输入时表示查询的是本机的虚拟机进程，输入时需要输入RMI注册表中的主机名。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>如下程序用来测试jps命令工具，该程序很简单，只是接收一个参数，然后不断将该参数打印出来。本文后续的例子将基于此例子进行说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJvmTools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(args[<span class="number">0</span>]);</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;no parameter pass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用命令<code>java -Xms20M -Xmx20M TestJvmTools oneParameter </code>执行该程序，让程序一直处于运行状态，然后分别执行<code>jps -l</code>、<code>jps -m</code>、<code>jps -v</code>、<code>jps -q</code>命令，查看输出结果，如下图所示</p>
<p><img src="/images/jvm/jps.png" alt="jps命令输出结果"></p>
<h1 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h1><p>jstat是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或远程虚拟机进程中的类装载、内存、垃圾回收、JIT编译等运行数据。</p>
<h2 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h2><p>jstat命令格式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat [option vmid [interval[s|ms][count]]]</span><br></pre></td></tr></table></figure>

<p>其中option表示希望查询的虚拟机信息，主要分为三类：类装载、垃圾回收、运行编译状况，具体选项及作用如下表所示</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-class</td>
<td>监视类装载、卸载数量、总空间以及类装载所耗费的时间</td>
</tr>
<tr>
<td>-gc</td>
<td>监视java堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息</td>
</tr>
<tr>
<td>-gccapacity</td>
<td>监视内容与 -gc基本相同，但输出主要关注java堆各个区域使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcutil</td>
<td>监视内容与 -gc基本相同，但输出主要关注已使用空间站总空间的百分比</td>
</tr>
<tr>
<td>-gccause</td>
<td>与 -gcutil功能一样，但是会额外输出导致上一次GC产生的原因</td>
</tr>
<tr>
<td>-gcnew</td>
<td>监视新生代GC状况</td>
</tr>
<tr>
<td>-gcnewcapacity</td>
<td>监视内容与 -gcnew基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcold</td>
<td>监视老年代GC状况</td>
</tr>
<tr>
<td>-gcoldcapacity</td>
<td>监视内容与 -gcold基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-compiler</td>
<td>输出JIT编译器编译过的方法、耗时等信息</td>
</tr>
<tr>
<td>-printcompilation</td>
<td>输出已经被JIT编译的方法</td>
</tr>
<tr>
<td>命令行中的vmid参数，如果是本地虚拟机进程，则与LVMID一致，如果是远程虚拟机进程，则vmid的格式如下</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[protocol:][//]lvmid[@hostname[:port]/servername]</span><br></pre></td></tr></table></figure>

<p>命令行中的interval和count代表查询间隔和次数，如果省略这两个参数，则只查询一次。例如以下命令表示每隔250毫秒查询一次进程10928垃圾回收情况，一共查询20次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat -gc 10928 250 20</span><br></pre></td></tr></table></figure>

<h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><h3 id="查看类装载信息"><a href="#查看类装载信息" class="headerlink" title="查看类装载信息"></a>查看类装载信息</h3><p>执行<code>jstat -class 10928</code>命令查看类的装载信息，如下图所示</p>
<p><img src="/images/jvm/jstatClass.png" alt="jstat查看类装载命令输出结果"></p>
<p>输出结果中的参数说明如下</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Loaded</td>
<td>加载class的数量</td>
</tr>
<tr>
<td>Bytes（从左往右数第一个Bytes）</td>
<td>所占用空间大小</td>
</tr>
<tr>
<td>Unloaded</td>
<td>未加载数量</td>
</tr>
<tr>
<td>Bytes（从左往右数第二个Bytes）</td>
<td>未加载占用空间</td>
</tr>
<tr>
<td>Times</td>
<td>装载所耗的时间</td>
</tr>
</tbody></table>
<h3 id="查看编译信息"><a href="#查看编译信息" class="headerlink" title="查看编译信息"></a>查看编译信息</h3><p>分别执行<code>jstat -compiler 10928</code>、<code>jstat -printcompilation 10928</code>命令查看进程的编译相关信息，如下图所示</p>
<p><img src="/images/jvm/jstatCompile.png" alt="jstat查看编译相关信息命令输出结果"></p>
<p>-compiler命令输出结果中的参数说明如下</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Compiled</td>
<td>编译数量</td>
</tr>
<tr>
<td>Failed</td>
<td>编译失败数量</td>
</tr>
<tr>
<td>Invilid</td>
<td>不可用数量</td>
</tr>
<tr>
<td>Time</td>
<td>编译时间</td>
</tr>
<tr>
<td>FailedTypes</td>
<td>失败类型</td>
</tr>
<tr>
<td>FailedMethod</td>
<td>失败的方法</td>
</tr>
</tbody></table>
<p>-printcompilation命令输出结果参数说明如下</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Compiled</td>
<td>最近编译方法的数量</td>
</tr>
<tr>
<td>Size</td>
<td>最近编译方法的字节码数量</td>
</tr>
<tr>
<td>Type</td>
<td>最近编译方法的编译类型</td>
</tr>
<tr>
<td>Method</td>
<td>方法名标识</td>
</tr>
</tbody></table>
<h3 id="查看垃圾回收信息"><a href="#查看垃圾回收信息" class="headerlink" title="查看垃圾回收信息"></a>查看垃圾回收信息</h3><p>分别执行<code>jstat -gc 10928</code>、<code>jstat -gccapacity 10928</code>、<code>jstat -gcutil 10928</code>、<code>jstat -gccause 10928</code>、<code>jstat -gcnew 10928</code>、<code>jstat -gcnewcapacity 10928</code>、<code>jstat -gcold 10928</code>、<code>jstat -gcoldcapacity 10928</code>命令查看垃圾回收的相关信息，如下图所示</p>
<p><img src="/images/jvm/jstatGC.png" alt="jstat查看垃圾回收相关信息命令输出结果"></p>
<p>输出结果中参数说明如下</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>S0C</td>
<td>Survivor0的大小</td>
</tr>
<tr>
<td>S1C</td>
<td>Survivor1的大小</td>
</tr>
<tr>
<td>S0U</td>
<td>Survivor0区已使用空间大小</td>
</tr>
<tr>
<td>S1U</td>
<td>Survivor1区已使用空间大小</td>
</tr>
<tr>
<td>EC</td>
<td>Eden区的大小</td>
</tr>
<tr>
<td>EU</td>
<td>Eden区已使用的空间大小</td>
</tr>
<tr>
<td>OC</td>
<td>老年代（Old）区的大小</td>
</tr>
<tr>
<td>OU</td>
<td>老年代区已使用空间大小</td>
</tr>
<tr>
<td>MC</td>
<td>方法区大小</td>
</tr>
<tr>
<td>MU</td>
<td>方法区已使用空间大小</td>
</tr>
<tr>
<td>CCSC</td>
<td>压缩类空间大小</td>
</tr>
<tr>
<td>CCSU</td>
<td>压缩类空间已使用大小</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代垃圾回收次数，YGC表示Young GC</td>
</tr>
<tr>
<td>YGCT</td>
<td>年轻代垃圾回收总耗时</td>
</tr>
<tr>
<td>FGC</td>
<td>老年代垃圾回收次数，FGC表示Full GC</td>
</tr>
<tr>
<td>FGCT</td>
<td>老年代来及回收总耗时</td>
</tr>
<tr>
<td>GCT</td>
<td>垃圾回收总消耗时间</td>
</tr>
<tr>
<td>NGCMN</td>
<td>新生代最小容量</td>
</tr>
<tr>
<td>NGCMX</td>
<td>新生代最大容量</td>
</tr>
<tr>
<td>NGC</td>
<td>当前新生代容量</td>
</tr>
<tr>
<td>OGCMN</td>
<td>老年代最小容量</td>
</tr>
<tr>
<td>OGCMX</td>
<td>老年代最大容量</td>
</tr>
<tr>
<td>OGC</td>
<td>当前老年代容量</td>
</tr>
<tr>
<td>MCMN</td>
<td>方法区最小容量</td>
</tr>
<tr>
<td>MCMX</td>
<td>方法区最大容量</td>
</tr>
<tr>
<td>CCSMN</td>
<td>压缩类空间最小容量</td>
</tr>
<tr>
<td>CCSMX</td>
<td>压缩类空间最大容量</td>
</tr>
<tr>
<td>S0</td>
<td>Survivor0区</td>
</tr>
<tr>
<td>S1</td>
<td>Survivor1区</td>
</tr>
<tr>
<td>E</td>
<td>Eden区</td>
</tr>
<tr>
<td>O</td>
<td>老年代</td>
</tr>
<tr>
<td>M</td>
<td>方法区</td>
</tr>
<tr>
<td>CCS</td>
<td>压缩类</td>
</tr>
<tr>
<td>TT</td>
<td>对象在新生代存活的次数</td>
</tr>
<tr>
<td>MTT</td>
<td>对象在新生代存活的最大次数</td>
</tr>
<tr>
<td>DSS</td>
<td>期望的一个Survivor区的大小</td>
</tr>
<tr>
<td>S0CMX</td>
<td>Survivor0区最大容量</td>
</tr>
<tr>
<td>S1CMX</td>
<td>Survivor1区最大容量</td>
</tr>
<tr>
<td>ECMX</td>
<td>Eden区最大容量</td>
</tr>
</tbody></table>
<h1 id="jinfo：java配置信息工具"><a href="#jinfo：java配置信息工具" class="headerlink" title="jinfo：java配置信息工具"></a>jinfo：java配置信息工具</h1><p>jinfo的作用是实时地查看和调整迅疾各项参数。使用jps -v命令可以查看虚拟机启动时显示配置的参数，而jinfo命令不仅可以查看虚拟机启动时显示配置的参数，也能查看未被显示指定的参数的系统默认值，还能动态修改参数的值。</p>
<h2 id="命令格式-2"><a href="#命令格式-2" class="headerlink" title="命令格式"></a>命令格式</h2><p>jinfo的命令格式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jinfo [option] pid</span><br></pre></td></tr></table></figure>

<p>其中pid表示进程号，option是一个可选参数，如果是查看信息，则使用 -flag param，如<code>jinfo -flag InitialHeapSize 10928</code> ，如果是修改信息，则使用 -flag +param或 -flag -param或 -flag param&#x3D;value，如<code>jinfo -flag InitialHeapSize=20480 10928</code>或<code>jinfo -flag +UseParallelGC 10928</code>，</p>
<h2 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h2><p>下图所示是jinfo的查看命令</p>
<p><img src="/images/jvm/jinfo.png" alt="jinfo命令输出结果"></p>
<h1 id="jmap：java内存映像工具"><a href="#jmap：java内存映像工具" class="headerlink" title="jmap：java内存映像工具"></a>jmap：java内存映像工具</h1><p>jmap命令用于生成堆转储快照（即heapdump或dump文件），同时也可以用于查询finalize执行队列、java堆和永久代的详细信息，如空间使用率、当前用的是哪种垃圾回集器等</p>
<h2 id="命令格式-3"><a href="#命令格式-3" class="headerlink" title="命令格式"></a>命令格式</h2><p>jmap的命令格式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap [option] vmid</span><br></pre></td></tr></table></figure>

<p>其中option是可选参数，其选项和含义如下表所示</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-dump</td>
<td>生成java堆转储快照。格式为：-dump:[live,]format&#x3D;b,file&#x3D;&lt;filename&gt;，其中live子参数说明是否只dump出存活对象</td>
</tr>
<tr>
<td>-finalizerinfo</td>
<td>显示在F-Queue中等待Finalizer线程执行finalize方法的对象</td>
</tr>
<tr>
<td>-heap</td>
<td>显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等</td>
</tr>
<tr>
<td>-histo</td>
<td>显示堆中对象统计信息，包括类、实例数量、合计容量</td>
</tr>
<tr>
<td>-clstats</td>
<td>以ClassLoader为统计入口</td>
</tr>
<tr>
<td>-F</td>
<td>当虚拟机进程对 -dump   没有响应时，可使用这个选项强制生产dump快照</td>
</tr>
</tbody></table>
<h2 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h2><p>下图是执行命令<code>jmap -dump:format=b,file=D:/testDump 10928</code>，<code>jmap -heap 10928</code>的结果</p>
<p><img src="/images/jvm/jmap.png" alt="jmap命令执行结果"></p>
<h1 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h1><p>jhat主要用于分析jmap产生的堆转储快照，jhat内置了一个微型的HTTP&#x2F;HTML服务器，在生成dump文件的分析结果后可以下浏览器中查看。然而，由于分析dump文件需要耗费很大的内存，加上jhat产生的界面比较简陋，远不及可视化工具jvisualvm，所以一般情况下也不会使用这个命令对dump文件进行分析。</p>
<h2 id="命令格式-4"><a href="#命令格式-4" class="headerlink" title="命令格式"></a>命令格式</h2><p>jhat的命令格式如下，其中&lt;dumpFile&gt;指dump文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jhat &lt;dumpFile&gt;</span><br></pre></td></tr></table></figure>

<h2 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h2><p>下图是执行<code>jhat D:/testDump</code>命令的结果（D:&#x2F;testDump是“jmap：java内存映像工具”章节中例子生产的dump文件）。当控制台中输出<code>Server is ready</code>后，在浏览器中输入<code>http://localhost:7000</code>即可查看相应的分析结果</p>
<p><img src="/images/jvm/jhatConsole.png" alt="jhat命令控制台输出结果"></p>
<p><img src="/images/jvm/jhatBrowser.png" alt="jhat命令浏览器查看结果"></p>
<h1 id="jstack：java堆栈跟踪工具"><a href="#jstack：java堆栈跟踪工具" class="headerlink" title="jstack：java堆栈跟踪工具"></a>jstack：java堆栈跟踪工具</h1><p>jstack命令用于生成虚拟机当前时刻的线程快照，主要是用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。当线程出现停顿的时候通过jstack查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。</p>
<h2 id="命令格式-5"><a href="#命令格式-5" class="headerlink" title="命令格式"></a>命令格式</h2><p>jstack的命令格式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstack [option] vmid</span><br></pre></td></tr></table></figure>

<p>其中option是一个可选参数，选项列表如下</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-F</td>
<td>当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l</td>
<td>除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m</td>
<td>如果调用到本地方法的话，可以显示C&#x2F;C++的堆栈</td>
</tr>
</tbody></table>
<h2 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h2><p>下图是执行<code>jstack -l 10928</code>命令的结果</p>
<p><img src="/images/jvm/jstack.png" alt="jstack命令输出结果"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践[M]. 北京：机械工业出版社，2013<br>[2] 南湖公明. jstat命令使用[J&#x2F;OL]. <a href="https://www.cnblogs.com/lizhonghua34/p/7307139.html">https://www.cnblogs.com/lizhonghua34/p/7307139.html</a> , 2017-08-08 </p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm 类加载过程</title>
    <url>/jvm/jvm-class-loading/</url>
    <content><![CDATA[<h1 id="类生命周期"><a href="#类生命周期" class="headerlink" title="类生命周期"></a>类生命周期</h1><p>类从被加载到虚拟机内存开始，到卸载出内存为止，其需要经历包含以下 7 个阶段的生命周期：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化化（Initialization）、使用（Using）、卸载（Unloading）。其中，验证、准备、解析三个部分统称为连接。其图示如下：</p>
<p><img src="/images/jvm/classLifecycle.png" alt="类生命周期"></p>
<span id="more"></span>

<p>这些阶段是按部就班地开始，但是并不一定是需要等上一个阶段完成后才开始下一个阶段，有可能上一个步骤在进行时，下一个步骤也开始执行了。</p>
<h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><p>加载是类加载过程中的第一个阶段，在这个阶段中，虚拟机需要完成以下三件事</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时的数据接结构</li>
<li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<p>而关于“通过一个类的全限定名来获取定义此类的二进制字节流”这一条中，并没有规定一定要从硬盘中的 class 文件中获取，也可以从 zip 包中读取（例如：jar包、war包），或是从网络中获取（例如：Applet），当然，也可以是运行时生成（如：动态代理）或从其他文件中读取（如，JSP）······</p>
<p>在加载阶段完成之后，虚拟机外部的二进制流就按照虚拟机所需的格式存储在方法区之中，而对于方法区中的数据存储格式，虚拟并没有规定，可以由虚拟机实现者自己决定。</p>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>验证是连接阶段的第一步，一般情况下，在加载阶段进行的过程中，会启动验证阶段对二进制流进行验证。由于 class 文件并不一定是由 java 源码编译生成（可能是由其他编程语言产生，也可能是直接用编辑器输出 16 进制的文件），所以对读取的二进制字节流进行验证显得格外重要，否则可能会对整个系统产生严重破坏。</p>
<p>虚拟机中在验证阶段进行了很多项检验动作，这些动作主要可以归纳为四个方面：</p>
<ul>
<li>文件格式验证：主要是对“魔数”、版本号等类型信息的验证，主要是要确保解析的二进制字节流在格式上符合描述一个 java 类型信息的要求，在这一阶段完成后，二进制字节流就被存储在方法区中了，后续的验证都是基于方法区中进行，不会再操作二进制字节流。</li>
<li>元数据验证：这个阶段主要是对字节码进行语义分析，确保描述的信息符合 java 语言规范的要求，主要包括验证类的继承关系、接口关系、数据类型等是否合法。</li>
<li>字节码验证：这个阶段是最复杂的一个阶段，主要是通过数据流和控制流分析，确保程序语义的合法性。主要是对类的方法体进行校验（校验执行指令），确保方法在运行时不会对虚拟机造成破坏。</li>
<li>符号引用验证：这个阶段一般与解析阶段并行，主要是确保所有的符号引用都能得到正确的解析。</li>
</ul>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。这些变量所使用的内存都在方法区中进行分配，初始值指“零值”，需要注意的是被 final 定义的变量，其值不是零值，而是指定的具体的值，因为在编译阶段就会将这些常量值生成 ConstantValue 属性，在准备阶段时会根据 ConstantValue 将对应的变量设置成相应的常量值。此过程只涉及类成员变量（static 变量），不涉及实例成员变量（这是在初始化阶段进行的，分配在堆中）。</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>解析是虚拟机将常量池内的符号引用替换为直接引用的过程，类似于根据指针找到对应的内存区域的过程。解析动作主要包含以下 7 中类型</p>
<ul>
<li>类或接口：对应常量池中的 CONSTANT_Class_info</li>
<li>字段：对应常量池中的 CONSTANT_Fieldref_info，解析过程中先搜索本类、再搜索接口、再搜索父类</li>
<li>类方法：对应常量池中的 CONSTANT_Methodref_info，解析过程中先搜索本类，再搜索父类、再搜索接口</li>
<li>接口类型：对应常量池中的 CONSTANT_InterfaceMethodref_info</li>
<li>方法类型：对应常量池中的 CONSTANT_MethodType_info</li>
<li>方法句柄：对应常量池中的 CONSTANT_MethodHandle_info</li>
<li>调用点：对应常量池中的 CONSTANT_InvokeDynamic_info</li>
</ul>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><h2 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h2><p>虚拟机规范中严格规定了有且仅有以下 5 中情况会立即对类进行初始化：</p>
<ul>
<li>遇到 new、getstatic（读取静态变量，但是非 fianl 修饰的变量，因为 final 修饰的变量在编译期已经被放入常量池中）、putstatic（设置静态变量）、invokestatic（调用静态方法）这四条字节码指令时，如果没有对类进行初始化，需要立即对类进行初始化</li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用</li>
<li>当初始化一个类的时候，如果发现父类还没有进行过初始化，则需要先触发其父类的初始化</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main 方法的类），虚拟机会先初始化这个主类</li>
<li>当使用动态语言支持时，如果一个 <code>java.lang.invoke.MethodHandle</code> 实例最后的解析结果 <code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>类初始化阶段是执行类构造器 &lt;clinit&gt; 方法的过程，其主要有以下特点</p>
<ul>
<li>&lt;clinit&gt; 是由编译器自动收集类中的所有类变量（static 变量）的赋值动作（单纯定义的不包含）和静态语句块（static 代码块）中的语句合并产生，其按照代码出现的先后顺序进行搜集。也就是说，初始化过程会执行类静态变量和静态代码块，同时按照出现的先后顺序从上到下执行</li>
<li>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它后面的变量，在前面的的静态语句块中可以赋值，但是不能访问</li>
<li>父类中定义的静态变量和静态语句块的初始化先于子类完成。虚拟机会保证在子类的 &lt;clinit&gt; 方法执行之前，父类的 &lt;clinit&gt; 方法已经执行完毕</li>
<li>&lt;clinit&gt; 方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也么有对变量的赋值操作，那么编译器可以不为这个类生成 &lt;clinit&gt; 方法</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的复制操作，因此接口与类一样会生成 &lt;clinit&gt; 方法，只是接口执行 &lt;clinit&gt; 方法不需要先执行父接口的 &lt;clinit&gt; 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt; 方法</li>
</ul>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>以下的例子是从<a href="https://blog.csdn.net/noaman_wgs/article/details/74489549">网上</a>看到的，作为补充，能更好地理解类的加载过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton1</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> value1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Singleton1</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        value1++;</span><br><span class="line">        value2++;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton1() value1: &quot;</span> + value1 + <span class="string">&quot;, value2: &quot;</span> + value2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> value1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton2</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Singleton2</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        value1++;</span><br><span class="line">        value2++;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton2() value1: &quot;</span> + value1 + <span class="string">&quot;, value2: &quot;</span> + value2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Singleton1</span> <span class="variable">singleton1</span> <span class="operator">=</span> Singleton1.getInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton1 value1 is: &quot;</span> + singleton1.value1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton1 value2 is: &quot;</span> + singleton1.value2);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Singleton2</span> <span class="variable">singleton2</span> <span class="operator">=</span> Singleton2.getInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton2 value1 is: &quot;</span> + singleton2.value1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton2 value2 is: &quot;</span> + singleton2.value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Singleton1() value1: 1, value2: 1</span><br><span class="line">Singleton1 value1 is: 1</span><br><span class="line">Singleton1 value2 is: 10</span><br><span class="line">Singleton2() value1: 1, value2: 11</span><br><span class="line">Singleton2 value1 is: 1</span><br><span class="line">Singleton2 value2 is: 11</span><br></pre></td></tr></table></figure>

<p>首先解析 Singleton1 类的三个输出语句。在程序执行到 <code>Singleton1 singleton1 = Singleton1.getInstance()</code> 时会触发 Singleton1 类的加载、验证、准备、解析、初始化阶段。在类的解析阶段，会为类的静态成员变量赋零值，此时 <code>instance = null, value1 = 0, value2 = 0</code>，然后执行初始化阶段，对静态成员变量进行赋值操作。首先是 instance 变量的赋值，这会 new 一个 Singleton1 对象，执行 Singlton1 的无参构造函数，执行后 <code>value1 = 1, value2 = 1</code>，同时输出 <code>Singleton1() value1: 1, value2: 1</code>，接着执行 value2 变量的赋值，执行后 <code>value2 = 10</code>，虽然 value1 也是静态变量，但是其没有显式的赋值操作，所以不会再次为其赋值。接下来程序执行对 value1 和 value2 的输出操作，所以输出 <code>Singleton1 value1 is: 1</code> 和 <code>Singleton1 value2 is: 10</code>。</p>
<p>现在解析 Singleton2 类的三个输出语句。在程序执行到 <code>Singleton2 singleton2 = Singleton2.getInstance()</code> 时会触发 Singleton2 类的加载、验证、准备、解析、初始化阶段。在类的解析阶段，会为类的静态成员变量赋零值，此时 <code>instance = null, value1 = 0, value2 = 0</code>，然后执行初始化阶段，对静态成员变量进行赋值操作。首先执行 value2 变量的赋值，执行后 <code>value2 = 10</code>，接着是 instance 变量的赋值，这会 new 一个 Singleton2 对象，执行 Singlton2 的无参构造函数，执行后 <code>value1 = 1, value2 = 11</code>，同时输出 <code>Singleton2() value1: 1, value2: 11</code>，虽然 value1 也是静态变量，但是其没有显式的赋值操作，所以不会再次为其赋值。接下来程序执行对 value1 和 value2 的输出操作，所以输出 <code>Singleton2 value1 is: 1</code> 和 <code>Singleton2 value2 is: 11</code>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践[M]. 北京：机械工业出版社，2013<br>[2] 是Guava不是瓜娃. JVM(四)—一道面试题搞懂JVM类加载机制[J&#x2F;OL]. <a href="https://blog.csdn.net/noaman_wgs/article/details/74489549%EF%BC%8C2017-07-05">https://blog.csdn.net/noaman_wgs/article/details/74489549，2017-07-05</a> </p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm 类文件结构</title>
    <url>/jvm/jvm-class-structure/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java 文件经过编译后会产生 class 文件，这是一个存储字节码的文件，它可以被 java 虚拟机解析并运行。事实上，java 虚拟机并不是只能解析 java 语言编译产生的 class 文件，它也可以解析其他语言产生的 class 文件，事实上，java 虚拟机是一种语言无关的平台，只要 class 文件满足 java 虚拟机特定的语法和结构化约束，就能在 java 虚拟机解析运行。</p>
<span id="more"></span>

<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p>class 文件是一组以 8 字节为基础单位的二进制流，各个数据项目严格按照规范和大端模式（高字节存放在地址低位，低字节存放在地址高位）的顺序紧凑地排列在 class 文件中，没有任何分隔符。</p>
<p>class 文件中只有两种数据类型，无符号数和表，其中无符号数用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。分别以 u1、u2、u4、u8 代表 1 个字节、2 个字节、4 个字节、8个字节的无符号数。表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以 <code>_info</code> 结尾。</p>
<p>class 文件的总体数据结构如下所示，其主要的顺序是：文件类型信息  –&gt;  文件版本号  –&gt;  常量信息  –&gt;  文件访问权限信息  –&gt;  类索引  –&gt;  父类索引  –&gt;  接口索引信息  –&gt;  字段表信息  –&gt;  方法表信息  –&gt;  属性表信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>类型</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>magic</td>
<td>“魔数”，用于确认文件是否能够被 java 虚拟机解析</td>
<td>u4</td>
<td>1</td>
</tr>
<tr>
<td>minor_version</td>
<td>class 文件次版本号</td>
<td>u2</td>
<td>1</td>
</tr>
<tr>
<td>major_version</td>
<td>class 文件主版本号</td>
<td>u2</td>
<td>1</td>
</tr>
<tr>
<td>constant_pool_count</td>
<td>常量池中常量数量</td>
<td>u2</td>
<td>1</td>
</tr>
<tr>
<td>constant_pool</td>
<td>常量池中的常量表</td>
<td>cp_info</td>
<td>constant_pool_count - 1</td>
</tr>
<tr>
<td>access_flags</td>
<td>访问标志，用于标识类或接口的访问信息</td>
<td>u2</td>
<td>1</td>
</tr>
<tr>
<td>this_class</td>
<td>类索引</td>
<td>u2</td>
<td>1</td>
</tr>
<tr>
<td>super_class</td>
<td>父类索引</td>
<td>u2</td>
<td>1</td>
</tr>
<tr>
<td>interfaces_count</td>
<td>接口索引的数量</td>
<td>u2</td>
<td>1</td>
</tr>
<tr>
<td>interfaces</td>
<td>接口索引</td>
<td>u2</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>fields_count</td>
<td>字段表数量</td>
<td>u2</td>
<td>1</td>
</tr>
<tr>
<td>fields</td>
<td>字段表</td>
<td>field_info</td>
<td>fields_count</td>
</tr>
<tr>
<td>methods_count</td>
<td>方法表数量</td>
<td>u2</td>
<td>1</td>
</tr>
<tr>
<td>methods</td>
<td>方法表</td>
<td>method_info</td>
<td>methods_count</td>
</tr>
<tr>
<td>attributes_count</td>
<td>属性表数量</td>
<td>u2</td>
<td>1</td>
</tr>
<tr>
<td>attributes</td>
<td>属性表</td>
<td>attribute_info</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p>本文中将以下面的简单例子产生的字节码进行分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJvmClassStructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>产生的字节码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cafe babe 0000 0034 0013 0a00 0400 0f09</span><br><span class="line">0003 0010 0700 1107 0012 0100 016d 0100</span><br><span class="line">0149 0100 063c 696e 6974 3e01 0003 2829</span><br><span class="line">5601 0004 436f 6465 0100 0f4c 696e 654e</span><br><span class="line">756d 6265 7254 6162 6c65 0100 0369 6e63</span><br><span class="line">0100 0328 2949 0100 0a53 6f75 7263 6546</span><br><span class="line">696c 6501 001a 5465 7374 4a76 6d43 6c61</span><br><span class="line">7373 5374 7275 6374 7572 652e 6a61 7661</span><br><span class="line">0c00 0700 080c 0005 0006 0100 1554 6573</span><br><span class="line">744a 766d 436c 6173 7353 7472 7563 7475</span><br><span class="line">7265 0100 106a 6176 612f 6c61 6e67 2f4f</span><br><span class="line">626a 6563 7400 2100 0300 0400 0000 0100</span><br><span class="line">0200 0500 0600 0000 0200 0100 0700 0800</span><br><span class="line">0100 0900 0000 1d00 0100 0100 0000 052a</span><br><span class="line">b700 01b1 0000 0001 000a 0000 0006 0001</span><br><span class="line">0000 0001 0001 000b 000c 0001 0009 0000</span><br><span class="line">001f 0002 0001 0000 0007 2ab4 0002 0460</span><br><span class="line">ac00 0000 0100 0a00 0000 0600 0100 0000</span><br><span class="line">0600 0100 0d00 0000 0200 0e</span><br></pre></td></tr></table></figure>

<h1 id="“魔数”"><a href="#“魔数”" class="headerlink" title="“魔数”"></a>“魔数”</h1><p>“魔数”主要是用于确认这个文件是否能够被 java 虚拟机解析的文件。class 文件中主要使用文件开始的前 4 个字节表示“魔数”，只有当值是 0xcafebabe 时，才表明这个 class 文件是能够被虚拟机解析的文件。</p>
<p>使用“魔数”而不是文件的后缀名进行判断主要是出于安全方面的考虑，因为文件后缀名能够随意更改。现在有很多存储文件都使用“魔数”进行文件类别的校验，如 gif。文件格式的制定者可以自由地选择魔数值，只要这个魔数值没有被广泛使用并且不会产生二义性即可。</p>
<p>上述例子中，前四个字节<code>cafe babe</code>表明了这是一个 class 文件</p>
<h1 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h1><p>跟在“魔数”后面的四个字节，即第 5 ~ 8 个字节，表明 class 文件的版本号。其中第 5、第 6 个字节表明 class 文件的次版本号，第 7、第 8 个字节表明文件的主版本号。这个版本号表明该 class 文件可以被高于或等于这个版本的虚拟机解析，使用 JDK8 编译产生的版本号是 0x00000034，表明可以被 JDK8 或高于 JDK8 以上的虚拟机解析执行。</p>
<p>上述例子中，第 5 ~ 8 个字节<code>0000 0034</code>表明这适用于 JDK8 及以上版本的虚拟机解析运行。</p>
<h1 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h1><p>常量池是跟在版本号后面的字节码。其主要存放两种数据：字面量（Literal）和符号引用（Symbolic References）。其中字面量类似于 java 语言的常量，而符号引用则属于编译原理方面的概念，主要包括：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。</p>
<p>由于常量池中的常量数量不固定，因此在常量吃入口有一项 u2 类型的数据代表常量池中常量的数量（称为常量池容量）。但是有一点需要注意，其技术从 1 开始而不是从 0 开始，这就意味者如果常量池容量为 10，则常量的数量为 10 - 1 &#x3D; 9。class 文件结构中只有常量池的容量计数是从 1 开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都是从 0 开始的。</p>
<p>常量池中共有 14 中常量，其结构如下所示</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>项目</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_Utf8_info</td>
<td>tag</td>
<td>u1</td>
<td>区分常量类型，值为 1</td>
</tr>
<tr>
<td></td>
<td>length</td>
<td>u2</td>
<td>UTF-8 编码的字符串占用的字节数</td>
</tr>
<tr>
<td></td>
<td>bytes</td>
<td>u1</td>
<td>长度为 length 的 UTF-8 编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>tag</td>
<td>u1</td>
<td>区分常量类型，值为 3</td>
</tr>
<tr>
<td></td>
<td>bytes</td>
<td>u4</td>
<td>按照高位在前（大端模式）存储的 int 值</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>tag</td>
<td>u1</td>
<td>区分常量类型，值为 4</td>
</tr>
<tr>
<td></td>
<td>bytes</td>
<td>u4</td>
<td>按照高位在前（大端模式）存储的 float 值</td>
</tr>
<tr>
<td>CONSTNAT_Long_info</td>
<td>tag</td>
<td>u1</td>
<td>区分常量类型，值为 5</td>
</tr>
<tr>
<td></td>
<td>bytes</td>
<td>u8</td>
<td>按照高位在前（大端模式）存储的 long 值</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>tag</td>
<td>u1</td>
<td>区分常量类型，值为 6</td>
</tr>
<tr>
<td></td>
<td>bytes</td>
<td>u8</td>
<td>按照高位在前（大端模式）存储的 double 值</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>tag</td>
<td>u1</td>
<td>区分常量类型，值为 7</td>
</tr>
<tr>
<td></td>
<td>index</td>
<td>u2</td>
<td>指向全限定名常量项的索引</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>tag</td>
<td>u1</td>
<td>区分常量类型，值为 8</td>
</tr>
<tr>
<td></td>
<td>index</td>
<td>u2</td>
<td>指向字符串字面量的索引</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>tag</td>
<td>u1</td>
<td>区分常量类型，值为 9</td>
</tr>
<tr>
<td></td>
<td>index</td>
<td>u2</td>
<td>指向声明字段的类或接口描述符 CONSTANT_Class_info 的索引项</td>
</tr>
<tr>
<td></td>
<td>index</td>
<td>u2</td>
<td>指向字段描述符 CONSTANT_NameAndType 的索引项</td>
</tr>
<tr>
<td>CONSTANT_Method-<br>ref_info</td>
<td>tag</td>
<td>u1</td>
<td>区分常量类型，值为 10</td>
</tr>
<tr>
<td></td>
<td>index</td>
<td>u2</td>
<td>指向声明方法的类描述符 CONSTANT_Class_info 的索引项</td>
</tr>
<tr>
<td></td>
<td>index</td>
<td>u2</td>
<td>指向名称及类型描述符 CONSTANT_NameAndType 的索引项</td>
</tr>
<tr>
<td>CONSTANT_Interface-<br>Methodref_info</td>
<td>tag</td>
<td>u1</td>
<td>区分常量类型，值为 11</td>
</tr>
<tr>
<td></td>
<td>index</td>
<td>u2</td>
<td>指向声明方法的类描述符 CONSTANT_Class_info 的索引项</td>
</tr>
<tr>
<td></td>
<td>index</td>
<td>u2</td>
<td>指向名称及类型描述符 CONSTANT_NameAndType 的索引项</td>
</tr>
<tr>
<td>CONSTANT_Name-<br>AndType_info</td>
<td>tag</td>
<td>u1</td>
<td>区分常量类型，值为 12</td>
</tr>
<tr>
<td></td>
<td>index</td>
<td>u2</td>
<td>指向字段或方法名称常量项的索引</td>
</tr>
<tr>
<td></td>
<td>index</td>
<td>u2</td>
<td>指向字段或方法描述符常量项的索引</td>
</tr>
<tr>
<td>CONSTANT_Method-<br>Handle_info</td>
<td>tag</td>
<td>u1</td>
<td>区分常量类型，值为 15</td>
</tr>
<tr>
<td></td>
<td>reference_kind</td>
<td>u1</td>
<td>值必须在 1 ~9 之间（包括 1 和 9），它决定了方法句柄的类型。方法句柄类型的值表示方法句柄的字节码行为</td>
</tr>
<tr>
<td></td>
<td>reference_index</td>
<td>u2</td>
<td>值必须是对常量池的有效索引</td>
</tr>
<tr>
<td>CONSTANT_Method-<br>Type_info</td>
<td>tag</td>
<td>u1</td>
<td>区分常量类型，值为 16</td>
</tr>
<tr>
<td></td>
<td>reference_kind</td>
<td>u1</td>
<td>值必须是对常量池的有效索引，常量池在该索引处的项必须是 CONSTANT_Utf8_info 结构，表示方法的描述符</td>
</tr>
<tr>
<td>CONSTANT_Invoke-<br>Dynamic_info</td>
<td>tag</td>
<td>u1</td>
<td>区分常量类型，值为 18</td>
</tr>
<tr>
<td></td>
<td>bootstrap_me-<br>thod_attr_index</td>
<td>u2</td>
<td>值必须是对当前 Class 文件中引导方法表的 bootstrap_methods[] 数组的有效索引</td>
</tr>
<tr>
<td></td>
<td>name_and_type_index</td>
<td>u2</td>
<td>值必须是对当前常量池的有效索引，常量池在该索引处必须是 CONSTANT_NameAndType_info 结构，表示方法名和方法描述符</td>
</tr>
</tbody></table>
<p>上述例子中，第 9 ~ 181 个字节表示的是常量池中的常量内容，具体表示含义如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 13                     常量池中的数量，值是19，说明有18个常量项</span><br><span class="line">0a                        CONSTANT_Methodref_info常量项，tag</span><br><span class="line">00 04                     指向声明方法的类描述符CONSTANT_Class_info的索引项, index, 值是4</span><br><span class="line">00 0f                     指向名称及类型描述符CONSTANT_NameAndType_info的索引项, index, 值是15</span><br><span class="line">09                        CONSTANT_Fieldref_info常量项，tag</span><br><span class="line">00 03                     指向声明字段的类或接口描述符CONSTANT_Class_info的索引项, index, 值是3</span><br><span class="line">00 10                     指向字段描述符CONSTANT_NameAndType_info的索引项, index, 值是16</span><br><span class="line">07                        CONSTANT_Class_info常量项，tag</span><br><span class="line">00 11                     指向全限定名称常量项的索引，index, 值是17</span><br><span class="line">07                        CONSTANT_Class_info常量项，tag</span><br><span class="line">00 12                     指向全限定名称常量项的索引，index, 值是18，</span><br><span class="line">01                        CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 01                     UTF-8编码的字符串占用的字节数，length, 值是1</span><br><span class="line">6d                        长度为 1 的UTF-8编码字符串，bytes, 值是m</span><br><span class="line">01                        CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 01                     UTF-8编码的字符串占用的字节数，length, 值是1</span><br><span class="line">49                        长度为 1 的UTF-8编码字符串，bytes, 值是I</span><br><span class="line">01                        CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 06                     UTF-8编码的字符串占用的字节数，length, 值是6</span><br><span class="line">3c 69 6e 69 74 3e         长度为 6 的UTF-8编码字符串，bytes, 值是&lt;init&gt;</span><br><span class="line">01                        CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 03                     UTF-8编码的字符串占用的字节数，length, 值是3</span><br><span class="line">28 29 56                  长度为 3 的UTF-8编码字符串，bytes, 值是()V</span><br><span class="line">01                        CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 04                     UTF-8编码的字符串占用的字节数，length, 值是4</span><br><span class="line">43 6f 64 65               长度为 4 的UTF-8编码字符串，bytes, 值是Code</span><br><span class="line">01                        CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 0f                     UTF-8编码的字符串占用的字节数，length, 值是15</span><br><span class="line">4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65    长度为 15 的UTF-8编码字符串，bytes, 值是LineNumberTable</span><br><span class="line">01                                              CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 03                                           UTF-8编码的字符串占用的字节数，length, 值是3</span><br><span class="line">69 6e 63                                        长度为 3 的UTF-8编码字符串，bytes, 值是inc</span><br><span class="line">01                                              CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 03                                           UTF-8编码的字符串占用的字节数，length, 值是3</span><br><span class="line">28 29 49                                        长度为 3 的UTF-8编码字符串，bytes, 值是()I</span><br><span class="line">01                                              CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 0a                                           UTF-8编码的字符串占用的字节数，length, 值是10</span><br><span class="line">53 6f 75 72 63 65 46 69 6c 65                   长度为 3 的UTF-8编码字符串，bytes, 值是SourceFile</span><br><span class="line">01                                              CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 1a                                           UTF-8编码的字符串占用的字节数，length, 值是26</span><br><span class="line">54 65 73 74 4a 76 6d 43 6c 61 73 73 53 74 72 75 63 74 75 72 65 2e 6a 61 76 61       长度为 26 的UTF-8编码字符串，bytes, 值是TestJvmClassStructure.java</span><br><span class="line">0c                                                      CONSTANT_NameAndType_info常量项, tag </span><br><span class="line">00 07                                                   指向该字符安或方法名称常量项的索引项, index, 值是7</span><br><span class="line">00 08                                                   指向该字符安或方法描述符常量项的索引项, index, 值是8</span><br><span class="line">0c                                                      CONSTANT_NameAndType_info常量项, tag </span><br><span class="line">00 05                                                   指向该字符安或方法名称常量项的索引项, index, 值是5</span><br><span class="line">00 06                                                   指向该字符安或方法描述符常量项的索引项, index, 值是6</span><br><span class="line">01                                                      CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 15                                                   UTF-8编码的字符串占用的字节数，length, 值是21</span><br><span class="line">54 65 73 74 4a 76 6d 43 6c 61 73 73 53 74 72 75 63 74 75 72 65      长度为 21 的UTF-8编码字符串，bytes, 值是TestJvmClassStructure</span><br><span class="line">01                                                      CONSTANT_NameAndType_info常量项, tag</span><br><span class="line">00 10                                                   UTF-8编码的字符串占用的字节数，length, 值是16</span><br><span class="line">6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74         长度为 16 的UTF-8编码字符串，bytes, 值是java/lang/Object</span><br></pre></td></tr></table></figure>

<p>执行 javap 命令对 class 文件进行反编译，可以看到其常量池如下所示，与上述字节码的解析相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">4.</span>#<span class="number">15</span>         <span class="comment">//  java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">3.</span>#<span class="number">16</span>         <span class="comment">//  TestJvmClassStructure.m:I</span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">17</span>            <span class="comment">//  TestJvmClassStructure</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">18</span>            <span class="comment">//  java/lang/Object</span></span><br><span class="line">   #<span class="number">5</span> = Utf8               m</span><br><span class="line">   #<span class="number">6</span> = Utf8               I</span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               inc</span><br><span class="line">  #<span class="number">12</span> = Utf8               ()I</span><br><span class="line">  #<span class="number">13</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">14</span> = Utf8               TestJvmClassStructure.java</span><br><span class="line">  #<span class="number">15</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">//  &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">16</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">//  m:I</span></span><br><span class="line">  #<span class="number">17</span> = Utf8               TestJvmClassStructure</span><br><span class="line">  #<span class="number">18</span> = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure>

<h1 id="文件访问标志"><a href="#文件访问标志" class="headerlink" title="文件访问标志"></a>文件访问标志</h1><p>在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个 class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。具体的标志位及其标志的含义如下所示</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>是否为 public 类型，如果是，取值为 0x0001，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>是否被声明为 final，如果是，取值为 0x0010，否则为 0x0000，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>是否允许使用 invokespecial字节码指令的新语义， invokespecial 指令的语义在 JDK 1.0.2 发生过改变，为了区别这条指令使用哪种语义， JDK 1.0.2 之后编译出来的类的这个标志都必须为真</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>是否是一个接口，如果是，取值为 0x0200，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_ABSTARCT</td>
<td>0x0400</td>
<td>是否为 abstract 类型，对于接口或者抽象类来说，此值为 0x0400，其他类值为 0x0000</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>该 class 文件是否非用户代码产生，如果是，取值为 0x1000，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>是否是一个注解，如果是，取值为 0x2000，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>是否是一个枚举，如果是，取值为 0x4000，否则为 0x0000</td>
</tr>
</tbody></table>
<p>对于这些标志位，可能只会用到一部分，对于用到的标志位，将其标志值进行或运算得到最终的标志值，对于没用到的标志位，其值不参与运算（或者说其值为 0）。</p>
<p>对于上述的例子，第 182 ~ 183 个字节是<code>00 21</code>，是由 0x0001 和 0x0020 或运算得到的，所以ACC_PUBLIC、ACC_SUPER为真，ACC_FINAL、ACC_INFERFACE、ACC_ABSTRACT、ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM为假，即说明这是一个非 final 的被 public 修饰的类。</p>
<h1 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h1><p>类索引（this_class）和父类索引（super_class）都是一个 u2 类型的数据，而接口索引集合（interfaces）是一组 u2 类型的数据的集合。class 文件中由这三项数据来确定这个类的继承关系，其中类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，接口索引集合用于描述这个类实现的接口。</p>
<p>类索引和父类索引都指向一个类型为 CONSTANT_Class_info 的类描述符常量，通过 CONSTANT_Class_info 类型的常量中的索引值可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。</p>
<p>上述例子中，第 184 ~ 187 个字节表示类索引和父类索，引对应的值如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 03    本类索引，this_class，对应到第 3 个常量项，得知指向第 17 个常量项，值是TestJvmClassStructure</span><br><span class="line">00 04    父类索引，super_calss，对应到第 4 个常量项，得知指向第 18 个常量项，值是java/lang/Object</span><br></pre></td></tr></table></figure>

<p>对于接口索引集合，首先用一个 u2 的数据类型的数据来表示接口的数量 n ，紧接着跟着 n 个 u2 数据类型的接口索引，跟类索引和父类索引一样，也是指向一个类型为 CONSTANT_Class_info 的类描述符常量，通过 CONSTANT_Class_info 类型的常量中的索引值可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。然而，如果表示接口数量的 u2 数据类型的数据为 0，则后面接口的索引表不占任何字节，即后面直接跟着字段表集合。</p>
<p>上述例子中，第 188 ~ 189 个字节表示接口索引信息，由于没有接口，故接口数量为 0，其字节码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00    接口索引集合大小，值是0，表示没有实现接口</span><br></pre></td></tr></table></figure>

<h1 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h1><p>字段表（field_info）用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但是不包括在方法内部声明的局部变量。字段表集合中不会列出从父类或者父接口中继承而来的字段，但有可能列出原本 java 代码中不存在的字段，比如在内部类中为了保持对外部类的访问性，为自动添加指向外部类实例的字段。</p>
<p>字段表的结构如下所示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>access_flags</td>
<td>u2</td>
<td>1</td>
<td>字段修饰符，用于判断字段的访问权限等信息</td>
</tr>
<tr>
<td>name_index</td>
<td>u2</td>
<td>1</td>
<td>对常量池中常量的引用，表示字段的简单名称</td>
</tr>
<tr>
<td>descriptor_index</td>
<td>u2</td>
<td>1</td>
<td>对常量池中常量的引用，表示字段和方法的描述符</td>
</tr>
<tr>
<td>attributes_count</td>
<td>u2</td>
<td>1</td>
<td>属性表中属性的数量</td>
</tr>
<tr>
<td>attributes</td>
<td>attribute_info</td>
<td>attributes_count</td>
<td>属性表中属性的信息</td>
</tr>
</tbody></table>
<p>其中 access_flags 与文件访问标志类似，其定义的标志名称的值在该标志位为真时取对应的值，为假时取 0，最终将所有标志位进行与运算得到最后结果。其具体项及其含义如下所示</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>字段是否为 public 类型，如果是，取值为 0x0001，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>字段是否是 private 类型，如果是，取值为 0x0002，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>字段是否是 protected 类型，如果是，取值为 0x0004，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>字段是否是 static 类型，如果是，取值为 0x0008，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>字段是否是 final 类型，如果是，取值为 0x0010，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>字段是否是 volatile 类型，如果是，取值为 0x0040，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_TRANSIENT</td>
<td>0x0080</td>
<td>字段是否是transient 类型，如果是，取值为 0x0080，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>字段是否由编译器自动产生，如果是，取值为 0x1000，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>字段是否是 enum 类型，如果是，取值为 0x4000，否则为 0x0000</td>
</tr>
</tbody></table>
<p>上述例子中，第 190 ~ 199 个字节表示字段表信息，其具体含义如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 01        字段表中字段的数量，值是1</span><br><span class="line">00 02        字段访问标志，access_flags，0x0002表示ACC_PRIVATE为真，其他标志符为假</span><br><span class="line">00 05        字段的简单名称，name_index，对应到第 5 个常量，值是m</span><br><span class="line">00 06        字段的描述符，descriptor_index，对应到第 6 个常量，值是I</span><br><span class="line">00 00        字段的属性表中属性数量，值是0</span><br></pre></td></tr></table></figure>

<h1 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h1><p>方法表的结构与字段表一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。其含义如下所示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>access_flags</td>
<td>u2</td>
<td>1</td>
<td>方法修饰符，用于判断方法的访问权限等信息</td>
</tr>
<tr>
<td>name_index</td>
<td>u2</td>
<td>1</td>
<td>对常量池中常量的引用，表示方法的简单名称</td>
</tr>
<tr>
<td>descriptor_index</td>
<td>u2</td>
<td>1</td>
<td>对常量池中常量的引用，表示字段和方法的描述符</td>
</tr>
<tr>
<td>attributes_count</td>
<td>u2</td>
<td>1</td>
<td>属性表中属性的数量</td>
</tr>
<tr>
<td>attributes</td>
<td>attribute_info</td>
<td>attributes_count</td>
<td>属性表中属性的信息</td>
</tr>
</tbody></table>
<p>其中 access_flags 与文件访问标志类似，其定义的标志名称的值在该标志位为真时取对应的值，为假时取 0，最终将所有标志位进行与运算得到最后结果。其具体项及其含义如下所示</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>方法是否为 public 类型，如果是，取值为 0x0001，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>方法是否是 private 类型，如果是，取值为 0x0002，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>方法是否是 protected 类型，如果是，取值为 0x0004，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>方法是否是 static 类型，如果是，取值为 0x0008，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>方法是否是 final 类型，如果是，取值为 0x0010，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_SYNCHRONIZED</td>
<td>0x0020</td>
<td>方法是否是 synchronized 类型，如果是，取值为 0x0020，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_BRIDGE</td>
<td>0x0040</td>
<td>方法是否由编译器产生的桥接方法，如果是，取值为 0x0040，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_VARAGS</td>
<td>0x0080</td>
<td>方法是否接收不定参数，如果是，取值为 0x0080，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_NATIVE</td>
<td>0x0100</td>
<td>方法是否是 native 类型，如果是，取值为 0x0100，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>方法是否是 abstract 类型，如果是，取值为 0x0400，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_STRICTFP</td>
<td>0x0800</td>
<td>方法是否是 strictfp 类型，如果是，取值为 0x0800，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>方法是否由编译器自动产生，如果是，取值为 0x1000，否则为 0x0000</td>
</tr>
</tbody></table>
<p>需要注意的是，虽然实例构造函数 <code>&lt;init&gt;</code> 和类构造函数 <code>&lt;clinit&gt;</code> 也可以由编译器自动生成，但是，这两个函数的 ACC_SYNTHETIC 仍然为假。另外，如果父类方法在子类中没有被重写（override），方法表集合中就不会出现来自父类的方法信息。</p>
<p>上述例子中，第 200 ~ 289 个字节表示方法表的信息，其具体含义如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 02          方法表中方法的数量，值是2</span><br><span class="line">00 01          方法访问标志，access_flags，0x0001表示ACC_PUBLIC为真，其他标志符为假</span><br><span class="line">00 07          方法的简单名称，name_index，对应到第 7 个常量，值是&lt;init&gt;</span><br><span class="line">00 08          方法的描述符，descriptor_index，对应到第 8 个常量，值是()V</span><br><span class="line">00 01          方法的属性表中属性数量，值是1</span><br><span class="line">00 09          属性名称索引，attribute_name_index，对应到第 9 个常量，值是Code</span><br><span class="line">00 00 00 1d    属性字节长度，attribute_length，值是29</span><br><span class="line">00 01          Code属性中操作数栈深度的最大值，max_stack，值是1</span><br><span class="line">00 01          Code属性中局部变量表所需的存储空间，max_locals，单位是Slot，值是1</span><br><span class="line">00 00 00 05    字节码指令字节长度，值是5</span><br><span class="line">2a             虚拟机指令 aload_0，将第一个引用类型本地变量推送值栈顶</span><br><span class="line">b7             虚拟机指令 invokespecial，实例初始化方法，构造函数调用，后续有个 u2 类型参数说明调用的是哪个方法</span><br><span class="line">00 01          invokespecial 参数，指向常量池中第 1 个常量，得知值是java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">b1             虚拟机指令 return，从当前方法返回 void</span><br><span class="line">00 00          Code属性中异常表数量，exception_table_length，值是0</span><br><span class="line">00 01          Code属性中属性数量，attributes_count，值是1</span><br><span class="line">00 0a          属性名称索引，attribute_name_index，对应到第 10 个常量，值是LineNumberTable</span><br><span class="line">00 00 00 06    属性字节长度，attribute_length，值是6</span><br><span class="line">00 01          LineNumberTable属性中line_number_table数量，line_number_table_length，值是1</span><br><span class="line">00 00 00 01    LineNumberTable属性中line_number_info表，包括一个u2的start_pc和一个u2的line_number，分别表示字节码相对于方法体开始的偏移量（值是0），后者表示java源码的行号（值是1）</span><br><span class="line"></span><br><span class="line">               // init方法完毕</span><br><span class="line"></span><br><span class="line">00 01          方法访问标志，access_flags，0x0001表示ACC_PUBLIC为真，其他标志符为假</span><br><span class="line">00 0b          方法的简单名称，name_index，对应到第 11 个常量，值是inc</span><br><span class="line">00 0c          方法的描述符，descriptor_index，对应到第 12 个常量，值是()I</span><br><span class="line">00 01          方法的属性表中属性数量，值是1</span><br><span class="line">00 09          属性名称索引，attribute_name_index，对应到第 9 个常量，值是Code</span><br><span class="line">00 00 00 1f    属性字节长度，attribute_length，值是31</span><br><span class="line">00 02          Code属性中操作数栈深度的最大值，max_stack，值是2</span><br><span class="line">00 01          Code属性中局部变量表所需的存储空间，max_locals，单位是Slot，值是1</span><br><span class="line">00 00 00 07    字节码指令字节长度，值是7</span><br><span class="line">2a             虚拟机指令 aload_0，将第一个引用类型本地变量推送值栈顶</span><br><span class="line">b4             虚拟机指令 getfield，获取指定类的实例域，并将其值压入栈顶，后续有个u2类型参数说明压入栈顶的是哪个变量</span><br><span class="line">00 02          getfield 参数，指向常量池中第 2 个常量，得知值是TestJvmClassStructure.m:I</span><br><span class="line">04             虚拟机指令 iconst_1，将int型 1 推送至栈顶</span><br><span class="line">60             虚拟机指令 iadd，将栈顶两个 int 型相加，并将结果压入栈顶</span><br><span class="line">ac             虚拟机指令 ireturn，从当前方法返回 int</span><br><span class="line">00 00          Code属性中异常表数量，exception_table_length，值是0</span><br><span class="line">00 01          Code属性中属性数量，attributes_count，值是1</span><br><span class="line">00 0a          属性名称索引，attribute_name_index，对应到第 10 个常量，值是LineNumberTable</span><br><span class="line">00 00 00 06    属性字节长度，attribute_length，值是6</span><br><span class="line">00 01          LineNumberTable属性中line_number_table数量，line_number_table_length，值是1</span><br><span class="line">00 00 00 06    LineNumberTable属性中line_number_info表，包括一个u2的start_pc和一个u2的line_number，分别表示字节码相对于方法体开始的偏移量（值是0），后者表示java源码的行号（值是6）</span><br></pre></td></tr></table></figure>

<h1 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h1><p>属性表是比较“自由”的一种数据结构，其不同于字段表或方法表等有严格的顺序限制，其可以自由地定义顺序，并且只要不与已有属性名重复，任何编译器都可以向属性表中写入自己定义的独特的不同于其他编译器的属性信息，在解析时，java 虚拟机会自动忽略其不认识的属性。因此，不同的厂商实现的编译器的属性表会有所不同。</p>
<p>为了能够正确解析 class 文件，java 虚拟机规范中预定义了一些属性，其一部分属性及其含义如下所示</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Code</td>
<td>方法表</td>
<td>java 代码编译成的字节码指令</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>字段表</td>
<td>final 关键字定义的常量值</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类、方法表、字段表</td>
<td>被声明为 deprecated 的方法和字段</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>EnclosingMethod</td>
<td>类文件</td>
<td>仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td>
</tr>
<tr>
<td>InnerClasses</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>Code属性</td>
<td>java 源码的行号与字节码指令的对应关系</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>Code属性</td>
<td>方法的局部变量描述</td>
</tr>
<tr>
<td>StackMapTable</td>
<td>Code属性</td>
<td>JDK 1.6 中新增的属性，供新的类型检查验证器（Type Checker）检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配</td>
</tr>
<tr>
<td>Signature</td>
<td>类、方法表、字段表</td>
<td>JDK 1.5 中新增的属性，这个属性用于支持泛型情况下的方法签名，在 java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameerized Types），则 Signature 属性会为它记录泛型签名信息。由于 java 的泛型采用擦除法实现，在为了避免类型信息被擦除后导致签名混乱，需要这个属性记录泛型中的相关信息</td>
</tr>
<tr>
<td>SourceFile</td>
<td>类文件</td>
<td>记录源文件名称</td>
</tr>
<tr>
<td>SourceDebugExtension</td>
<td>类文件</td>
<td>JDK 1.6 中新增的属性，SourceDebugExtension 属性用于存储额外的调试信息。譬如在进行 JSP 文件调试时，无法通过 java 堆栈来定位到 JSP 文件的行号，JSR-45 规范为这些非 java 语言编写，却需要编译成字节码并运行在 java 虚拟机中的程序提供了一个进行调试的标准机制，使用 SourceDebugExtension 属性就可以用于存储这个标准所新加入的调试信息</td>
</tr>
<tr>
<td>Synthetic</td>
<td>类、方法表、字段表</td>
<td>标识方法或字段为编译器自动生成的</td>
</tr>
<tr>
<td>LocalVariableTypeTable</td>
<td>类</td>
<td>JDK 1.5 中新增的属性，它使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型</td>
</tr>
<tr>
<td>RuntimeVisibleAnnotations</td>
<td>类、方法表、字段表</td>
<td>JDK 1.5 中新增的属性，为动态注解提供支持。RuntimeVisibleAnnotations 属性用于指明哪些注解是运行时（实际上运行时就是进行反射调用）可见的</td>
</tr>
<tr>
<td>RuntimeInvisibleAnnotations</td>
<td>类、方法表、字段表</td>
<td>JDK 1.5 中新增的属性，与 RuntimeVisibleAnnotations 属性作用刚好相反，用于指明哪些注解是运行时不可见的</td>
</tr>
<tr>
<td>RuntimeVisibleParameter-<br>Annotaions</td>
<td>方法表</td>
<td>JDK 1.5 中新增的属性，与 RuntimeVisibleAnnotations 属性类似，只不过作用对象为方法参数</td>
</tr>
<tr>
<td>RuntimeInvisibleParameter-<br>Annotaions</td>
<td>方法表</td>
<td>JDK 1.5 中新增的属性，与 RuntimeInvisibleAnnotations属性类似，只不过作用对象为方法参数</td>
</tr>
<tr>
<td>AnnotationDefault</td>
<td>方法表</td>
<td>JDK 1.5 中新增的属性，用于记录注解类元素的默认值</td>
</tr>
<tr>
<td>BootstrapMethods</td>
<td>类文件</td>
<td>JDK 1.7 中新增的属性，用于保存 invokedynamic 指令引用的引导方法限定符</td>
</tr>
</tbody></table>
<p>对于每个属性，它的名称需要从常量池中引用一个 CONSTANT_Utf8_info 类型的常量来表示，而属性值的结构则是自己定义的，值需要通过一个 u4 的长度属性说明属性值占用的位数即可。属性表的结构如下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td>对常量池中常量的引用，表示属性类型名称</td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td>该类型属性所占的字节码长度</td>
</tr>
<tr>
<td>info</td>
<td>u1</td>
<td>attribute_length</td>
<td>该类型属性的具体字节码</td>
</tr>
</tbody></table>
<h2 id="Code-属性"><a href="#Code-属性" class="headerlink" title="Code 属性"></a>Code 属性</h2><p>Code属性主要是用于存放 java 方法体的相关内容的字节码信息。其结构如下所示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td>属性名称，指向 CONSTANT_Utf8_info 的常量索引，固定是 “Code”</td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td>属性内容信息占有的字节码长度</td>
</tr>
<tr>
<td>max_stack</td>
<td>u2</td>
<td>1</td>
<td>操作数栈深度的最大值。在方法执行的任何时候操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度</td>
</tr>
<tr>
<td>max_locals</td>
<td>u2</td>
<td>1</td>
<td>局部变量表所需的存储空间，单位是 Solt。Slot 是虚拟机为局部变量分配内存所使用的最小单位。对于 byte、char、float、int、short、boolean 和 retruanAddress 等长度不超过 32 位的数据类型，用 1 个 Slot 存放。对于 double 和 long 这两种 64 位的数据类型则需要 2 个Slot。</td>
</tr>
<tr>
<td>code_length</td>
<td>u4</td>
<td>1</td>
<td>字节码指令长度</td>
</tr>
<tr>
<td>code</td>
<td>u1</td>
<td>code_length</td>
<td>字节码指令</td>
</tr>
<tr>
<td>exception_table_length</td>
<td>u2</td>
<td>1</td>
<td>显示异常处理表长度，用于表示方法体内的异常</td>
</tr>
<tr>
<td>exception_table</td>
<td>exception_info</td>
<td>exception_table_length</td>
<td>显示异常处理表信息</td>
</tr>
<tr>
<td>attributes_count</td>
<td>u2</td>
<td>1</td>
<td>属性表中属性数量</td>
</tr>
<tr>
<td>attributes</td>
<td>attribute_info</td>
<td>attributes_count</td>
<td>属性表中属性信息</td>
</tr>
</tbody></table>
<p>其中异常表（exception_table）的数据结构如下，其表示在 start_pc 到 end_pc (不包括 end_pc 本身)之间出现了类型为 catch_type 或者子类的异常，则跳转到 handle_pc 处继续执行。当 catch_type 值是 0 时，代表任意异常情况都需要转向 handler_pc 处进行处理。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>start_pc</td>
<td>u2</td>
<td>1</td>
<td>可能发生异常的开始的地方</td>
</tr>
<tr>
<td>end_pc</td>
<td>u2</td>
<td>1</td>
<td>被包裹的异常块的结束位置</td>
</tr>
<tr>
<td>handler_pc</td>
<td>u2</td>
<td>1</td>
<td>处理异常的入口处</td>
</tr>
<tr>
<td>catch_type</td>
<td>u2</td>
<td>1</td>
<td>指向一个 CONSTANT_Class_info 型常量的索引，表示异常的类型，如果为 0，表示接受任何类型</td>
</tr>
</tbody></table>
<h2 id="Exceptions-属性"><a href="#Exceptions-属性" class="headerlink" title="Exceptions 属性"></a>Exceptions 属性</h2><p>Exceptions 属性的作用是列举出方法中可能抛出的受检异常（Checked Exceptions），也就是方法描述是在 throws 关键字后面列举的异常。不同于 Code 属性中的异常，Code 属性中的异常表示的是方法体内的 try-catch块。Exceptions 属性的结构如下所示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td>属性名称，指向 CONSTANT_Utf8_info 的常量索引，固定是 “Exceptions”</td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td>属性内容信息占有的字节码长度</td>
</tr>
<tr>
<td>number_of_exceptions</td>
<td>u2</td>
<td>1</td>
<td>方法抛出的受检异常的数量</td>
</tr>
<tr>
<td>exception_index_table</td>
<td>u2</td>
<td>number_of_exceptions</td>
<td>一个指向常量池中的 CONSTANT_Class_info 型常量的索引，表示受检异常的类型</td>
</tr>
</tbody></table>
<h2 id="LineNumberTable-属性"><a href="#LineNumberTable-属性" class="headerlink" title="LineNumberTable 属性"></a>LineNumberTable 属性</h2><p>LineNumberTable 属性用于描述 java 源码行号与字节码行号（字节码的偏移量）之间的对应关系。这并不是运行时的必需属性，但是默认为生成到 class 文件中，可以在 javac 中分别使用 -g:none 选项来取消生成这项信息，也可以使用 -g:lines 选项来生成这项信息。其结构如下所示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td>属性名称，指向 CONSTANT_Utf8_info 的常量索引，固定是 “LineNumberTable”</td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td>属性内容信息占有的字节码长度</td>
</tr>
<tr>
<td>line_number_table_length</td>
<td>u2</td>
<td>1</td>
<td>line_number_table 项的数量</td>
</tr>
<tr>
<td>line_number_table</td>
<td>line_number_info</td>
<td>line_number_table_length</td>
<td>字节码与 java 源码行号对应关系</td>
</tr>
</tbody></table>
<p>其中 line_number_table 的数据结构如下所示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>start_pc</td>
<td>u2</td>
<td>1</td>
<td>字节码的偏移量</td>
</tr>
<tr>
<td>line_number</td>
<td>u2</td>
<td>1</td>
<td>java 源码行号</td>
</tr>
</tbody></table>
<h2 id="LocalVariableTable-属性"><a href="#LocalVariableTable-属性" class="headerlink" title="LocalVariableTable 属性"></a>LocalVariableTable 属性</h2><p>LocalVariableTable 属性用于描述栈帧中局部变量表中变量与 java 源码中定义的变量之间的关系，这不是运行时必需的属性，但是默认会生成到 class 文件中。可以在 javac 命令中使用 -g:none 选项来取消生成这项信息，也可以使用 -g:vars 选项要求生成这项信息。其结构如下所示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td>属性名称，指向 CONSTANT_Utf8_info 的常量索引，固定是 “LocalVariableTable”</td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td>属性内容信息占有的字节码长度</td>
</tr>
<tr>
<td>local_variable_table-<br>_length</td>
<td>u2</td>
<td>1</td>
<td>局部变量表数量</td>
</tr>
<tr>
<td>local_variable_table</td>
<td>local_variable_info</td>
<td>local_variable_table-<br>_length</td>
<td>局部变量表信息</td>
</tr>
</tbody></table>
<p>其中 local_variable_table 的结构如下所示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>start_pc</td>
<td>u2</td>
<td>1</td>
<td>局部变量的生命周期开始的字节码偏移量</td>
</tr>
<tr>
<td>length</td>
<td>u2</td>
<td>1</td>
<td>局部变量的生命周期的作用范围的长度</td>
</tr>
<tr>
<td>name_index</td>
<td>u2</td>
<td>1</td>
<td>指向常量池中 CONSTANT_Utf8_info 型常量的索引，表示局部变量的名称</td>
</tr>
<tr>
<td>descriptor_index</td>
<td>u2</td>
<td>1</td>
<td>指向常量池中 CONSTANT_Utf8_info 型常量的索引，表示局部变量的描述符</td>
</tr>
<tr>
<td>index</td>
<td>u2</td>
<td>1</td>
<td>表示局部变量在栈帧局部变量表中 Slot 的位置。当这个变量的数据类型是 64 位类型（double 和 long）时，它占用的 Slot 为 index 和 index + 1 两个</td>
</tr>
</tbody></table>
<h2 id="SourceFile-属性"><a href="#SourceFile-属性" class="headerlink" title="SourceFile 属性"></a>SourceFile 属性</h2><p>SourceFile 属性用于记录生成这个 class 文件的源码文件名称，这是一个可选的属性，默认情况下会生成。可以在javac 命令中使用 -g:none 选项来取消生成这项信息，也可以使用 -g:source 选项明确要求生成这项信息。其结构如下图所示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td>属性名称，指向 CONSTANT_Utf8_info 的常量索引，固定是 “SourceFile”</td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td>属性内容信息占有的字节码长度</td>
</tr>
<tr>
<td>source_index</td>
<td>u2</td>
<td>1</td>
<td>指向常量池中 CONSTANT_Utf8_info 型常量的索引，表示源码文件的文件名</td>
</tr>
</tbody></table>
<p>上述例子中，第 290 ~ 299 个字节表示 SourceFile 属性信息，其具体含义如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 01               属性数量，值是1</span><br><span class="line">00 0d               属性名称索引，attribute_name_index，对应到第 13 个常量，值是SourceFile</span><br><span class="line">00 00 00 02         属性字节长度，attribute_length，值是2</span><br><span class="line">00 0e               SourceFile属性中源码文件名称索引，sourcefile_index，指向第 14 个常量，值是TestJvmClassStructure.java</span><br></pre></td></tr></table></figure>

<h2 id="ConstantValue-属性"><a href="#ConstantValue-属性" class="headerlink" title="ConstantValue 属性"></a>ConstantValue 属性</h2><p>ConstantValue 属性的作用是通知虚拟机自动为静态变量赋值，只有被 static 关键字修改时的变量（类变量）才可以使用这个属性。其结构如下所示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td>属性名称，指向 CONSTANT_Utf8_info 的常量索引，固定是 “ConstantValue”</td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td>属性内容信息占有的字节码长度</td>
</tr>
<tr>
<td>constantvalue_index</td>
<td>u2</td>
<td>1</td>
<td>指向常量池中字面常量的引用。根据字段类型的不同，字面量可以是 CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_String_info 常量中的一种</td>
</tr>
</tbody></table>
<h2 id="InnerClasses-属性"><a href="#InnerClasses-属性" class="headerlink" title="InnerClasses 属性"></a>InnerClasses 属性</h2><p>InnerClasses 属性用于记录内部类与宿主类之间的关联，其结构如下所示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td>属性名称，指向 CONSTANT_Utf8_info 的常量索引，固定是 “InnerClasses”</td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td>属性内容信息占有的字节码长度</td>
</tr>
<tr>
<td>number_of_classes</td>
<td>u2</td>
<td>1</td>
<td>需要记录的内部类的数量</td>
</tr>
<tr>
<td>inner_classes</td>
<td>inner_classes_info</td>
<td>number_of_classes</td>
<td>需要记录的内部类的信息</td>
</tr>
</tbody></table>
<p>其中 inner_classes 的结构如下所示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>inner_class_info_index</td>
<td>u2</td>
<td>1</td>
<td>指向常量池中 CONSTANT_Class_info 型常量的索引，表示内部类的符号引用</td>
</tr>
<tr>
<td>outer_class_info_index</td>
<td>u2</td>
<td>1</td>
<td>指向常量池中 CONSTANT_Class_info 型常量的索引，表示宿主类的符号引用</td>
</tr>
<tr>
<td>inner_name_index</td>
<td>u2</td>
<td>1</td>
<td>指向常量池中 CONSTANT_Utf8_info 型常量的索引，表示内部类的名称，如果是匿名内部类，则值是 0</td>
</tr>
<tr>
<td>inner_class_access_flags</td>
<td>u2</td>
<td>1</td>
<td>内部类的访问标志</td>
</tr>
</tbody></table>
<p>其中 inner_class_access_flags 文件访问标志类似，其定义的标志名称的值在该标志位为真时取对应的值，为假时取 0，最终将所有标志位进行与运算得到最后结果。其具体项及其含义如下所示</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>内部类是否为 public 类型，如果是，取值为 0x0001，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>内部类是否是 private 类型，如果是，取值为 0x0002，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>内部类是否是 protected 类型，如果是，取值为 0x0004，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>内部类是否是 static 类型，如果是，取值为 0x0008，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>内部类是否是 final 类型，如果是，取值为 0x0010，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0020</td>
<td>内部类是否是接口，如果是，取值为 0x0020，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>内部类是否是 abstract 类型，如果是，取值为 0x0400，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>内部类是否由编译器自动产生，如果是，取值为 0x1000，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>内部类是否是一个注解，如果是，取值为 0x2000，否则为 0x0000</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>内部类是否是一个枚举类型，如果是，取值为 0x4000，否则为 0x0000</td>
</tr>
</tbody></table>
<h2 id="Deprecated-属性"><a href="#Deprecated-属性" class="headerlink" title="Deprecated 属性"></a>Deprecated 属性</h2><p>Deprecated 属性用于表示某个类、字段或者方法是否已经被程序作者标注为不推荐使用，对应 java 代码中的 <code>@deprecated</code> 注解。这是一个布尔属性，只存在有和没有的区别，没有属性值的概念。也就是说，要么在 class 文件中 没有这个属性，要么存在这个属性，但是属性长度为 0。其结构如下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td>属性名称，指向 CONSTANT_Utf8_info 的常量索引，固定是 “Deprecated”</td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td>值为固定值，0x00000000</td>
</tr>
</tbody></table>
<h2 id="Synthetic-属性"><a href="#Synthetic-属性" class="headerlink" title="Synthetic 属性"></a>Synthetic 属性</h2><p>Synthetic 属性代表此字段或者方法并不是由 java 源码直接产生的，而是由编译器自行添加的。需要注意的是，实例构造器 <code>&lt;init&gt;</code> 和类构造器 <code>&lt;clinit&gt;</code> 虽然也可以由编译器自动生成，但是此时值为假。与 Deprecated 属性一样，这也是一个布尔属性。其结构如下所示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td>属性名称，指向 CONSTANT_Utf8_info 的常量索引，固定是 “Synthetic”</td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td>值为固定值，0x00000000</td>
</tr>
</tbody></table>
<h2 id="Signature-属性"><a href="#Signature-属性" class="headerlink" title="Signature 属性"></a>Signature 属性</h2><p>Signature 属性主要用于记录泛型签名信息，其结构如下所示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td>属性名称，指向 CONSTANT_Utf8_info 的常量索引，固定是 “Signature”</td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td>属性内容信息占有的字节码长度</td>
</tr>
<tr>
<td>signature_index</td>
<td>u2</td>
<td>1</td>
<td>指向常量池中 CONSTANT_Utf8_info 型常量的索引，表示类签名、方法类型签名或字段类型签名</td>
</tr>
</tbody></table>
<h2 id="BootstrapMethods-属性"><a href="#BootstrapMethods-属性" class="headerlink" title="BootstrapMethods 属性"></a>BootstrapMethods 属性</h2><p>BootstrapMethods 属性用于保存 invokedynamic 指令引用的引导方法限定符。如果某个类文件结构的常量池中曾经出现过 CONSTANT_InvokeDynamic_info 类型的常量，那么这个类文件的属性表中必须存在一个明确的 BootstrapMethods 属性，另外，即使 CONSTANT_InvokeDynamic_info 类型的常量在常量池中出现过多次，类文件的属性表中最多也只有一个 BootstrapMethods 属性。其结构如下所示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>attribute_name_index</td>
<td>u2</td>
<td>1</td>
<td>属性名称，指向 CONSTANT_Utf8_info 的常量索引，固定是 “BootstrapMethods”</td>
</tr>
<tr>
<td>attribute_length</td>
<td>u4</td>
<td>1</td>
<td>属性内容信息占有的字节码长度</td>
</tr>
<tr>
<td>num_bootstrap_methods</td>
<td>u2</td>
<td>1</td>
<td>引导方法限定符的数量</td>
</tr>
<tr>
<td>bootstrap_methods</td>
<td>bootstrap_method</td>
<td>num_bootstrap_methods</td>
<td>引导方法信息</td>
</tr>
</tbody></table>
<p>其中 bootstrap_methods 结构如下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>bootstrap_method_ref</td>
<td>u2</td>
<td>1</td>
<td>指向常量池中 CONSTANT_MethodHandle_info 型常量的索引</td>
</tr>
<tr>
<td>num_bootstrap_arg-<br>uments</td>
<td>u2</td>
<td>1</td>
<td>bootstrap_arguments[] 数组成员的数量</td>
</tr>
<tr>
<td>bootstrap_arguments</td>
<td>u2</td>
<td>num_bootstrap_arg-<br>uments</td>
<td>指向常量池中字面常量的引用。值必须是 CONSTANT_String_info、CONSTANT_Class_info、CONSTANT_Integer_info、 CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_MethodHandle_info、CONSTANT_MethodType_info 常量中的一种</td>
</tr>
</tbody></table>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="例子完整字节码解析"><a href="#例子完整字节码解析" class="headerlink" title="例子完整字节码解析"></a>例子完整字节码解析</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ca fe ba be               格式，固定值</span><br><span class="line">00 00 00 34               JDK版本号</span><br><span class="line">00 13                     常量池中的数量，值是19，说明有18个常量项</span><br><span class="line">0a                        CONSTANT_Methodref_info常量项，tag</span><br><span class="line">00 04                     指向声明方法的类描述符CONSTANT_Class_info的索引项, index, 值是4</span><br><span class="line">00 0f                     指向名称及类型描述符CONSTANT_NameAndType_info的索引项, index, 值是15</span><br><span class="line">09                        CONSTANT_Fieldref_info常量项，tag</span><br><span class="line">00 03                     指向声明字段的类或接口描述符CONSTANT_Class_info的索引项, index, 值是3</span><br><span class="line">00 10                     指向字段描述符CONSTANT_NameAndType_info的索引项, index, 值是16</span><br><span class="line">07                        CONSTANT_Class_info常量项，tag</span><br><span class="line">00 11                     指向全限定名称常量项的索引，index, 值是17</span><br><span class="line">07                        CONSTANT_Class_info常量项，tag</span><br><span class="line">00 12                     指向全限定名称常量项的索引，index, 值是18，</span><br><span class="line">01                        CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 01                     UTF-8编码的字符串占用的字节数，length, 值是1</span><br><span class="line">6d                        长度为 1 的UTF-8编码字符串，bytes, 值是m</span><br><span class="line">01                        CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 01                     UTF-8编码的字符串占用的字节数，length, 值是1</span><br><span class="line">49                        长度为 1 的UTF-8编码字符串，bytes, 值是I</span><br><span class="line">01                        CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 06                     UTF-8编码的字符串占用的字节数，length, 值是6</span><br><span class="line">3c 69 6e 69 74 3e         长度为 6 的UTF-8编码字符串，bytes, 值是&lt;init&gt;</span><br><span class="line">01                        CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 03                     UTF-8编码的字符串占用的字节数，length, 值是3</span><br><span class="line">28 29 56                  长度为 3 的UTF-8编码字符串，bytes, 值是()V</span><br><span class="line">01                        CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 04                     UTF-8编码的字符串占用的字节数，length, 值是4</span><br><span class="line">43 6f 64 65               长度为 4 的UTF-8编码字符串，bytes, 值是Code</span><br><span class="line">01                        CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 0f                     UTF-8编码的字符串占用的字节数，length, 值是15</span><br><span class="line">4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65    长度为 15 的UTF-8编码字符串，bytes, 值是LineNumberTable</span><br><span class="line">01                                              CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 03                                           UTF-8编码的字符串占用的字节数，length, 值是3</span><br><span class="line">69 6e 63                                        长度为 3 的UTF-8编码字符串，bytes, 值是inc</span><br><span class="line">01                                              CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 03                                           UTF-8编码的字符串占用的字节数，length, 值是3</span><br><span class="line">28 29 49                                        长度为 3 的UTF-8编码字符串，bytes, 值是()I</span><br><span class="line">01                                              CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 0a                                           UTF-8编码的字符串占用的字节数，length, 值是10</span><br><span class="line">53 6f 75 72 63 65 46 69 6c 65                   长度为 3 的UTF-8编码字符串，bytes, 值是SourceFile</span><br><span class="line">01                                              CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 1a                                           UTF-8编码的字符串占用的字节数，length, 值是26</span><br><span class="line">54 65 73 74 4a 76 6d 43 6c 61 73 73 53 74 72 75 63 74 75 72 65 2e 6a 61 76 61       长度为 26 的UTF-8编码字符串，bytes, 值是TestJvmClassStructure.java</span><br><span class="line">0c                        CONSTANT_NameAndType_info常量项, tag </span><br><span class="line">00 07                     指向该字符安或方法名称常量项的索引项, index, 值是7</span><br><span class="line">00 08                     指向该字符安或方法描述符常量项的索引项, index, 值是8</span><br><span class="line">0c                        CONSTANT_NameAndType_info常量项, tag </span><br><span class="line">00 05                     指向该字符安或方法名称常量项的索引项, index, 值是5</span><br><span class="line">00 06                     指向该字符安或方法描述符常量项的索引项, index, 值是6</span><br><span class="line">01                        CONSTANT_Utf8_info常量项，tag</span><br><span class="line">00 15                     UTF-8编码的字符串占用的字节数，length, 值是21</span><br><span class="line">54 65 73 74 4a 76 6d 43 6c 61 73 73 53 74 72 75 63 74 75 72 65      长度为 21 的UTF-8编码字符串，bytes, 值是TestJvmClassStructure</span><br><span class="line">01                        CONSTANT_NameAndType_info常量项, tag</span><br><span class="line">00 10                     UTF-8编码的字符串占用的字节数，length, 值是16</span><br><span class="line">6a 61 76 61 2f 6c 61 6e   长度为 16 的UTF-8编码字符串，bytes, 值是java/lang/Object</span><br><span class="line"></span><br><span class="line">                          // 常量池完毕</span><br><span class="line"></span><br><span class="line">00 21                     访问标志，ACC_PUBLIC、ACC_SUPER为真，ACC_FINAL、ACC_INFERFACE、ACC_ABSTRACT、ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM为假，故值为 0x0001 | 0x0021 = 0x0021</span><br><span class="line">00 03                     本类索引，this_class，对应到第 3 个常量项，得知指向第 17 个常量项，值是TestJvmClassStructure</span><br><span class="line">00 04                     父类索引，super_calss，对应到第 4 个常量项，得知指向第 18 个常量项，值是java/lang/Object</span><br><span class="line">00 00                     接口索引集合大小，值是0，表示没有实现接口</span><br><span class="line">00 01                     字段表中字段的数量，值是1</span><br><span class="line">00 02                     字段访问标志，access_flags，0x0002表示ACC_PRIVATE为真，其他标志符为假</span><br><span class="line">00 05                     字段的简单名称，name_index，对应到第 5 个常量，值是m</span><br><span class="line">00 06                     字段的描述符，descriptor_index，对应到第 6 个常量，值是I</span><br><span class="line">00 00                     字段的属性表中属性数量，值是0</span><br><span class="line"></span><br><span class="line">                          // 字段表完毕</span><br><span class="line"></span><br><span class="line">00 02                     方法表中方法的数量，值是2</span><br><span class="line">00 01                     方法访问标志，access_flags，0x0001表示ACC_PUBLIC为真，其他标志符为假</span><br><span class="line">00 07                     方法的简单名称，name_index，对应到第 7 个常量，值是&lt;init&gt;</span><br><span class="line">00 08                     方法的描述符，descriptor_index，对应到第 8 个常量，值是()V</span><br><span class="line">00 01                     方法的属性表中属性数量，值是1</span><br><span class="line">00 09                     属性名称索引，attribute_name_index，对应到第 9 个常量，值是Code</span><br><span class="line">00 00 00 1d               属性字节长度，attribute_length，值是29</span><br><span class="line">00 01                     Code属性中操作数栈深度的最大值，max_stack，值是1</span><br><span class="line">00 01                     Code属性中局部变量表所需的存储空间，max_locals，单位是Slot，值是1</span><br><span class="line">00 00 00 05               字节码指令字节长度，值是5</span><br><span class="line">2a                        虚拟机指令 aload_0，将第一个引用类型本地变量推送值栈顶</span><br><span class="line">b7                        虚拟机指令 invokespecial，实例初始化方法，构造函数调用，后续有个 u2 类型参数说明调用的是哪个方法</span><br><span class="line">00 01                     invokespecial 参数，指向常量池中第 1 个常量，得知值是java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">b1                        虚拟机指令 return，从当前方法返回 void</span><br><span class="line">00 00                     Code属性中异常表数量，exception_table_length，值是0</span><br><span class="line">00 01                     Code属性中属性数量，attributes_count，值是1</span><br><span class="line">00 0a                     属性名称索引，attribute_name_index，对应到第 10 个常量，值是LineNumberTable</span><br><span class="line">00 00 00 06               属性字节长度，attribute_length，值是6</span><br><span class="line">00 01                     LineNumberTable属性中line_number_table数量，line_number_table_length，值是1</span><br><span class="line">00 00 00 01               LineNumberTable属性中line_number_info表，包括一个u2的start_pc和一个u2的line_number，分别表示字节码相对于方法体开始的偏移量（值是0），后者表示java源码的行号（值是1）</span><br><span class="line"></span><br><span class="line">                          // init方法完毕</span><br><span class="line"></span><br><span class="line">00 01                     方法访问标志，access_flags，0x0001表示ACC_PUBLIC为真，其他标志符为假</span><br><span class="line">00 0b                     方法的简单名称，name_index，对应到第 11 个常量，值是inc</span><br><span class="line">00 0c                     方法的描述符，descriptor_index，对应到第 12 个常量，值是()I</span><br><span class="line">00 01                     方法的属性表中属性数量，值是1</span><br><span class="line">00 09                     属性名称索引，attribute_name_index，对应到第 9 个常量，值是Code</span><br><span class="line">00 00 00 1f               属性字节长度，attribute_length，值是31</span><br><span class="line">00 02                     Code属性中操作数栈深度的最大值，max_stack，值是2</span><br><span class="line">00 01                     Code属性中局部变量表所需的存储空间，max_locals，单位是Slot，值是1</span><br><span class="line">00 00 00 07               字节码指令字节长度，值是7</span><br><span class="line">2a                        虚拟机指令 aload_0，将第一个引用类型本地变量推送值栈顶</span><br><span class="line">b4                        虚拟机指令 getfield，获取指定类的实例域，并将其值压入栈顶，后续有个u2类型参数说明压入栈顶的是哪个变量</span><br><span class="line">00 02                     getfield 参数，指向常量池中第 2 个常量，得知值是TestJvmClassStructure.m:I</span><br><span class="line">04                        虚拟机指令 iconst_1，将int型 1 推送至栈顶</span><br><span class="line">60                        虚拟机指令 iadd，将栈顶两个 int 型相加，并将结果压入栈顶</span><br><span class="line">ac                        虚拟机指令 ireturn，从当前方法返回 int</span><br><span class="line">00 00                     Code属性中异常表数量，exception_table_length，值是0</span><br><span class="line">00 01                     Code属性中属性数量，attributes_count，值是1</span><br><span class="line">00 0a                     属性名称索引，attribute_name_index，对应到第 10 个常量，值是LineNumberTable</span><br><span class="line">00 00 00 06               属性字节长度，attribute_length，值是6</span><br><span class="line">00 01                     LineNumberTable属性中line_number_table数量，line_number_table_length，值是1</span><br><span class="line">00 00 00 06               LineNumberTable属性中line_number_info表，包括一个u2的start_pc和一个u2的line_number，分别表示字节码相对于方法体开始的偏移量（值是0），后者表示java源码的行号（值是6）</span><br><span class="line"></span><br><span class="line">                          // 方法表完毕</span><br><span class="line"></span><br><span class="line">00 01                     属性数量，值是1</span><br><span class="line">00 0d                     属性名称索引，attribute_name_index，对应到第 13 个常量，值是SourceFile</span><br><span class="line">00 00 00 02               属性字节长度，attribute_length，值是2</span><br><span class="line">00 0e                     SourceFile属性中源码文件名称索引，sourcefile_index，指向第 14 个常量，值是TestJvmClassStructure.java</span><br></pre></td></tr></table></figure>

<h2 id="例子完整-javap-反编译输出"><a href="#例子完整-javap-反编译输出" class="headerlink" title="例子完整 javap 反编译输出"></a>例子完整 javap 反编译输出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /C:/Users/zhchun/Desktop/TestJvmClassStructure.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2018</span>-<span class="number">7</span>-<span class="number">29</span>; size <span class="number">299</span> bytes</span><br><span class="line">  MD5 checksum f683f6070c8a0820e2fdd9adf16d6c1d</span><br><span class="line">  Compiled from <span class="string">&quot;TestJvmClassStructure.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJvmClassStructure</span></span><br><span class="line">  SourceFile: <span class="string">&quot;TestJvmClassStructure.java&quot;</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">4.</span>#<span class="number">15</span>         <span class="comment">//  java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">3.</span>#<span class="number">16</span>         <span class="comment">//  TestJvmClassStructure.m:I</span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">17</span>            <span class="comment">//  TestJvmClassStructure</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">18</span>            <span class="comment">//  java/lang/Object</span></span><br><span class="line">   #<span class="number">5</span> = Utf8               m</span><br><span class="line">   #<span class="number">6</span> = Utf8               I</span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               inc</span><br><span class="line">  #<span class="number">12</span> = Utf8               ()I</span><br><span class="line">  #<span class="number">13</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">14</span> = Utf8               TestJvmClassStructure.java</span><br><span class="line">  #<span class="number">15</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">//  &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">16</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">//  m:I</span></span><br><span class="line">  #<span class="number">17</span> = Utf8               TestJvmClassStructure</span><br><span class="line">  #<span class="number">18</span> = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TestJvmClassStructure</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0       </span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span>        </span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0       </span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field m:I</span></span><br><span class="line">         <span class="number">4</span>: iconst_1      </span><br><span class="line">         <span class="number">5</span>: iadd          </span><br><span class="line">         <span class="number">6</span>: ireturn       </span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践[M]. 北京：机械工业出版社，2013</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载器</title>
    <url>/jvm/jvm-classloader/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>类加载器主要是用来将 java 字节码文件（class 文件）加载到虚拟机中，也可以说是将 java 类加载到 java 虚拟机中。在 java 中，每一个类加载器都拥有一个独立的类名称空间，对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立起在 java 虚拟机中的唯一性。也就是说，要比较两个类是否相等，只有在两个类是由同一个类加载器加载的前提下才有效，否则即使两个类是同一个 class 文件加载而成，但是是由不同的类加载器进行加载的，那么两者进行比较也是不相等的。</p>
<span id="more"></span>

<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>java 中的类加载器基本上可以分成两类，一类是系统提供的，另一类是开发人员自己编写的。系统提供的类加载器主要有以下三类：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：它用来加载 java 的核心库（<code>$&#123;JRE_HOME&#125;/lib/rt.jar</code>），是用原生代码来实现的，并不继承自 <code>java.lang.ClassLoader</code> </li>
<li>扩展类加载器（Extension ClassLoader）：由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现，负责加载 Java 的扩展库 ，如 <code>$&#123;JRE_HOME&#125;/lib/ext</code> 目录下的类库</li>
<li>应用程序类加载器（Application ClassLoader）：由 <code>sun.misc.Launcher$AppClassLoader</code> 实现，负责加载用户类路径（classpath）上所指定的类库。一般而言，java 应用的类都是由它来完成加载的，可以通过 <code>ClassLoader.getSystemClassLoader()</code>来获取它 ，所以也可以称其为系统类加载器</li>
</ul>
<p>其结构图大致如下所示</p>
<p><img src="/images/jvm/classloader.png" alt="类加载器双亲委派模型图"></p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不是自己尝试去加载这个类，而是交给其父类加载器进行尝试加载（注意：启动类加载器没有父类），如果父类加载器没加载成功，再交由自己的类加载器进行加载，如果仍然加载不成功，则抛出异常。</p>
<h1 id="类加载器的主要函数"><a href="#类加载器的主要函数" class="headerlink" title="类加载器的主要函数"></a>类加载器的主要函数</h1><p>使用类加载器进行加载，主要会用到以下的函数</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getParent()</td>
<td>返回该类加载器的父类加载器。</td>
</tr>
<tr>
<td>loadClass(String name)</td>
<td>加载名称为 name 的类，返回的结果是  <code>java.lang.Class </code> 类的实例。</td>
</tr>
<tr>
<td>findClass(String name)</td>
<td>查找名称为 name 的类，返回的结果是 <code>java.lang.Class</code> 类的实例。</td>
</tr>
<tr>
<td>findLoadedClass(String name)</td>
<td>查找名称为 name 的已经被加载过的类，返回的结果是 <code>java.lang.Class</code> 类的实例。</td>
</tr>
<tr>
<td>defineClass(String name, byte[] b, int off, int len)</td>
<td>把字节数组 <code>b</code>中的内容转换成 java 类，返回的结果是 <code>java.lang.Class</code>类的实例。这个方法被声明为 <code>final</code>的。</td>
</tr>
<tr>
<td>resolveClass(Class&lt;?&gt; c)</td>
<td>链接指定的 java 类。</td>
</tr>
</tbody></table>
<p>一般情况下，调用类加载器加载某个类主要是用 loadClass 函数完成，在 loadClass 函数中，先通过 findLoadedClass 函数判断是否已经加载了某个类，如果没有加载，则调用父类加载器进行加载，如果父类加载器加载失败，则调用 findClass 函数尝试获取对应的 class 实例进行加载，而在 findClass 函数中，一般也会通过调用 defineClass 函数来将字节码数据转成对应的 class 实例。</p>
<h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><p>自定义类加载器有两种模式：一种是通过继承 <code>ClassLoader</code> 类并重写 <code>loadClass</code> 方法，另一种是通过继承 <code>ClassLoader</code> 类并重写 <code>findClass</code> 方法。由于双亲委派模型在 <code>loadClass</code> 方法中已经保证了在调用父类的加载器加载失败后会调用本类的 <code>findClass</code> 方法进行类加载，因此建议通过重写 <code>findClass</code> 方法的方式进行自定义类加载器的编写。本例以重写 <code>findClass</code> 方法的方式进行自定义类加载器的编写。</p>
<h2 id="要被加载器加载的类"><a href="#要被加载器加载的类" class="headerlink" title="要被加载器加载的类"></a>要被加载器加载的类</h2><p>这个类很简单，主要有两个函数：<code>setSample</code> 和 <code>sayHello</code>。其中 <code>sayHello</code> 主要用于验证类被自定义加载器正确加载，<code>setSample</code> 主要用于验证只有类加载器和加载的类都相同的情况下，两个类才是相等的。</p>
<p>需要注意的是，此类生成的 class 文件需要放在 main 函数加载不到的地方，否则此类会被应用加载器加载而不会触发自定义类加载器的加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Sample sample;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSample</span><span class="params">(Object obj)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.sample = (Sample) obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义类加载器类"><a href="#自定义类加载器类" class="headerlink" title="自定义类加载器类"></a>自定义类加载器类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLASS_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileClassLoader</span><span class="params">(String path)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写 findClass，用于加载类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取 class 文件的 byte 数据</span></span><br><span class="line">        <span class="type">byte</span>[] classBytes = getClassBytes(name);</span><br><span class="line">        <span class="keyword">if</span> (classBytes == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用 defineClass 函数将 byte 数据转成对应的 class 类实例</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据类的全限定名，找到对应的 class 文件，然后文件内的数据读取出来放入一个 byte 数组返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className 类的全限定名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte 数组，是类的 class 文件的数据。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassBytes(String className)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> path + File.separator + className.replace(<span class="string">&quot;.&quot;</span>, File.separator) + CLASS_SUFFIX;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">4</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = fileInputStream.read(data)) != -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                byteArrayOutputStream.write(data, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">            <span class="keyword">return</span> byteArrayOutputStream.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="验证程序"><a href="#验证程序" class="headerlink" title="验证程序"></a>验证程序</h2><p>首先定义两个类加载器，用这两个类加载器加载 Sample 类并生成对应的实例，然后用反射方法分别调用实例的 <code>sayHello</code> 函数，用于验证类加载成功，再用反射方法调用实例的 <code>setSample</code> 方法用于验证在 java 中每个类都需要由加载它的类加载器和这个类本身一同确立起在 java 虚拟机中的唯一性。</p>
<p>需要注意的是，由于 Sample 类是通过自定义类加载器加载完成的，所以在调用 Sample 类中的函数时，不能直接调用，因为获取不到。有两种方法可以完成其调用：一是通过反射进行调用，二是通过接口的方式进行调用，此种方法需要调用方拥有与被加载类同样的接口并且调用方能够加载接口类。此处主要用反射的方式进行被加载类方法的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClassLoader</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">currentPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        <span class="type">FileClassLoader</span> <span class="variable">fileClassLoader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileClassLoader</span>(currentPath);</span><br><span class="line">        <span class="type">FileClassLoader</span> <span class="variable">fileClassLoader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileClassLoader</span>(currentPath);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;jvm.Sample&quot;</span>;</span><br><span class="line">            Class&lt;?&gt; class1 = fileClassLoader1.loadClass(className);</span><br><span class="line">            Class&lt;?&gt; class2 = fileClassLoader2.loadClass(className);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance1</span> <span class="operator">=</span>  class1.newInstance();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance2</span> <span class="operator">=</span>  class2.newInstance();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;----class loader 1 indress: &quot;</span> + class1.getClassLoader() + <span class="string">&quot;----&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;----class loader 2 indress: &quot;</span> + class2.getClassLoader() + <span class="string">&quot;----&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;----class loader 1, instance sayHello----&quot;</span>);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> class1.getDeclaredMethod(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">            method.invoke(instance1);</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;----class loader 2, instance sayHello----&quot;</span>);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span> class2.getDeclaredMethod(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">            method2.invoke(instance2);</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;----class loader 1, instance setSample----&quot;</span>);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method3</span> <span class="operator">=</span> class1.getDeclaredMethod(<span class="string">&quot;setSample&quot;</span>, Object.class);</span><br><span class="line">            method3.invoke(instance1, instance2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出结果如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----class loader 1 indress: jvm.FileClassLoader@6d06d69c----</span><br><span class="line">----class loader 2 indress: jvm.FileClassLoader@4e25154f----</span><br><span class="line">----class loader 1, instance sayHello----</span><br><span class="line">Hello World!</span><br><span class="line">----class loader 2, instance sayHello----</span><br><span class="line">Hello World!</span><br><span class="line">----class loader 1, instance setSample----</span><br><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Unknown Source)</span><br><span class="line">	at jvm.TestClassLoader.main(TestClassLoader.java:96)</span><br><span class="line">Caused by: java.lang.ClassCastException: jvm.Sample cannot be cast to jvm.Sample</span><br><span class="line">	at jvm.Sample.setSample(Sample.java:8)</span><br><span class="line">	... 5 more</span><br></pre></td></tr></table></figure>

<p>从输出结果中可以看出，<code>fileClassLoader1</code> 和 <code>fileClassLoader2</code> 是两个不同的类加载器，虽然他们都成功地加载了同一个 class 文件（分别调用对应的 <code>sayHello</code> 函数都能正确输出结果），但是他们并不是同一个类，这通过 instance1（通过 fileClassLoader1 类加载器加载的 Sample 类生成的实例）调用 <code>setSample</code> 函数要将 instance2（通过 fileClassLoader2 类加载器加载的 Sample 类生成的实例）强制转换为 instance1 所对应的类时抛出 <code>ClassCastException</code> 异常可以证明。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>虽然在 java 世界中大部分的类加载器都使用双亲委派模型进行类的加载，而且这也是 java 设计者推荐给开发者的类加载器的实现方式，但是也例外的情况，比如 JNDI 和 OSGi，其并不能通过双亲委派模型解决问题，而是通过线程上下文类加载器或自定义其他类加载器模型完成。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践[M]. 北京：机械工业出版社，2013<br>[2] 成富. 深入探讨 Java 类加载器[J&#x2F;OL]. <a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/">https://www.ibm.com/developerworks/cn/java/j-lo-classloader/</a> ，2010-03-01</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm 描述符</title>
    <url>/jvm/jvm-descriptor/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>描述符是 jvm 层次上的概念，针对 class 文件定义而成，主要用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）。</p>
<span id="more"></span>

<h1 id="字段数据类型描述符"><a href="#字段数据类型描述符" class="headerlink" title="字段数据类型描述符"></a>字段数据类型描述符</h1><p>对于字段的数据类型，其描述符主要有以下几种</p>
<ul>
<li>基本数据类型（byte、char、double、float、int、long、short、boolean）：除 long 和 boolean，其他基本数据类型的描述符用对应单词的大写首字母表示。long 用 J 表示，boolean 用 Z 表示。</li>
<li>void：描述符是 V。</li>
<li>对象类型：描述符用字符<code>L</code>加上对象的全限定名表示，如 <code>String</code> 类型的描述符为 <code>Ljava/lang/String</code>。</li>
<li>数组类型：每增加一个维度则在对应的字段描述符前增加一个 <code>[</code> ，如一维数组 <code>int[]</code> 的描述符为 <code>[I</code>，二维数组 <code>String[][]</code> 的描述符为 <code>[[java/lang/String</code> 。</li>
</ul>
<p>各类型的描述符汇总如下</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述符</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>B</td>
</tr>
<tr>
<td>char</td>
<td>C</td>
</tr>
<tr>
<td>double</td>
<td>D</td>
</tr>
<tr>
<td>float</td>
<td>F</td>
</tr>
<tr>
<td>int</td>
<td>I</td>
</tr>
<tr>
<td>long</td>
<td>J</td>
</tr>
<tr>
<td>short</td>
<td>S</td>
</tr>
<tr>
<td>boolean</td>
<td>Z</td>
</tr>
<tr>
<td>特殊类型void</td>
<td>V</td>
</tr>
<tr>
<td>对象类型</td>
<td>L + 对象全限定名。如 <code>Ljava/lang/String</code> 表示 <code>String</code> 类型</td>
</tr>
<tr>
<td>数组类型</td>
<td>每增加一个维度则在对应的字段描述符前增加一个 <code>[</code> ，如一维数组 <code>int[]</code> 的描述符为 <code>[I</code>，二维数组 <code>String[][]</code> 的描述符为 <code>[[java/lang/String</code></td>
</tr>
</tbody></table>
<h1 id="方法描述符"><a href="#方法描述符" class="headerlink" title="方法描述符"></a>方法描述符</h1><p>用描述符来描述方法时，其格式为：<code>(参数列表描述符)返回值描述符</code>。其中参数列表按照方法的参数从左到右依次用描述符对参数进行描述，如果没有参数则不用写。</p>
<p>例如：方法<code>void init()</code>的描述符为 <code>()init</code>，方法<code>java.lang.String getName()</code>的描述符为<code>()Ljava/lang/String</code>，方法<code>int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)</code>的描述符为<code>([CII[CIII)I</code>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践[M]. 北京：机械工业出版社，2013</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm 垃圾回收算法</title>
    <url>/jvm/jvm-gc-algorithm/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>jvm中有多种垃圾回收算法，不同的虚拟机采用的回收方法也不同，本文主要介绍其中几种常见的回收算法，包括：标记清除算法、复制算法、标记整理算法、分代收集算法。</p>
<span id="more"></span>

<h1 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h1><p>标记清除（Mark-Sweep）算法是最基础的垃圾回收算法，他将回收过程分成两个阶段：标记和清除。第一阶段先扫描内存区域，对不可用对象（可以进行垃圾回收的对象）进行标记，第二阶段则将第一阶段所有标记成可回收的对象进行回收。下图是一个内存区域使用标记清除算法进行回收的前后对比图。</p>
<p><img src="/images/jvm/markSweep.png" alt="标记清除算法图"></p>
<p>此算法有两个不足之处：一个是效率问题，标记和清除这两个过程的效率都不高，另一个是空间问题，标记清除之后会产生大量的内存碎片，可能导致后续在分配大内存对象时因为没有足够连续的空间而不得不提前触发另一次垃圾回收。</p>
<h1 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h1><p>复制（Copying）算法是将内存按照容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完时，将存活的对象复制到另一块内存区域，然后将这一块的内存空间一次性清理掉。下图是一个内存区域使用复制算法进行回收的前后对比图</p>
<p><img src="/images/jvm/copying.png" alt="复制算法图"></p>
<p>此算法解决了标记清除算法中内存碎片的问题，在存活对象较少时，因为复制对象少，能够获得很好的效率。但是此算法由于预留了一半的内存区域而造成内存的浪费。为了进一步改进此算法，可以根据实际情况降低预留内存区域的比例。</p>
<p>现代的商业虚拟机绝大部分采用这种算法回收新生代的内存区域。但是并不是严格按照1：1的比例来预留内存区域的。而是将内存分成一块较大的Eden空间和两块比较小的Survivor空间，每次使用Eden和其中一块Survivor空间。当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8：1，也就是每次新生代中可用内存空间是整个新生代的90%，只有10%的预留内存空间会被“浪费”。在决大部分情况下，在进行回收时，Survivor能够存放Eden和一个Survivor中的存活对象，但是也有少数情况会造成溢出，此时需要依赖其他内存（老年代）进行分配担保。</p>
<h1 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h1><p>标记整理（Mark-Compact）算法与标记清理算法类似，同样由两个阶段完成。第一个阶段同样是标记，第二个阶段对存活对象进行移动，将其移动到内存区域的一端，然后将存活对象界线之外的空间对象进行清理回收。下图是一个内存区域使用标记整理算法进行回收的前后对比图</p>
<p><img src="/images/jvm/markCompact.png" alt="标记整理算法图"></p>
<p>此算法既避免了标记清理算法中的内存碎片问题，也弥补了复制算法中的预留内存区域的空间浪费及分配担保的问题。但是如果对象存活率低，经常发生垃圾回收时，此算法则存在效率问题。因此，此算法一般用于对象存活率高的老年代中。</p>
<h1 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h1><p>分代收集（Generational Collection）算法是根据对象存活周期的不同将内存划分成几块，一般情况下是划分成新生代和老年代，然后针对不同的区域使用不同的回收算法。一般情况下，在新生代中，由于大部分对象都是“朝生夕死”，每次回收时都有大量的对象被回收，对象存活率低，因此此区域中基本上使用复制算法进行垃圾回收。而在老年代中，由于对象存活率高，且没有额外的空间进行分配担保，因此一般选择标记整理算法或标记清除算法进行垃圾回收。</p>
<p>当前商业虚拟机的垃圾回收都采用此算法。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 周志明，深入理解Java虚拟机：JVM高级特性与最佳实践[M]，北京：机械工业出版社，2013</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm垃圾回收器</title>
    <url>/jvm/jvm-gc-collectors/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java虚拟机的垃圾回收器多种多样，因不同的厂商、版本而不同。本文主要介绍在HotSpot虚拟机中常用的几种垃圾回收器：Serial、ParNew、Parallel Scavenge、CMS、Serial Old、Parallel Old、G1。这几种垃圾回收器关系如下图所示，其中连线表示两个垃圾回收器可以结合使用。</p>
<p><img src="/images/jvm/gcCollectors.png" alt="垃圾回收器关系图"></p>
<blockquote>
<p>说明：此图参考《深入理解Java虚拟机：JVM高级特性与最佳实践》画出</p>
</blockquote>
<span id="more"></span>

<h1 id="Serial回收器"><a href="#Serial回收器" class="headerlink" title="Serial回收器"></a>Serial回收器</h1><p>Serial收集器是最基本也是发展历史最悠久的回收器。它相比其他回收器而言显得简单而高效，是虚拟机运行在Client模式下的默认新生代回收器。这是一个单线程的收集器，其在进行垃圾回收时，必须暂停其他所有的工作线程（Stop The World）直到收集结束。其运行过程大致如下图所示</p>
<p><img src="/images/jvm/serialCollector.png" alt="Serial回收器运行图"></p>
<blockquote>
<p>说明：此图参考《深入理解Java虚拟机：JVM高级特性与最佳实践》画出</p>
</blockquote>
<h1 id="ParNew回收器"><a href="#ParNew回收器" class="headerlink" title="ParNew回收器"></a>ParNew回收器</h1><p>ParNew回收器是Serial回收器的多线程版本，是大部分虚拟机运行在Server模式下的首选新生代回收器，同时也是使用-XX:+UseConcMarkSweepGC选项后的默认的新生代回收器，当然，也可以使用-XX:+UseParNewGC选项来强制启动该回收器。由于这是多线程进行回收，存在线程切换的开销，因此当CPU数量较少时，其性能并不比Serial回收器好，甚至比Serial回收器还差，但是当CPU数量比较多时，其性能远远超过Seral回收器，这也是Serial回收器应用于Client端而ParNew回收器应用于Server端的一个原因。当然，可以通过-XX:ParallelGCThreads参数来限制垃圾回收的线程数。其运行过程大致如下图所示</p>
<p><img src="/images/jvm/parNewCollector.png" alt="ParNew回收器运行图"></p>
<blockquote>
<p>说明：此图参考《深入理解Java虚拟机：JVM高级特性与最佳实践》画出</p>
</blockquote>
<h1 id="Parallel-Scavenge回收器"><a href="#Parallel-Scavenge回收器" class="headerlink" title="Parallel Scavenge回收器"></a>Parallel Scavenge回收器</h1><p>Parallel Scavenge回收器也是一个使用复制算法的新生代的并行多线程的回收器，与ParNew回收器不同的是：ParNew回收器注重的是响应时间，即在垃圾回收过程中用户线程停顿的时间；而Parallel Scavenge回收器注重的是吞吐量，即运行用户的代码消耗的CPU时间占CPU总消耗时间的比率。吞吐量 &#x3D; 运行用户代码时间 &#x2F;（运行用户代码时间 + 垃圾回收时间）。</p>
<p>Parallel Scavenge回收器提供了以下几个参数用户控制吞吐量</p>
<ul>
<li><p>-XX:UseAdaptiveSizePolicy：此参数是一个开关参数，用于控制是否让虚拟机动态调整相关参数以提供最合适的停顿时间或最大的吞吐量。当此参数打开后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等参数细节。</p>
</li>
<li><p>-XX:MaxGCPauseMillis：控制最大垃圾回收的停顿时间，停顿时间小是以牺牲新生代的大小为代价换来的。</p>
</li>
<li><p>-XX:GCTimeRatio：一个（0，100）的整数，表示用户线程运行时间与垃圾回收时间的比值，默认值是99，表示允许最大1%（即 1&#x2F;(1+99)) 的垃圾回收时间。其运行过程图大致如下图所示</p>
<p><img src="/images/jvm/parallelOldCollector.png" alt="Parallel Scavenge回收器运行图"></p>
</li>
</ul>
<blockquote>
<p>说明：此图参考《深入理解Java虚拟机：JVM高级特性与最佳实践》画出</p>
</blockquote>
<h1 id="Serial-Old回收器"><a href="#Serial-Old回收器" class="headerlink" title="Serial Old回收器"></a>Serial Old回收器</h1><p>Serial Old回收器是Serial回收器的老年代版本，同样是一个单线程回收器，使用“标记整理”算法。这个回收器的主要意义是给Client模式下的虚拟机使用。如果运行在Server端，还可以作为CMS回收器的后备预案，在并发回收发生Concurrent Mode Failure时使用。其运行过程图大致如下图所示</p>
<p><img src="/images/jvm/parNewCollector.png" alt="Serial Old回收器运行图"></p>
<blockquote>
<p>说明：此图参考《深入理解Java虚拟机：JVM高级特性与最佳实践》画出</p>
</blockquote>
<h1 id="Parallel-Old回收器"><a href="#Parallel-Old回收器" class="headerlink" title="Parallel Old回收器"></a>Parallel Old回收器</h1><p>Parallel Old回收器是Parallel Scavenge回收器的老年代版本，使用多线程和“标记整理”算法。其运行过程图大致如下图所示</p>
<p><img src="/images/jvm/parallelOldCollector.png" alt="Parallel Old回收器运行图"></p>
<blockquote>
<p>说明：此图参考《深入理解Java虚拟机：JVM高级特性与最佳实践》画出</p>
</blockquote>
<h1 id="CMS回收器"><a href="#CMS回收器" class="headerlink" title="CMS回收器"></a>CMS回收器</h1><p>CMS(Concurrent Mark Sweep)回收器是一种以获取最短回收停顿时间为目标的回收器，也就是说，这是一个注重用户响应时间、注重用户体验的回收器。CMS回收器使用“标记清除”算法，其运行过程主要分成四个步骤：初始标记、并发标记、重新标记、并发清除。</p>
<ul>
<li>初始标记（CMS initial mark）：标记一下GC Roots能直接关联到的对象，速度快，需要暂停用户线程（Stop The World）</li>
<li>并发标记（CMS concurrent mark）：根据GC Roots节点查找所有能与之直接或间接关联的对象（GC Roots Tracing），此过程耗时较长，可以与用户线程并发执行</li>
<li>重新标记（CMS remark）：修正并发标记期间因用户程序继续运行而导致标记产生变动的对象的标记记录，这个过程一般比初始标记阶段稍微长一点，但是远比并发标记的时间短，此过程也需要暂停用户线程（Stop The World）</li>
<li>并发清除（CMS concurrent sweep）：此过程将对象进行回收，可以与用户线程并发执行。</li>
</ul>
<p>其运行过程图大致如下图所示</p>
<p><img src="/images/jvm/CMSCollector.png" alt="CMS回收器运行图"></p>
<blockquote>
<p>说明：此图参考《深入理解Java虚拟机：JVM高级特性与最佳实践》画出</p>
</blockquote>
<p>CMS是一款优秀的回收器，但是其也存在以下几个缺点</p>
<ul>
<li>对CPU资源非常敏感。因为在并发标记和并发清除这两个阶段是运行用户线程并发执行的，线程之间的切换会导致了用户线程与回收线程争抢CPU资源的情况，如果CPU资源少，则会同时影响用户线程和垃圾回收的运行时间</li>
<li>CMS回收器无法清理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生，此时会临时启用Serial Old回收器重新进行老年代的垃圾回收</li>
<li>可能产生大量垃圾碎片，这是因为其使用“标记清除”的回收算法导致的</li>
</ul>
<h1 id="G1回收器"><a href="#G1回收器" class="headerlink" title="G1回收器"></a>G1回收器</h1><p>G1(Garbage-First)回收器是一款面向Server端的垃圾回收器，其不像其他垃圾回收器区分新生代和老年代，而是使用“化整为零”的思想把整个java堆划分成多个大小相等的独立区域（Region），虽然还保留着新生代和老年代的概念，但是新生代和老年代不再是物理隔离的，他们都是一部分Region(不需要连续)的集合。其运行过程主要分成四个步骤：初始标记、并发标记、最终标记、筛选回收。</p>
<ul>
<li>初始标记（Initial Marking）：标记一下GC Roots能直接关联到的对象，并且修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时能在正确可用的Region中创建对象，这阶段需要停顿用户线程（Stop The World），但是耗时短</li>
<li>并发标记（Concurrent Marking）：根据GC Roots节点查找所有能与之直接或间接关联的对象（GC Roots Tracing），此过程耗时较长，可以与用户线程并发执行</li>
<li>最终标记（Final Marking）：修正并发标记期间因用户程序继续运行而导致标记产生变动的对象的标记记录，此阶段耗时较少，也需要停顿用户线程（Stop The World）</li>
<li>筛选回收（Live Data Counting and Evacuation）：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划并回收对象</li>
</ul>
<p>其运行过程图大致如下图所示</p>
<p><img src="/images/jvm/G1Collector.png" alt="CMS回收器运行图"></p>
<blockquote>
<p>说明：此图参考《深入理解Java虚拟机：JVM高级特性与最佳实践》画出</p>
</blockquote>
<p>G1回收器有以下特点</p>
<ul>
<li>并发与并行。G1回收器能充分利用多CPU、多核环境下的硬件优势来缩短Stop-The-World停顿的时间。部分回收器原本需要停顿java线程执行GC动作，但是G1回收器仍然可以通过并发的方式让java程序继续运行</li>
<li>分代回收。虽然G1回收器中新生代和老年代的区别不在那么明显，但是G1回收器仍然能够采用不同的方式处理新建的对象和已经存活一段时间的对象</li>
<li>空间整合：G1回收器整体上是使用“标记整理”算法，而不是容易产生空间碎片的“标记清除”算法</li>
<li>可预测的停顿：G1回收器能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾回收上的时间不超过N毫秒，这几乎是实时java(RTSJ)的垃圾回收器的特征。</li>
</ul>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><table>
<thead>
<tr>
<th>回收器</th>
<th>适用内存区域</th>
<th>适用B&#x2F;S范围</th>
<th>回收算法</th>
</tr>
</thead>
<tbody><tr>
<td>Serial回收器</td>
<td>新生代</td>
<td>Client</td>
<td>复制</td>
</tr>
<tr>
<td>ParNew回收器</td>
<td>新生代</td>
<td>Server</td>
<td>复制</td>
</tr>
<tr>
<td>Parallel Scavenge回收器</td>
<td>新生代</td>
<td>Server</td>
<td>复制</td>
</tr>
<tr>
<td>Serial Old</td>
<td>老年代</td>
<td>Client、Server</td>
<td>标记整理</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>老年代</td>
<td>Server</td>
<td>标记整理</td>
</tr>
<tr>
<td>CMS回收器</td>
<td>老年代</td>
<td>Server</td>
<td>标记清除</td>
</tr>
<tr>
<td>G1回收器</td>
<td>新生代、老年代</td>
<td>Server</td>
<td>标记整理</td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 周志明，深入理解Java虚拟机：JVM高级特性与最佳实践[M]，北京：机械工业出版社，2013</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>GC 日志</title>
    <url>/jvm/jvm-gc-log/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>GC日志是分析性能问题的重要工具，通过查看GC日志可以对问题的解决方法有一个大致的方向。GC日志随着使用垃圾回收器的不同而有所差别，但是大致内容是相同的。本文主要以Serial垃圾回收器的GC日志进行说明。</p>
<span id="more"></span>

<h1 id="GC日志示例"><a href="#GC日志示例" class="headerlink" title="GC日志示例"></a>GC日志示例</h1><p><img src="/images/jvm/gcLog.png" alt="GC日志例子"></p>
<h1 id="GC日志说明"><a href="#GC日志说明" class="headerlink" title="GC日志说明"></a>GC日志说明</h1><ul>
<li>最开始的<code>[GC</code>表示这次GC的类型，如果是GC说明这次是Minor GC，如果是Full GC，说明这次是Full GC，Full GC发生需要stop-the-world</li>
<li>接着的<code>(Allocation Failure)</code>表示这次发生GC的原因，此处表示内存分配失败。</li>
<li>接着的<code>[DefNew: 7479K-&gt;511K(9216K), 0.0046090 secs]</code>表明这次发生GC的区域、发生GC前该区域使用的内存、发生GC后该区域使用的内存、该区域的总内存、发生GC在该区域的耗时。如此处表示发生GC的区域是新生代，新生代总内存9216KB，发生GC前使用了7479KB，发生GC后使用了511KB，GC在新生代的耗时是0.004609秒</li>
<li>接着的<code>7479K-&gt;6655K(19456K), 0.0046698 secs</code>表示发生GC前堆的已使用内存、发生GC后堆的已使用内存、发生GC的总耗时。例如此处表示发生GC前堆使用量是7479KB，发生GC后堆的使用量是6655KB，此次GC总共耗时0.0046698秒</li>
<li>接着的<code>[Times: user=0.00 sys=0.00, real=0.01 secs]</code>表示此次GC整个过程用户消耗的CPU时间、内核消耗的CPU时间和操作从开始到结束所经过的墙钟时间（Wall Clock Time，包括各种非运算的等待耗时，CPU时间不包括这些非运算的耗时）</li>
<li>接着的日志表示程序退出时各个内存区域的使用情况。<code>def new generation</code>表示新生代，<code>eden</code>表示Eden区域，<code>from</code>和<code>to</code>表示两Survivor区域，<code>tenured generation</code>表示老年代</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践[M]. 北京：机械工业出版社，2013</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm 字节码指令</title>
    <url>/jvm/jvm-instructions/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java 虚拟机的指令由一个操作码（Opcode）以及零或多个操作数（Operands）组成。其中，操作码是一个字节长度的数字，不同的数字代表不同的操作码。对于操作数而言，一个字节码的数字代表一个操作数。由于 java 虚拟机采用面向操作数栈而不是寄存器的架构，因此，大多数的指令都不包含操作数，只有一个操作码。</p>
<p>在 java 虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息，在这些指令中，操作码中第一个字母表明了其数据类型：i 代表 int，l 代表 long，s 代表 short，b 代表 byte，c 代表 char，f 代表 float，d 代表 double，a 代表 reference。</p>
<p>由于操作码只占一个字节，所以最多只有 256 个指令，这也决定了 java 虚拟机中只对一些常用的操作提供了有限的类型相关识别指令，对于剩下的部分，java 虚拟机通过类型转换将其他类型转成虚拟机指令支持的类型然而再进行操作。</p>
<p>由于虚拟机指令很多，而且部分指令功能类似，所以本文只介绍部分常用的指令。</p>
<span id="more"></span>

<h1 id="加载指令"><a href="#加载指令" class="headerlink" title="加载指令"></a>加载指令</h1><p>加载指令是指将数据在栈帧中的局部变量表加载到操作数栈中。其主要的指令包括两种：将一个局部变量加载到操作数栈和将一个常量加载到操作数栈。</p>
<h2 id="加载局部变量"><a href="#加载局部变量" class="headerlink" title="加载局部变量"></a>加载局部变量</h2><p>部分常见的加载局部变量的指令如下所示</p>
<table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>iload</td>
<td>一个，i</td>
<td>加载第 i 个 int 类型的局部变量，i 从 0 开始计数</td>
</tr>
<tr>
<td>iload_0</td>
<td>0</td>
<td>加载第 0 个 int 类型的局部变量，与 iload 0 指令相同</td>
</tr>
<tr>
<td>iload_1</td>
<td>无</td>
<td>加载第 1 个 int 类型的局部变量，与 iload 1 指令相同</td>
</tr>
<tr>
<td>iload_2</td>
<td>无</td>
<td>加载第 2 个 int 类型的局部变量，与 iload 2 指令相同</td>
</tr>
<tr>
<td>iload_3</td>
<td>无</td>
<td>加载第 3 个 int 类型的局部变量，与 iload 3 指令相同</td>
</tr>
<tr>
<td>lload</td>
<td>一个，i</td>
<td>加载第 i 个 long 类型的局部变量，i 从 0 开始计数</td>
</tr>
<tr>
<td>lload_0</td>
<td>无</td>
<td>加载第 0 个 long 类型的局部变量，与 lload 0 指令相同</td>
</tr>
<tr>
<td>lload_1</td>
<td>无</td>
<td>加载第 1 个 long 类型的局部变量，与 lload 1 指令相同</td>
</tr>
<tr>
<td>lload_2</td>
<td>无</td>
<td>加载第 2 个 long 类型的局部变量，与 lload 2 指令相同</td>
</tr>
<tr>
<td>lload_3</td>
<td>无</td>
<td>加载第 3 个 long 类型的局部变量，与 lload 3 指令相同</td>
</tr>
<tr>
<td>fload</td>
<td>一个，i</td>
<td>加载第 i 个 float 类型的局部变量，i 从 0 开始计数</td>
</tr>
<tr>
<td>fload_0</td>
<td>无</td>
<td>加载第 0 个 float 类型的局部变量，与 fload 0 指令相同</td>
</tr>
<tr>
<td>fload_1</td>
<td>无</td>
<td>加载第 1 个 float 类型的局部变量，与 fload 1 指令相同</td>
</tr>
<tr>
<td>fload_2</td>
<td>无</td>
<td>加载第 2 个 float 类型的局部变量，与 fload 2 指令相同</td>
</tr>
<tr>
<td>fload_3</td>
<td>无</td>
<td>加载第 3 个 float 类型的局部变量，与 fload 3 指令相同</td>
</tr>
<tr>
<td>dload</td>
<td>一个，i</td>
<td>加载第 i 个 double 类型的局部变量，i 从 0 开始计数</td>
</tr>
<tr>
<td>dload_0</td>
<td>无</td>
<td>加载第 0 个 double 类型的局部变量，与 dload 0 指令相同</td>
</tr>
<tr>
<td>dload_1</td>
<td>无</td>
<td>加载第 1 个 double 类型的局部变量，与 dload 1 指令相同</td>
</tr>
<tr>
<td>dload_2</td>
<td>无</td>
<td>加载第 2 个 double 类型的局部变量，与 dload 2 指令相同</td>
</tr>
<tr>
<td>dload_3</td>
<td>无</td>
<td>加载第 3 个 double 类型的局部变量，与 dload 3 指令相同</td>
</tr>
<tr>
<td>aload</td>
<td>一个，i</td>
<td>加载第 i 个 引用类型的局部变量，i 从 0 开始计数</td>
</tr>
<tr>
<td>aload_0</td>
<td>无</td>
<td>加载第 0 个 引用类型的局部变量，与 aload 0 指令相同</td>
</tr>
<tr>
<td>aload_1</td>
<td>无</td>
<td>加载第 1 个 引用类型的局部变量，与 aload 1 指令相同</td>
</tr>
<tr>
<td>aload_2</td>
<td>无</td>
<td>加载第 2 个 引用类型的局部变量，与 aload 2 指令相同</td>
</tr>
<tr>
<td>aload_3</td>
<td>无</td>
<td>加载第 3 个 引用类型的局部变量，与 aload 3 指令相同</td>
</tr>
</tbody></table>
<h2 id="加载常量"><a href="#加载常量" class="headerlink" title="加载常量"></a>加载常量</h2><p>部分常见的加载常量的指令如下所示</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>bipush</td>
<td>一个，i</td>
<td>将单字节的常量值 i （-128 ~ 127）推送到栈顶</td>
</tr>
<tr>
<td>sipush</td>
<td>两个，byte1, byte2</td>
<td>将 byte1 和 byte2 进行 ((byte1 &lt;&lt; 8)&amp;#124; byte2) 运算，得到 short 类型（-32768 ~ 32767），并将其推送到栈顶</td>
</tr>
<tr>
<td>ldc</td>
<td>一个，i</td>
<td>与 ldc_w 类似，将常量池中第 i 个（从 1 开始计数）常量的值取出推送到栈顶，类型可以是 int、float、String。当常量池中常量数量不超过 255 个时，使用此指令，否则使用 ldc_w</td>
</tr>
<tr>
<td>ldc_w</td>
<td>两个，indexbyte1，indexbyte2</td>
<td>与 ldc 类似，将常量池中第 ((indexbyte1 &lt;&lt; 8) &amp;#124; indexbyte2) 个（从 1 开始计数）常量的值取出推送到栈顶，类型可以是 int、float、String。当常量池中常量数量超过 255 个时，使用此指令，否则使用 ldc</td>
</tr>
<tr>
<td>ldc2_w</td>
<td>两个，indexbyte1，indexbyte2</td>
<td>将常量池中第 ((indexbyte1 &lt;&lt; 8) &amp;#124; indexbyte2) 个（从 1 开始计数）常量的值取出推送到栈顶，类型可以是 long 或 double</td>
</tr>
<tr>
<td>aconst_null</td>
<td>无</td>
<td>将一个 null 推送到栈顶</td>
</tr>
<tr>
<td>iconst_m1</td>
<td>无</td>
<td>将数字 -1（int 类型）推送到栈顶</td>
</tr>
<tr>
<td>iconst_0</td>
<td>无</td>
<td>将数字 0（int 类型）推送到栈顶</td>
</tr>
<tr>
<td>iconst_1</td>
<td>无</td>
<td>将数字 1（int 类型）推送到栈顶</td>
</tr>
<tr>
<td>iconst_2</td>
<td>无</td>
<td>将数字 2（int 类型）推送到栈顶</td>
</tr>
<tr>
<td>iconst_3</td>
<td>无</td>
<td>将数字 3（int 类型）推送到栈顶</td>
</tr>
<tr>
<td>iconst_4</td>
<td>无</td>
<td>将数字 4（int 类型）推送到栈顶</td>
</tr>
<tr>
<td>iconst_5</td>
<td>无</td>
<td>将数字 5（int 类型）推送到栈顶</td>
</tr>
<tr>
<td>lconst_0</td>
<td>无</td>
<td>将数字 0（long 类型）推送到栈顶</td>
</tr>
<tr>
<td>lconst_1</td>
<td>无</td>
<td>将数字 1（long 类型）推送到栈顶</td>
</tr>
<tr>
<td>fconst_0</td>
<td>无</td>
<td>将数字 0（float 类型）推送到栈顶</td>
</tr>
<tr>
<td>fconst_1</td>
<td>无</td>
<td>将数字 1（float 类型）推送到栈顶</td>
</tr>
<tr>
<td>fconst_2</td>
<td>无</td>
<td>将数字 2（float 类型）推送到栈顶</td>
</tr>
<tr>
<td>dconst_0</td>
<td>无</td>
<td>将数字 0（double 类型）推送到栈顶</td>
</tr>
<tr>
<td>dconst_1</td>
<td>无</td>
<td>将数字 1（double 类型）推送到栈顶</td>
</tr>
</tbody></table>
<h1 id="存储指令"><a href="#存储指令" class="headerlink" title="存储指令"></a>存储指令</h1><p>存储指令主要是将一个数值从操作数栈存储到局部变量表中，常见的指令如下</p>
<table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>istore</td>
<td>一个，i</td>
<td>将栈顶 int 类型数值存入第 i 个（从 0 开始计数）本地局部变量</td>
</tr>
<tr>
<td>istore_0</td>
<td>无</td>
<td>将栈顶 int 类型的数值存入第 0 个本地局部变量，与 istore 0 指令相同</td>
</tr>
<tr>
<td>istore_1</td>
<td>无</td>
<td>将栈顶 int 类型的数值存入第 1 个本地局部变量，与 istore 1 指令相同</td>
</tr>
<tr>
<td>istore_2</td>
<td>无</td>
<td>将栈顶 int 类型的数值存入第 2 个本地局部变量，与 istore 2 指令相同</td>
</tr>
<tr>
<td>istore_3</td>
<td>无</td>
<td>将栈顶 int 类型的数值存入第 3 个本地局部变量，与 istore 3 指令相同</td>
</tr>
<tr>
<td>lstore</td>
<td>一个，i</td>
<td>将栈顶 long 类型数值存入第 i 个（从 0 开始计数）本地局部变量</td>
</tr>
<tr>
<td>lstore_0</td>
<td>无</td>
<td>将栈顶 long 类型的数值存入第 0 个本地局部变量，与 lstore 0 指令相同</td>
</tr>
<tr>
<td>lstore_1</td>
<td>无</td>
<td>将栈顶 long 类型的数值存入第 1 个本地局部变量，与 lstore 1 指令相同</td>
</tr>
<tr>
<td>lstore_2</td>
<td>无</td>
<td>将栈顶 long 类型的数值存入第 2 个本地局部变量，与 lstore 2 指令相同</td>
</tr>
<tr>
<td>lstore_3</td>
<td>无</td>
<td>将栈顶 long 类型的数值存入第 3 个本地局部变量，与 lstore 3 指令相同</td>
</tr>
<tr>
<td>fstore</td>
<td>一个，i</td>
<td>将栈顶 float 类型数值存入第 i 个（从 0 开始计数）本地局部变量</td>
</tr>
<tr>
<td>fstore_0</td>
<td>无</td>
<td>将栈顶 float 类型的数值存入第 0 个本地局部变量，与 fstore 0 指令相同</td>
</tr>
<tr>
<td>fstore_1</td>
<td>无</td>
<td>将栈顶 float 类型的数值存入第 1 个本地局部变量，与 fstore 1 指令相同</td>
</tr>
<tr>
<td>fstore_2</td>
<td>无</td>
<td>将栈顶 float 类型的数值存入第 2 个本地局部变量，与 fstore 2 指令相同</td>
</tr>
<tr>
<td>fstore_3</td>
<td>无</td>
<td>将栈顶 float 类型的数值存入第 3 个本地局部变量，与 fstore 3 指令相同</td>
</tr>
<tr>
<td>dstore</td>
<td>一个，i</td>
<td>将栈顶 double 类型数值存入第 i 个（从 0 开始计数）本地局部变量</td>
</tr>
<tr>
<td>dstore_0</td>
<td>无</td>
<td>将栈顶 double 类型的数值存入第 0 个本地局部变量，与 dstore 0 指令相同</td>
</tr>
<tr>
<td>dstore_1</td>
<td>无</td>
<td>将栈顶 double 类型的数值存入第 1 个本地局部变量，与 dstore 1 指令相同</td>
</tr>
<tr>
<td>dstore_2</td>
<td>无</td>
<td>将栈顶 double 类型的数值存入第 2 个本地局部变量，与 dstore 2 指令相同</td>
</tr>
<tr>
<td>dstore_3</td>
<td>无</td>
<td>将栈顶 double 类型的数值存入第 3 个本地局部变量，与 dstore 3 指令相同</td>
</tr>
<tr>
<td>astore</td>
<td>一个，i</td>
<td>将栈顶引用类型数值存入第 i 个（从 0 开始计数）本地局部变量</td>
</tr>
<tr>
<td>astore_0</td>
<td>无</td>
<td>将栈顶引用类型的数值存入第 0 个本地局部变量，与 astore 0 指令相同</td>
</tr>
<tr>
<td>astore_1</td>
<td>无</td>
<td>将栈顶引用类型的数值存入第 1 个本地局部变量，与 astore 1 指令相同</td>
</tr>
<tr>
<td>astore_2</td>
<td>无</td>
<td>将栈顶引用类型的数值存入第 2 个本地局部变量，与 astore 2 指令相同</td>
</tr>
<tr>
<td>astore_3</td>
<td>无</td>
<td>将栈顶引用类型的数值存入第 3 个本地局部变量，与 astore 3 指令相同</td>
</tr>
</tbody></table>
<h1 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h1><p>运算指令用于对两个操作数栈上的数值进行某种特定的运算，并将结果重新存入到操作数栈中。运算指令包括：加法指令、减法指令、乘法指令、除法指令、求余指令、取反指令、位移指令、按位或指令、按位与指令、按位异或指令、局部变量自增指令、比较指令。</p>
<h2 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h2><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>iadd</td>
<td>无</td>
<td>将栈顶两个 int 类型的数值出栈，对其求和，并将结果压入栈中</td>
</tr>
<tr>
<td>ladd</td>
<td>无</td>
<td>将栈顶两个 long 类型的数值出栈，对其求和，并将结果压入栈中</td>
</tr>
<tr>
<td>fadd</td>
<td>无</td>
<td>将栈顶两个 float 类型的数值出栈，对其求和，并将结果压入栈中</td>
</tr>
<tr>
<td>dadd</td>
<td>无</td>
<td>将栈顶两个 double 类型的数值出栈，对其求和，并将结果压入栈中</td>
</tr>
</tbody></table>
<h2 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h2><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>isub</td>
<td>无</td>
<td>将栈顶两个 int 类型的数值出栈，以第一个栈顶元素为减数，第二个栈顶元素为被减数，对其求差，并将结果压入栈中</td>
</tr>
<tr>
<td>lsub</td>
<td>无</td>
<td>将栈顶两个 long 类型的数值出栈，以第一个栈顶元素为减数，第二个栈顶元素为被减数，对其求差，并将结果压入栈中</td>
</tr>
<tr>
<td>fsub</td>
<td>无</td>
<td>将栈顶两个 float 类型的数值出栈，以第一个栈顶元素为减数，第二个栈顶元素为被减数，对其求差，并将结果压入栈中</td>
</tr>
<tr>
<td>dsub</td>
<td>无</td>
<td>将栈顶两个 double 类型的数值出栈，以第一个栈顶元素为减数，第二个栈顶元素为被减数，对其求差，并将结果压入栈中</td>
</tr>
</tbody></table>
<h2 id="乘法指令"><a href="#乘法指令" class="headerlink" title="乘法指令"></a>乘法指令</h2><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>imul</td>
<td>无</td>
<td>将栈顶两个 int 类型的数值出栈，对其求积，并将结果压入栈中</td>
</tr>
<tr>
<td>lmul</td>
<td>无</td>
<td>将栈顶两个 long 类型的数值出栈，对其求积，并将结果压入栈中</td>
</tr>
<tr>
<td>fmul</td>
<td>无</td>
<td>将栈顶两个 float 类型的数值出栈，对其求积，并将结果压入栈中</td>
</tr>
<tr>
<td>dmul</td>
<td>无</td>
<td>将栈顶两个 double 类型的数值出栈，对其求积，并将结果压入栈中</td>
</tr>
</tbody></table>
<h2 id="除法指令"><a href="#除法指令" class="headerlink" title="除法指令"></a>除法指令</h2><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>idiv</td>
<td>无</td>
<td>将栈顶两个 int 类型的数值出栈，以第一个栈顶元素为除数，第二个栈顶元素为被除数，对其求商，并将结果压入栈中</td>
</tr>
<tr>
<td>ldiv</td>
<td>无</td>
<td>将栈顶两个 long 类型的数值出栈，以第一个栈顶元素为除数，第二个栈顶元素为被除数，对其求商，并将结果压入栈中</td>
</tr>
<tr>
<td>fdiv</td>
<td>无</td>
<td>将栈顶两个 float 类型的数值出栈，以第一个栈顶元素为除数，第二个栈顶元素为被除数，对其求商，并将结果压入栈中</td>
</tr>
<tr>
<td>ddiv</td>
<td>无</td>
<td>将栈顶两个 double 类型的数值出栈，以第一个栈顶元素为除数，第二个栈顶元素为被除数，对其求商，并将结果压入栈中</td>
</tr>
</tbody></table>
<h2 id="求余指令"><a href="#求余指令" class="headerlink" title="求余指令"></a>求余指令</h2><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>irem</td>
<td>无</td>
<td>将栈顶两个 int 类型的数值出栈，以第一个栈顶元素为除数，第二个栈顶元素为被除数，对其求余，并将结果压入栈中</td>
</tr>
<tr>
<td>lrem</td>
<td>无</td>
<td>将栈顶两个 long 类型的数值出栈，以第一个栈顶元素为除数，第二个栈顶元素为被除数，对其求余，并将结果压入栈中</td>
</tr>
<tr>
<td>frem</td>
<td>无</td>
<td>将栈顶两个 float 类型的数值出栈，以第一个栈顶元素为除数，第二个栈顶元素为被除数，对其求余，并将结果压入栈中</td>
</tr>
<tr>
<td>drem</td>
<td>无</td>
<td>将栈顶两个 double 类型的数值出栈，以第一个栈顶元素为除数，第二个栈顶元素为被除数，对其求余，并将结果压入栈中</td>
</tr>
</tbody></table>
<h2 id="取反指令"><a href="#取反指令" class="headerlink" title="取反指令"></a>取反指令</h2><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ineg</td>
<td>无</td>
<td>将栈顶 int 类型的数值出栈，取反，并将结果压入栈中</td>
</tr>
<tr>
<td>lneg</td>
<td>无</td>
<td>将栈顶 long 类型的数值出栈，取反，并将结果压入栈中</td>
</tr>
<tr>
<td>fneg</td>
<td>无</td>
<td>将栈顶 float 类型的数值出栈，取反，并将结果压入栈中</td>
</tr>
<tr>
<td>dneg</td>
<td>无</td>
<td>将栈顶 double 类型的数值出栈，取反，并将结果压入栈中</td>
</tr>
</tbody></table>
<h2 id="位移指令"><a href="#位移指令" class="headerlink" title="位移指令"></a>位移指令</h2><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ishl</td>
<td>无</td>
<td>将栈顶两个 int 类型的数值出栈，以第一个栈顶元素为移动位数，第二个栈顶元素为位移数，进行左位移操作，并将结果压入栈中</td>
</tr>
<tr>
<td>lshl</td>
<td>无</td>
<td>将栈顶两个 long 类型的数值出栈，以第一个栈顶元素为移动位数，第二个栈顶元素为位移数，进行左位移操作，并将结果压入栈中</td>
</tr>
<tr>
<td>ishr</td>
<td>无</td>
<td>将栈顶两个 int 类型的数值出栈，以第一个栈顶元素为移动位数，第二个栈顶元素为位移数，进行带符号右位移操作，并将结果压入栈中</td>
</tr>
<tr>
<td>lshr</td>
<td>无</td>
<td>将栈顶两个 long 类型的数值出栈，以第一个栈顶元素为移动位数，第二个栈顶元素为位移数，进行带符号右位移操作，并将结果压入栈中</td>
</tr>
<tr>
<td>iushr</td>
<td>无</td>
<td>将栈顶两个 int 类型的数值出栈，以第一个栈顶元素为移动位数，第二个栈顶元素为位移数，进行<strong>无符号</strong>右位移操作，并将结果压入栈中</td>
</tr>
<tr>
<td>lushr</td>
<td>无</td>
<td>将栈顶两个 long 类型的数值出栈，以第一个栈顶元素为移动位数，第二个栈顶元素为位移数，进行<strong>无符号</strong>右位移操作，并将结果压入栈中</td>
</tr>
</tbody></table>
<h2 id="按位或指令"><a href="#按位或指令" class="headerlink" title="按位或指令"></a>按位或指令</h2><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ior</td>
<td>无</td>
<td>将栈顶两个 int 类型的数值出栈，对其进行按位或运算，并将结果压入栈中</td>
</tr>
<tr>
<td>lor</td>
<td>无</td>
<td>将栈顶两个 long 类型的数值出栈，对其进行按位或运算，并将结果压入栈中</td>
</tr>
</tbody></table>
<h2 id="按位与指令"><a href="#按位与指令" class="headerlink" title="按位与指令"></a>按位与指令</h2><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>iand</td>
<td>无</td>
<td>将栈顶两个 int 类型的数值出栈，对其进行按位与运算，并将结果压入栈中</td>
</tr>
<tr>
<td>land</td>
<td>无</td>
<td>将栈顶两个 long 类型的数值出栈，对其进行按位与运算，并将结果压入栈中</td>
</tr>
</tbody></table>
<h2 id="按位异或指令"><a href="#按位异或指令" class="headerlink" title="按位异或指令"></a>按位异或指令</h2><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ixor</td>
<td>无</td>
<td>将栈顶两个 int 类型的数值出栈，对其进行按位异或运算，并将结果压入栈中</td>
</tr>
<tr>
<td>lxor</td>
<td>无</td>
<td>将栈顶两个 long 类型的数值出栈，对其进行按位异或运算，并将结果压入栈中</td>
</tr>
</tbody></table>
<h2 id="局部变量自增指令"><a href="#局部变量自增指令" class="headerlink" title="局部变量自增指令"></a>局部变量自增指令</h2><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>iinc</td>
<td>两个，index 和 const</td>
<td>将第 index 个（index 从 0 开始计算）局部变量的数值加上 const 常量数值得到结果</td>
</tr>
</tbody></table>
<h2 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h2><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>lcmp</td>
<td>无</td>
<td>将栈顶两个 long 类型的数值出栈，以第一个栈顶元素为 value2，第二个栈顶元素为value1，如果 value1 - value2 &gt; 0，则将 1 压入栈中，如果 value1 - value2 &#x3D; 0，则将 0 压入栈中，如果 value1 - value2 &lt; 0，则将 -1 压入栈中</td>
</tr>
<tr>
<td>fcmpl</td>
<td>无</td>
<td>将栈顶两个 float 类型的数值出栈，以第一个栈顶元素为 value2，第二个栈顶元素为value1，如果 value1 和 value2 中有一个值为 NaN，则将 -1 压如栈中；如果 value1 - value2 &gt; 0，则将 1 压入栈中，如果 value1 - value2 &#x3D; 0，则将 0 压入栈中，如果 value1 - value2 &lt; 0，则将 -1 压入栈中</td>
</tr>
<tr>
<td>fcmpg</td>
<td>无</td>
<td>将栈顶两个 float 类型的数值出栈，以第一个栈顶元素为 value2，第二个栈顶元素为value1，如果 value1 和 value2 中有一个值为 NaN，则将 1 压如栈中；如果 value1 - value2 &gt; 0，则将 1 压入栈中，如果 value1 - value2 &#x3D; 0，则将 0 压入栈中，如果 value1 - value2 &lt; 0，则将 -1 压入栈中</td>
</tr>
<tr>
<td>dcmpl</td>
<td>无</td>
<td>将栈顶两个 double 类型的数值出栈，以第一个栈顶元素为 value2，第二个栈顶元素为value1，如果 value1 和 value2 中有一个值为 NaN，则将 -1 压如栈中；如果 value1 - value2 &gt; 0，则将 1 压入栈中，如果 value1 - value2 &#x3D; 0，则将 0 压入栈中，如果 value1 - value2 &lt; 0，则将 -1 压入栈中</td>
</tr>
<tr>
<td>dcmpg</td>
<td>无</td>
<td>将栈顶两个 double 类型的数值出栈，以第一个栈顶元素为 value2，第二个栈顶元素为value1，如果 value1 和 value2 中有一个值为 NaN，则将 1 压如栈中；如果 value1 - value2 &gt; 0，则将 1 压入栈中，如果 value1 - value2 &#x3D; 0，则将 0 压入栈中，如果 value1 - value2 &lt; 0，则将 -1 压入栈中</td>
</tr>
</tbody></table>
<h1 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h1><p>java 虚拟机直接支持数值类型的宽化类型转换指令（即小范围类型向大范围类型的安全转换），这些转换无需显示的转换指令，当然，也可以用转换指令来要求其进行显示的转换。其主要包括以下三种类型</p>
<ul>
<li>int 类型转换到 long、float 或者 double 类型</li>
<li>long 类型转换到 float、double 类型</li>
<li>float 类型转换到 double 类型</li>
</ul>
<p>对于窄转换类型（即大范围类型向小范围类型的安全转换），必须显示使用转换指令来完成，主要包括以下指令</p>
<table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>i2b</td>
<td>无</td>
<td>将栈顶 int 类型数值出栈，将其带符号转换成 byte 类型数据，并将其结果压入操作数栈。注意：此过程可能导致精度丢失，甚至可能导致转换结果与原先数值有不同的正负号</td>
</tr>
<tr>
<td>i2c</td>
<td>无</td>
<td>将栈顶 int 类型数值出栈，将其带符号转换成 char 类型数据，并将其结果压入操作数栈。注意：此过程可能导致精度丢失，甚至可能导致转换结果与原先数值有不同的正负号</td>
</tr>
<tr>
<td>i2s</td>
<td>无</td>
<td>将栈顶 int 类型数值出栈，将其带符号转换成 short 类型数据，并将其结果压入操作数栈。注意：此过程可能导致精度丢失，甚至可能导致转换结果与原先数值有不同的正负号</td>
</tr>
<tr>
<td>l2i</td>
<td>无</td>
<td>将栈顶 long 类型数值出栈，将其带符号转换成 int 类型数据，并将其结果压入操作数栈。注意：此过程可能导致精度丢失，甚至可能导致转换结果与原先数值有不同的正负号</td>
</tr>
<tr>
<td>l2f</td>
<td>无</td>
<td>将栈顶 long 类型数值出栈，将其带符号转换成 int 类型数据，并将其结果压入操作数栈。注意：此过程可能导致精度丢失，甚至可能导致转换结果与原先数值有不同的正负号</td>
</tr>
<tr>
<td>l2d</td>
<td>无</td>
<td>将栈顶 long 类型数值出栈，将其带符号转换成 double 类型数据，并将其结果压入操作数栈。注意：此过程可能导致精度丢失，甚至可能导致转换结果与原先数值有不同的正负号</td>
</tr>
<tr>
<td>f2i</td>
<td>无</td>
<td>将栈顶 float 类型数值出栈，将其带符号转换成 int 类型数据，并将其结果压入操作数栈。注意：此过程可能导致精度丢失，甚至可能导致转换结果与原先数值有不同的正负号</td>
</tr>
<tr>
<td>f2l</td>
<td>无</td>
<td>将栈顶 float 类型数值出栈，将其带符号转换成 long 类型数据，并将其结果压入操作数栈。注意：此过程可能导致精度丢失，甚至可能导致转换结果与原先数值有不同的正负号</td>
</tr>
<tr>
<td>f2d</td>
<td>无</td>
<td>将栈顶 float 类型数值出栈，将其带符号转换成 double 类型数据，并将其结果压入操作数栈。注意：此过程可能导致精度丢失，甚至可能导致转换结果与原先数值有不同的正负号</td>
</tr>
<tr>
<td>d2i</td>
<td>无</td>
<td>将栈顶 double 类型数值出栈，将其带符号转换成 int 类型数据，并将其结果压入操作数栈。注意：此过程可能导致精度丢失，甚至可能导致转换结果与原先数值有不同的正负号</td>
</tr>
<tr>
<td>d2l</td>
<td>无</td>
<td>将栈顶 double 类型数值出栈，将其带符号转换成 long 类型数据，并将其结果压入操作数栈。注意：此过程可能导致精度丢失，甚至可能导致转换结果与原先数值有不同的正负号</td>
</tr>
<tr>
<td>d2f</td>
<td>无</td>
<td>将栈顶 double 类型数值出栈，将其带符号转换成 float 类型数据，并将其结果压入操作数栈。注意：此过程可能导致精度丢失，甚至可能导致转换结果与原先数值有不同的正负号</td>
</tr>
</tbody></table>
<h1 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h1><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>new</td>
<td>两个，indexbyte1, indexbyte2</td>
<td>根据常量池中第 ((indexbyte1 &lt;&lt; 8) &amp;#124; indexbyte2) 个（从 1 开始计数）常量索引指向的类创建该类实例，并将类引用压入栈顶</td>
</tr>
<tr>
<td>newarray</td>
<td>一个，atype</td>
<td>根据 atype 确定要创建的基本数据类型，其中 atype的值表示如下：4 表示 boolean，5 表示 char，6 表示 float，7 表示 double，8 表示 byte，9 表示 short，10 表示 int，11 表示 long。然后将栈顶 int 类型的数值出栈，表示创建数组的大小，创建数组完毕后，将数组的引用值压入操作数栈中</td>
</tr>
<tr>
<td>anewarray</td>
<td>两个，indexbyte1, indexbyte2</td>
<td>根据常量池中第 ((indexbyte1 &lt;&lt; 8) &amp;#124; indexbyte2) 个（从 1 开始计数）常量索引指向的类确定创建数组的类型。然后将栈顶 int 类型的数值出栈，表示创建数组的大小，创建数组完毕后，将数组的引用值压入操作数栈中</td>
</tr>
<tr>
<td>getfield</td>
<td>两个，indexbyte1, indexbyte2</td>
<td>根据常量池中第 ((indexbyte1 &lt;&lt; 8) &amp;#124; indexbyte2) 个（从 1 开始计数）常量索引指向的字段确定具体的字段描述信息，然后将栈顶的对象引用数值出栈，根据对象引用和字段描述信息获取该字段的具体值，然后压入栈顶</td>
</tr>
<tr>
<td>putfield</td>
<td>两个，indexbyte1, indexbyte2</td>
<td>根据常量池中第 ((indexbyte1 &lt;&lt; 8) &amp;#124; indexbyte2) 个（从 1 开始计数）常量索引指向的字段确定具体的字段描述信息，然后将栈顶的数值 value 出栈，再将栈顶的对象引用 objectref 出栈，根据对象引用和字段描述信息获取该字段并将其设置为 value 值</td>
</tr>
<tr>
<td>getstatic</td>
<td>两个，indexbyte1, indexbyte2</td>
<td>根据常量池中第 ((indexbyte1 &lt;&lt; 8) &amp;#124; indexbyte2) 个（从 1 开始计数）常量索引指向的字段获取该字段的具体值，然后压入栈顶</td>
</tr>
<tr>
<td>putstatic</td>
<td>两个，indexbyte1, indexbyte2</td>
<td>根据常量池中第 ((indexbyte1 &lt;&lt; 8) &amp;#124; indexbyte2) 个（从 1 开始计数）常量索引指向的字段确定具体的字段描述信息，然后将栈顶的数值 value 出栈，根据字段描述信息获取该字段并将其设置为 value 值</td>
</tr>
<tr>
<td>baload</td>
<td>无</td>
<td>将栈顶的 int 类型数值 index 出栈（表示数组的下标），再将栈顶的 boolean 或 byte 类型的数组引用类型 arrayref 出栈，根据 arrayref 和 index 定位到具体的数组元素，将其具体值压入栈顶</td>
</tr>
<tr>
<td>caload</td>
<td>无</td>
<td>将栈顶的 int 类型数值 index 出栈（表示数组的下标），再将栈顶的 char 类型的数组引用类型 arrayref 出栈，根据 arrayref 和 index 定位到具体的数组元素，将其具体值压入栈顶</td>
</tr>
<tr>
<td>iaload</td>
<td>无</td>
<td>将栈顶的 int 类型数值 index 出栈（表示数组的下标），再将栈顶的 int 类型的数组引用类型 arrayref 出栈，根据 arrayref 和 index 定位到具体的数组元素，将其具体值压入栈顶</td>
</tr>
<tr>
<td>daload</td>
<td>无</td>
<td>将栈顶的 int 类型数值 index 出栈（表示数组的下标），再将栈顶的 double 类型的数组引用类型 arrayref 出栈，根据 arrayref 和 index 定位到具体的数组元素，将其具体值压入栈顶</td>
</tr>
<tr>
<td>aaload</td>
<td>无</td>
<td>将栈顶的 int 类型数值 index 出栈（表示数组的下标），再将栈顶的对象类型的数组引用类型 arrayref 出栈，根据 arrayref 和 index 定位到具体的数组元素，将其具体值压入栈顶</td>
</tr>
<tr>
<td>bastore</td>
<td>无</td>
<td>将栈顶的 value 数值出栈，再将栈顶的 int 类型数值 index 出栈（表示数组的下标），再将栈顶的 boolean 或 byte 类型的数组引用类型 arrayref 出栈，根据 arrayref 和 index 定位到具体的数组元素，将该元素的值赋为 value 值</td>
</tr>
<tr>
<td>castore</td>
<td>无</td>
<td>将栈顶的 value 数值出栈，再将栈顶的 int 类型数值 index 出栈（表示数组的下标），再将栈顶的 char 类型的数组引用类型 arrayref 出栈，根据 arrayref 和 index 定位到具体的数组元素，将该元素的值赋为 value 值</td>
</tr>
<tr>
<td>iastore</td>
<td>无</td>
<td>将栈顶的 value 数值出栈，再将栈顶的 int 类型数值 index 出栈（表示数组的下标），再将栈顶的 int 类型的数组引用类型 arrayref 出栈，根据 arrayref 和 index 定位到具体的数组元素，将该元素的值赋为 value 值</td>
</tr>
<tr>
<td>dastore</td>
<td>无</td>
<td>将栈顶的 value 数值出栈，再将栈顶的 int 类型数值 index 出栈（表示数组的下标），再将栈顶的 double 类型的数组引用类型 arrayref 出栈，根据 arrayref 和 index 定位到具体的数组元素，将该元素的值赋为 value 值</td>
</tr>
<tr>
<td>aastore</td>
<td>无</td>
<td>将栈顶的 value 数值出栈，再将栈顶的 int 类型数值 index 出栈（表示数组的下标），再将栈顶的对象类型的数组引用类型 arrayref 出栈，根据 arrayref 和 index 定位到具体的数组元素，将该元素的值赋为 value 值</td>
</tr>
<tr>
<td>arraylength</td>
<td>无</td>
<td>将栈顶的数组引用值出栈，获取数组的长度，并将其压入栈顶</td>
</tr>
<tr>
<td>instanceof</td>
<td>两个，indexbyte1, indexbyte2</td>
<td>根据常量池中第 ((indexbyte1 &lt;&lt; 8) &amp;#124; indexbyte2) 个（从 1 开始计数）常量索引指向的类确定具体的类描述信息 class，然后将栈顶元素 objectref 出栈，检查 objectref 是否是指定的类 class，如果是，则将 1 压入栈顶，否则将 0 压入栈顶</td>
</tr>
<tr>
<td>checkcast</td>
<td>两个，indexbyte1, indexbyte2</td>
<td>根据常量池中第 ((indexbyte1 &lt;&lt; 8) &amp;#124; indexbyte2) 个（从 1 开始计数）常量索引指向的类确定具体的类描述信息 class，然后将栈顶元素 objectref 出栈，检查 objectref 是否可以转换成指定的类 class，如果可以，则将 objectref 压入栈顶，否则抛出 ClassCastException 异常</td>
</tr>
</tbody></table>
<h1 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h1><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>pop</td>
<td>无</td>
<td>将操作数栈顶元素出栈</td>
</tr>
<tr>
<td>pop2</td>
<td>无</td>
<td>将操作数栈顶两个元素出栈</td>
</tr>
<tr>
<td>dup</td>
<td>无</td>
<td>将操作数栈顶元素进行复制，然后将复制值压入栈顶</td>
</tr>
<tr>
<td>dup2</td>
<td>无</td>
<td>将操作数栈顶两个元素进行复制，然后按顺序将复制值压入栈顶。具体操作过程如下：将操作数栈顶元素 value2 出栈，再将栈顶元素 value1 出栈，对 value1 进行复制得到 value1_1，对 value2 复制得到 value2_1，然后将 value1 入栈，再将 value2 入栈，再将 value1_1 入栈，再将 value2_1 入栈</td>
</tr>
<tr>
<td>dup_x1</td>
<td>无</td>
<td>复制操作数栈栈顶的值，并插入到栈顶以下 2 个值之后。具体操作过程如下：将栈顶元素 value2 出栈，复制 value2 得到 value2_1，再将栈顶 value1 出栈，然后将 value2_1 入栈，再将 value1 入栈，再将 value2 入栈</td>
</tr>
<tr>
<td>dup_x2</td>
<td>无</td>
<td>复制操作数栈栈顶的值，并插入到栈顶以下 2 个（次栈顶元素是 long 或 double 类型）或 3 个（次栈顶元素不是 long 或 double 类型）值之后。具体操作过程如下（以次栈顶元素不是 long 或 double 类型为例）：将栈顶元素 value3 出栈，复制 value3 得到 value3_1，再将栈顶 value2 出栈，再将栈顶 value1 出栈，然后将 value3_1 入栈，再将 value1 入栈，再将 value2 入栈，再将 value3 入栈</td>
</tr>
<tr>
<td>dup2_x1</td>
<td>无</td>
<td>dup_x1 的双倍版本，即复制两个栈顶元素</td>
</tr>
<tr>
<td>dup2_x2</td>
<td>无</td>
<td>dup_x2 的双倍版本，即复制两个栈顶元素</td>
</tr>
<tr>
<td>swap</td>
<td>无</td>
<td>将操作数栈顶的两个元素互换</td>
</tr>
</tbody></table>
<h1 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h1><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ifeq</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶元素出栈，将这个值与 0 进行比较，如果等于 0，则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>iflt</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶元素出栈，将这个值与 0 进行比较，如果小于 0，则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>ifne</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶元素出栈，将这个值与 0 进行比较，如果不等于 0，则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>ifge</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶元素出栈，将这个值与 0 进行比较，如果大于或等于 0，则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>ifgt</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶元素出栈，将这个值与 0 进行比较，如果大于 0，则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>ifle</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶元素出栈，将这个值与 0 进行比较，如果小于或等于 0，则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>ifnull</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶元素出栈，判断这个值是否是 null，如果是 null, 则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>ifnonnull</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶元素出栈，判断这个值是否是 null，如果不是 null, 则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>if_icmpeq</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶元素 value2 出栈，再将栈顶元素 value1 出栈，如果 value1 &#x3D;&#x3D; values, 则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>if_icmpne</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶元素 value2 出栈，再将栈顶元素 value1 出栈，如果 value1 !&#x3D; values, 则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>if_icmplt</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶元素 value2 出栈，再将栈顶元素 value1 出栈，如果 value1 &lt; values, 则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>if_icmpge</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶元素 value2 出栈，再将栈顶元素 value1 出栈，如果 value1 &gt;&#x3D; values, 则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>if_icmpgt</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶元素 value2 出栈，再将栈顶元素 value1 出栈，如果 value1 &gt; values, 则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>if_icmple</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶元素 value2 出栈，再将栈顶元素 value1 出栈，如果 value1 &lt;&#x3D; values, 则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>if_acmpeq</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶对象引用类型元素 value2 出栈，再将栈顶对象引用类型元素 value1 出栈，如果 value1 &#x3D;&#x3D; values, 则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>if_acmpne</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>将栈顶对象引用类型元素 value2 出栈，再将栈顶对象引用类型元素 value1 出栈，如果 value1 !&#x3D; values, 则跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，否则继续执行下一条指令</td>
</tr>
<tr>
<td>goto</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>无条件跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令</td>
</tr>
<tr>
<td>goto_w</td>
<td>四个，branchbyte1, branchbyte2, branchbyte3, branchbyte4</td>
<td>无条件跳转到 ((branchbyte1 &lt;&lt; 24) &amp;#124; (branchbyte2 &lt;&lt; 16) &amp;#124; (branchbyte3 &lt;&lt; 8) &amp;#124; branchbyte4) 位置处执行指令</td>
</tr>
<tr>
<td>jsr</td>
<td>两个，branchbyte1, branchbyte2</td>
<td>无条件跳转到 ((branchbyte1 &lt;&lt; 8) &amp;#124; branchbyte2) 位置处执行指令，并将 jsr 的下一条指令地址压如栈顶</td>
</tr>
<tr>
<td>jsr_w</td>
<td>四个，branchbyte1, branchbyte2, branchbyte3, branchbyte4</td>
<td>无条件跳转到 ((branchbyte1 &lt;&lt; 24) &amp;#124; (branchbyte2 &lt;&lt; 16) &amp;#124; (branchbyte3 &lt;&lt; 8) &amp;#124; branchbyte4) 位置处执行指令，并将 jsr 的下一条指令地址压如栈顶</td>
</tr>
<tr>
<td>ret</td>
<td>一个，index</td>
<td>返回本地变量指定的 index 的指令位置（一般与 jsr 或 jsr_w 联合使用）。index是一个 0 ~ 255 之间的无符号数，它代表一个当前栈帧的局部变量表的索引值，在该索引位置应为一个returnAddress类型的局部变量，指令执行后，将该局部变量的值更新到Java虚拟机的 PC 寄存器中，令程序从修改后的位置继续执行</td>
</tr>
</tbody></table>
<h1 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h1><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>invokevirtual</td>
<td>两个，indexbyte1, indexbyte2</td>
<td>调用实例方法。具体操作是：取出常量池中第 ((indexbyte1 &lt;&lt; 8) &amp;#124; indexbyte2) 个（从 1 开始计数）常量的索引对应的方法描述符，依次弹出操作数栈中的函数个数，再将栈顶的实例引用弹出，根据这些信息调用具体实例的函数</td>
</tr>
<tr>
<td>invokespecial</td>
<td>两个，indexbyte1, indexbyte2</td>
<td>调用超类的构造方法，实例初始化方法，私有方法。具体操作是：取出常量池中第 ((indexbyte1 &lt;&lt; 8) &amp;#124; indexbyte2) 个（从 1 开始计数）常量的索引对应的方法描述符，依次弹出操作数栈中的函数个数，再将栈顶的实例引用弹出，根据这些信息调用具体函数</td>
</tr>
<tr>
<td>invokestatic</td>
<td>两个，indexbyte1, indexbyte2</td>
<td>调用静态方法。具体操作是：取出常量池中第 ((indexbyte1 &lt;&lt; 8) &amp;#124; indexbyte2) 个（从 1 开始计数）常量的索引对应的方法描述符，依次弹出操作数栈中的函数个数，根据这些信息调用具体函数</td>
</tr>
<tr>
<td>invokeinterface</td>
<td>四个，indexbyte1, indexbyte2, count, 0（第四个操作数恒为 0）</td>
<td>调用接口方法。具体操作是：取出常量池中第 ((indexbyte1 &lt;&lt; 8) &amp;#124; indexbyte2) 个（从 1 开始计数）常量的索引对应的方法描述符，根据操作数 count 依次弹出操作数栈中的函数个数，根据这些信息调用具体函数</td>
</tr>
<tr>
<td>invodedynamic</td>
<td>四个，indexbyte1, indexbyte2, 0, 0（第三个和第四个操作数恒为 0）</td>
<td>调用动态方法</td>
</tr>
</tbody></table>
<h1 id="返回指令"><a href="#返回指令" class="headerlink" title="返回指令"></a>返回指令</h1><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ireturn</td>
<td>无</td>
<td>从当前方法返回 int 类型数值，可用于函数返回类型是 boolean、byte、char、short、int 的函数返回指令中</td>
</tr>
<tr>
<td>lreturn</td>
<td>无</td>
<td>从当前方法返回 long 类型数值</td>
</tr>
<tr>
<td>freturn</td>
<td>无</td>
<td>从当前方法返回 float 类型数值</td>
</tr>
<tr>
<td>dreturn</td>
<td>无</td>
<td>从当前方法返回 double 类型数值</td>
</tr>
<tr>
<td>areturn</td>
<td>无</td>
<td>从当前方法返回对象引用</td>
</tr>
<tr>
<td>return</td>
<td>无</td>
<td>从当前方法返回 void</td>
</tr>
</tbody></table>
<h1 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h1><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>athrow</td>
<td>无</td>
<td>将栈顶的异常抛出</td>
</tr>
</tbody></table>
<h1 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h1><table>
<thead>
<tr>
<th>助记符</th>
<th>操作数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>monitorenter</td>
<td>无</td>
<td>将栈顶的引用对象出栈，获取该对象的锁，用于进入同步块</td>
</tr>
<tr>
<td>monitorexit</td>
<td>无</td>
<td>将栈顶的引用对象出栈，释放该对象的锁，用于退出同步块</td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践[M]. 北京：机械工业出版社，2013<br>[2] Tim Lindholm, Frank Yellin, Gilad Bracha, Alex Buckley. Java虚拟机规范(Java SE 7版)[M]. 北京：机械工业出版社，2014</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>java 内存模型</title>
    <url>/jvm/jvm-jmm/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java 内存模型（Java Memory Model, JMM）是 java 虚拟机定义的一种抽象的模型，主要是用来屏蔽各种硬件和操作系统的内存访问差异，以实现让 java 程序在各种平台下都能达到一致的内存访问效果。其模型大致如下图所示：</p>
<p><img src="/images/jvm/JMM.png" alt="java内存模型"></p>
<span id="more"></span>

<h1 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h1><p>在 java 内存模型中，主内存是各个线程共享的，主要用于存在程序中创建的对象。与 java 内存区域（JVM 内存模型）中的堆可以进行类比，两者的功能类似。</p>
<p>工作内存，则是各个线程独享的，各个线程之间互不干扰。与 java 内存区域中的虚拟机栈类似，都是存放着本线程使用到的局部变量，如 int、long 等基本类型。需要注意的是，使用 Interger、Long 等包装类型或其他类对象，其对象实例是在主内存中，而持有该对象的引用则是在工作内存中。</p>
<p>当需要使用主内存的对象时，会将主内存的对象拷贝到线程的工作内存中，即线程的工作内存持有主内存变量的副本，当线程对该变量执行完毕后，需要将新的变量值写入主内存，此时，也是先将结果放在工作内存中，然后再从工作内存中写入主内存。从这个角度来说，工作内存就是线程执行引擎与主内存之间的桥梁，无论是读取还是更新主内存的变量，都需要先通过线程的工作内存进行。</p>
<h1 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h1><p>工作内存和主内存需要频繁进行通信，java 内存模型也为此定义了 8 中原子操作来完成这种交互。</p>
<ul>
<li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。使用之后，其他线程只有等待 unlock 操作后才能继续对该变量执行 lock 操作。</li>
<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</li>
<li>load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的赋值给工作内存的变量，没当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。</li>
<li>write（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量值放入主内存的变量中。</li>
</ul>
<p>除了定义这 8 种操作之外，java 内存模型还定义这 8 种基本操作必须满足的原则：</p>
<ul>
<li>不允许 read 和 load 操作单独出现，也不允许 store 和 write 操作单独出现，也就是说 read 和 load 操作（store 和 write 操作）这两个操作是绑定的，必须成对出现。虽然如此，但是并没有说这两个操作必须连续出现，也就是说执行这两个操作中间可以执行其他的操作。如读取两个变量 a 和 b，执行的顺序可以是 <code>read a -&gt; read b -&gt; load a -&gt; load b</code>。</li>
<li>不允许一个线程丢弃他的最近的 assign 操作，即变量在工作在工作内存中改变了之后必须把该变化同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步到主内存中。</li>
<li>一个新的变量（不包括基本类型的局部变量）只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，即对一个变量实施 use、store 操作之前，必须先执行了 assign 和 load 操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一个线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</li>
<li>如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</li>
<li>如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</li>
<li>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）。</li>
</ul>
<h1 id="java-内存模型特性"><a href="#java-内存模型特性" class="headerlink" title="java 内存模型特性"></a>java 内存模型特性</h1><p>java 内存模型有三大特性：原子性、可见性、有序性。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性（Atomicity）是指一个操作是不可中断的，即一个操作一旦开始执行就必须等待其执行完成，中间不会插入其他的操作。即使在多线程的环境下也是如此。java 内存模型提供的 8 中基本操作都是原子性的（虽然对 long 和 double 这种 64 位的数据结构而言，部分操作可以不是原子性的，但是几乎所有的商业虚拟机都是将其实现成原子性的），这些基本的操作能控制一些比较简单的指令。而对于需要将一块代码块（多个程序语句）实现成原子性时，Java 代码中也提供了 <code>synchronized </code> 关键字来保证，其对应到字节码指令是 <code>monitorenter</code> 和 <code>monitorexit</code>。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性（Visibility）是指当一个线程修改了共享变量的值，其他线程能够立即得到这个修改。这主要是通过将更新后的变量值及时写入主内存，同时其他线程获取变量时直接从主内存获取到工作内存来实现的。在 java 中有 <code>volatile</code>、<code>synchronized</code>、<code>final</code> 三个关键字可以实现可见性。</p>
<ul>
<li>volatile：被 volatile 修饰的变量，读取变量时，直接从主内存读取，更新变量时，立即同步到主内存。通过这种方式实现其可见性。</li>
<li>synchronized：其可见性是由 “对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）” 这个规则保证的。</li>
<li>final：被 final 修饰的字段（所在对象存在于主内存中）在构造器中一旦完成初始化并且构造器没有将 “this” 的引用传递出去，则其他线程能看到 final 字段的值。</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序性（Ordering）指在本线程内观察，所有的操作都是有序的（即串性执行）。而对于在一个线程中观察另一个线程，则操作是无序的，这主要是指 “指令重排“ 和 “工作内存与主内存同步延迟” 。</p>
<p>java 提供了 <code>volatile</code> 和 <code>synchronized</code> 两个关键字来保证线程之间操作的有序性。</p>
<ul>
<li>volatile：通过禁止指令重排序来实现线程的有序性</li>
<li>synchronized：其有序性由 “一个变量在同一个时刻只允许一条线程对其进行 lock 操作” 这个规则来保证的。</li>
</ul>
<h1 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h1><p>除了  <code>volatile</code> 和 <code>synchronized</code> 这两个关键字保证有序性之外，java 内存模型也默认提供并执行一些先行发生原则来保证有序性。</p>
<p>先行发生是 java 内存模型中定义的两种操作之间的偏序关系，如果操作 A 先行与操作 B 发生，则操作 A 执行的结果能够被操作 B 观察到。</p>
<p>先行发生原则包括以下几点：</p>
<ul>
<li>程序次序规则（Program Order Rule）：在一个线程内，安装程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。</li>
<li>管城锁定规则（Monitor Lock Rule）：一个 unlock 操作先行发生于后面（时间上的先后）对于同一个锁的 lock 操作。</li>
<li>volatile 变量规则（Volatile Variable Rule）：对一个 volatile 变量的写操作先行发生于后面（时间上的先后）对这个变量的读操作。</li>
<li>线程启动规则（Thread Start Rule）：Thread 对象的 start 方法先行发生于此线程的每个动作。</li>
<li>线程终止规则（Thread Termination Rule）：线程中所有操作都先行发生于对此线程的终止。</li>
<li>线程中断规则（Thread Interruption Rule）：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。可以通过 Thread.interrupted() 方法检测到是否有中断发生。也就是说， interrupt() 方法先于 Thread.interrupted() 方法执行。</li>
<li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</li>
<li>传递性（Transitivity）：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，则操作 A 先行发生于操作 C。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 周志明，深入理解Java虚拟机：JVM高级特性与最佳实践[M]，北京：机械工业出版社，2013</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm 内存分配策略</title>
    <url>/jvm/jvm-memory-allocation/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>虚拟机将内存区域划分为新生代和老年代，在新生代中又划分成一个Eden和两个Survivor区域。对象的内存分配，主要是在新生代的Eden区上进行分配，部分比较大的对象会直接分配在老年代中。虽然对象的分配根据使用的垃圾回收器不同而有所区别，但是总体上而言，主要有以下几个分配原则：对象优先分配在Eden区、大对象直接分配在老年代、长期存活的对象将进入老年代、动态对象年龄判定、空间分配担保。</p>
<span id="more"></span>

<h1 id="对象优先分配在Eden区"><a href="#对象优先分配在Eden区" class="headerlink" title="对象优先分配在Eden区"></a>对象优先分配在Eden区</h1><p>一般情况下，对象是直接分配在Eden区的，如果Eden区空间不够，将发生一次Minor GC进行垃圾回收。如下程序所示，程序配置的jvm参数中使用了<code>-XX:+UseSerialGC</code>启动了Serial + Serial Old的垃圾回收器组合进行垃圾回收，使用<code>-Xms20M</code>限制堆的最小值为20MB，使用<code>-Xmx20M</code>限制堆的最大值为20MB，从而限制了堆的大小为20MB，使用<code>-Xmn10M</code>限制了新生代大小为10MB，从而确认了老年代大小为10MB，使用<code>-XX:SurvivorRatio=8</code>限制了Eden区大小为8MB，两个Survivor区分别为1MB，使用<code>-XX:+PrintGCDetails</code>打印内存回收日志，并在进程退出时输出当前的内存各区域分配情况。</p>
<p>在程序中，先分配了3个2MB的空间，此时Eden区有足够内存进行分配，当要再分配4MB的时候，Eden区内存不够（Eden区除了放置allocation1、allocation2、allocation3三个对象外，还存在着一些元数据信息）4M，所以触发一次Minor GC。</p>
<p>Minor GC发生后，由于Survivor区只有1MB，不足以容纳6MB，所以allocation1、allocation2、allocation3三个对象通过分配担保提前进入老年代，从GC日志中可用看出，老年代中内存使用率有60%，此时Eden区已经有足够容量放置allocation4对象了，所以将allocation4对象分配到Eden区，加上其他一些数据，可用看到Eden区占比53%。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序使用的jvm参数：-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEdenAllocation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="type">byte</span>[] allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="type">byte</span>[] allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 出现Minor GC </span></span><br><span class="line">        <span class="type">byte</span>[] allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GC日志如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 7315K-&gt;508K(9216K), <span class="number">0.0074568</span> secs] 7315K-&gt;6652K(19456K), <span class="number">0.0075242</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 9216K, used 4850K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">53</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff03d8f0</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,  <span class="number">49</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff57f018</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 6144K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">60</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffc00030</span>, <span class="number">0x00000000ffc00200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 2463K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 271K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<h1 id="大对象直接分配在老年代"><a href="#大对象直接分配在老年代" class="headerlink" title="大对象直接分配在老年代"></a>大对象直接分配在老年代</h1><p>大对象指需要大量连续内存空间的对象。虚拟机中提供了一个-XX:PretenureSizeThreshold参数来设置大对象分配在老年代的条件，当分配的对象大小超过这个值时，直接分配在老年代中。</p>
<p>如下程序所示，设置-XX:PretenureSizeThreshold的值为2097152（也就是2MB，这个值不能按照Xms那样按MB单位计算，只能按B单位计算），表示当分配的对象大小超过2M时，会直接分配在老年代中。从GC日志中也可以看出，在老年代中，内存使用率是40%（4MB），这就是allocation对象的内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序使用的jvm参数：-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8  -XX:PretenureSizeThreshold=2097152 -XX:+UseSerialGC</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPreTenureSizeThreshold</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GC日志如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 9216K, used 1499K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">18</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fed76fd0</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 4096K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">40</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffa00010</span>, <span class="number">0x00000000ffa00200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 2494K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 271K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>需要注意的是PretenureSizeThreshold参数只对Serial和ParNew两款回收器有效，Parallel Scavenge回收器不认识这个参数。如下程序所示，使用Parallel Scavenge回收器，即使设置了这个参数，对象还是分配在Eden区中。从GC日志中可以看出，Eden区内存使用率为68%，而老年代中内存使用率为0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序使用的jvm参数：-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8  -XX:PretenureSizeThreshold=2097152 -XX:+UseParallelGC</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPreTenureSizeThreshold</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GC日志如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 5595K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">68</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffb76ec0</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line"> ParOldGen       total 10240K, used 0K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  object space 10240K, <span class="number">0</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace       used 2494K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 271K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<h1 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h1><p>对象一般分配在新生代的Eden区中，但是存活对象也不会一直在新生代中，否则新生代很容易空间不足，因此当存活对象在新生代中到达一定时间后会移动到老年代中。为此，虚拟机给每个对象定义了一个对象年龄（Age）计算器：如果对象在Eden中并经过一次Minor GC后仍然存活，并且能够被survivor区容纳，则该对象将被移动到survivor区中，并且将对象年龄设置为1，后续每经过一次Minor GC后对象仍然存活，则对象年龄加一，当对象年龄到达一个阈值（默认是15）时，将对象移动到老年代中。虚拟机中提供了-XX:MaxTernuringThreshold参数来表示将新生代对象移动到老年代对象的阈值。</p>
<p>如下程序所示，设置-XX:MaxTernuringThreshold参数的值为1，表示新生代对象年龄超过1后将其移动到老年代中。从GC日志中可以看出，在程序退出时，surivor from区的空间使用率是0，而老年代中空间使用率是84%：allocation2（8MB） + allocation3（8MB） + allocation1（512KB） + 一些元数据信息（511KB）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序使用的jvm参数：-Xms40M -Xmx40M -Xmn20M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMaxTenuringThreshold</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">2</span>];</span><br><span class="line">        <span class="type">byte</span>[] allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span> * _1MB];</span><br><span class="line">        <span class="comment">// 此处发生一次Minor GC</span></span><br><span class="line">        <span class="type">byte</span>[] allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span> * _1MB];</span><br><span class="line">        <span class="comment">// 此处再次发生Minor GC</span></span><br><span class="line">        <span class="type">byte</span>[] allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GC日志如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew</span><br><span class="line">Desired survivor size <span class="number">1048576</span> bytes, <span class="keyword">new</span> <span class="title class_">threshold</span> <span class="number">1</span> (max <span class="number">1</span>)</span><br><span class="line">- age   <span class="number">1</span>:    <span class="number">1048416</span> bytes,    <span class="number">1048416</span> total</span><br><span class="line">: 10670K-&gt;1023K(18432K), <span class="number">0.0091166</span> secs] 10670K-&gt;9215K(38912K), <span class="number">0.0091897</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew</span><br><span class="line">Desired survivor size <span class="number">1048576</span> bytes, <span class="keyword">new</span> <span class="title class_">threshold</span> <span class="number">1</span> (max <span class="number">1</span>)</span><br><span class="line">- age   <span class="number">1</span>:        <span class="number">120</span> bytes,        <span class="number">120</span> total</span><br><span class="line">: 9543K-&gt;0K(18432K), <span class="number">0.0074626</span> secs] 17735K-&gt;17407K(38912K), <span class="number">0.0075102</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 18432K, used 8356K [<span class="number">0x00000000fd800000</span>, <span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fec00000</span>)</span><br><span class="line">  eden space 16384K,  <span class="number">51</span>% used [<span class="number">0x00000000fd800000</span>, <span class="number">0x00000000fe0290e0</span>, <span class="number">0x00000000fe800000</span>)</span><br><span class="line">  from space 2048K,   <span class="number">0</span>% used [<span class="number">0x00000000fe800000</span>, <span class="number">0x00000000fe800078</span>, <span class="number">0x00000000fea00000</span>)</span><br><span class="line">  to   space 2048K,   <span class="number">0</span>% used [<span class="number">0x00000000fea00000</span>, <span class="number">0x00000000fea00000</span>, <span class="number">0x00000000fec00000</span>)</span><br><span class="line"> tenured generation   total 20480K, used 17407K [<span class="number">0x00000000fec00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 20480K,  <span class="number">84</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ffcffe80</span>, <span class="number">0x00000000ffd00000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 2496K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 272K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>当将-XX:MaxTernuringThreshold参数值设置成15时，GC日志如下。可以发现，程序退出时，survivior from区中空间使用率有49%：allocation1（512KB）+ 一些元数据（511KB），而老年代中使用率只有80%：allocation2（8MB） + allocation3（8MB）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew</span><br><span class="line">Desired survivor size <span class="number">1048576</span> bytes, <span class="keyword">new</span> <span class="title class_">threshold</span> <span class="number">15</span> (max <span class="number">15</span>)</span><br><span class="line">- age   <span class="number">1</span>:    <span class="number">1048416</span> bytes,    <span class="number">1048416</span> total</span><br><span class="line">: 10670K-&gt;1023K(18432K), <span class="number">0.0075451</span> secs] 10670K-&gt;9215K(38912K), <span class="number">0.0076104</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew</span><br><span class="line">Desired survivor size <span class="number">1048576</span> bytes, <span class="keyword">new</span> <span class="title class_">threshold</span> <span class="number">15</span> (max <span class="number">15</span>)</span><br><span class="line">- age   <span class="number">1</span>:        <span class="number">120</span> bytes,        <span class="number">120</span> total</span><br><span class="line">- age   <span class="number">2</span>:    <span class="number">1048160</span> bytes,    <span class="number">1048280</span> total</span><br><span class="line">: 9543K-&gt;1023K(18432K), <span class="number">0.0077775</span> secs] 17735K-&gt;17407K(38912K), <span class="number">0.0078239</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 18432K, used 9379K [<span class="number">0x00000000fd800000</span>, <span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fec00000</span>)</span><br><span class="line">  eden space 16384K,  <span class="number">51</span>% used [<span class="number">0x00000000fd800000</span>, <span class="number">0x00000000fe0290e0</span>, <span class="number">0x00000000fe800000</span>)</span><br><span class="line">  from space 2048K,  <span class="number">49</span>% used [<span class="number">0x00000000fe800000</span>, <span class="number">0x00000000fe8ffed8</span>, <span class="number">0x00000000fea00000</span>)</span><br><span class="line">  to   space 2048K,   <span class="number">0</span>% used [<span class="number">0x00000000fea00000</span>, <span class="number">0x00000000fea00000</span>, <span class="number">0x00000000fec00000</span>)</span><br><span class="line"> tenured generation   total 20480K, used 16384K [<span class="number">0x00000000fec00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 20480K,  <span class="number">80</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ffc00020</span>, <span class="number">0x00000000ffc00200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 2496K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 272K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<h1 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h1><p>为了能更好地适应不同程序的内存情况，虚拟机并不是永远要求对象的年龄必须达到了MaxTernuringThreshold才能移动到老年代中。如果在survivor中相同年龄的对象大小总和大于survivor空间的一半，年龄大于或等于该年龄的对象将直接进入老年代中。</p>
<p>如下程序所示，设置MaxTernuringThreshold的值为15，在发生第一次Minor GC时，allocation1和allocation2对象及部分元数据对象被移动到survivor区，并且设置对象年龄为1，allocation3对象被移动到老年代中，当第二次Minor GC时，allocation4对象被移动到老年代中，survivor区中allocation1和allocation2及部分元数据对象总和大于1024KB，且他们年龄相同，这满足大于survivor区的一半空间的要求，因此他们被移动到老年代中。从GC日志也可以看出，survivor区空间使用率为0，而老年代中空间使用率为87%（allocation1、allocation2、allocation3、allocation4、一些元数据对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序使用的jvm参数：-Xms40M -Xmx40M -Xmn20M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMaxTenuringThreshold</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">2</span>];</span><br><span class="line">        <span class="type">byte</span>[] allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">2</span>];</span><br><span class="line">        <span class="type">byte</span>[] allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span> * _1MB];</span><br><span class="line">        <span class="comment">// 此处再次发生Minor GC</span></span><br><span class="line">        <span class="type">byte</span>[] allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span> * _1MB];</span><br><span class="line">        <span class="comment">// 此处发生一次Minor GC</span></span><br><span class="line">        <span class="type">byte</span>[] allocation5 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GC日志如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew</span><br><span class="line">Desired survivor size <span class="number">1048576</span> bytes, <span class="keyword">new</span> <span class="title class_">threshold</span> <span class="number">1</span> (max <span class="number">15</span>)</span><br><span class="line">- age   <span class="number">1</span>:    <span class="number">1572720</span> bytes,    <span class="number">1572720</span> total</span><br><span class="line">: 11182K-&gt;1535K(18432K), <span class="number">0.0066021</span> secs] 11182K-&gt;9727K(38912K), <span class="number">0.0066686</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew</span><br><span class="line">Desired survivor size <span class="number">1048576</span> bytes, <span class="keyword">new</span> <span class="title class_">threshold</span> <span class="number">15</span> (max <span class="number">15</span>)</span><br><span class="line">- age   <span class="number">1</span>:        <span class="number">120</span> bytes,        <span class="number">120</span> total</span><br><span class="line">: 10055K-&gt;0K(18432K), <span class="number">0.0079043</span> secs] 18247K-&gt;17919K(38912K), <span class="number">0.0079458</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 18432K, used 8356K [<span class="number">0x00000000fd800000</span>, <span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fec00000</span>)</span><br><span class="line">  eden space 16384K,  <span class="number">51</span>% used [<span class="number">0x00000000fd800000</span>, <span class="number">0x00000000fe0290e0</span>, <span class="number">0x00000000fe800000</span>)</span><br><span class="line">  from space 2048K,   <span class="number">0</span>% used [<span class="number">0x00000000fe800000</span>, <span class="number">0x00000000fe800078</span>, <span class="number">0x00000000fea00000</span>)</span><br><span class="line">  to   space 2048K,   <span class="number">0</span>% used [<span class="number">0x00000000fea00000</span>, <span class="number">0x00000000fea00000</span>, <span class="number">0x00000000fec00000</span>)</span><br><span class="line"> tenured generation   total 20480K, used 17919K [<span class="number">0x00000000fec00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 20480K,  <span class="number">87</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ffd7fe90</span>, <span class="number">0x00000000ffd80000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 2497K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 272K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<h1 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h1><p>新生代中使用复制算法进行垃圾回收，而新生代又分成一个大的Eden区和两个小的Survivor区，当发生Minor GC时，是将Eden和一个Survivor中的存活对象复制到另一个Survivor区中。这就存在一个风险：如果存活的对象过多，Survivor区容纳不下，进行Minor GC并不能将所有的存活对象复制到Survivor中。此时就需要老年代进行空间分配担保，将Survivor无法容纳的对象直接移动到老年代中。更进一步，如果老年代也容纳不下这些存活对象呢（这种情况称为担保失败（Handle Promotion Failure）），那就进行一次Full GC。</p>
<p>事实上，在JDK 6 Update 24版本之后，只要老年代中连续空间大于新生代对象总大小或者大于新生代对象历次晋升到老年代的平均大小，虚拟机就会进行一次Minor GC（担保失败则进行一次Full GC）,否则直接进行Full GC</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Minor-GC和Full-GC的区别"><a href="#Minor-GC和Full-GC的区别" class="headerlink" title="Minor GC和Full GC的区别"></a>Minor GC和Full GC的区别</h2><p>Minor GC：指发生在新生代的垃圾回收，发生频率高，回收速度快</p>
<p>Full GC：也称Major GC，指发生在老年代的垃圾回收，发生频率低，回收速度慢。一般情况下，发生Majorl GC会伴随着至少一次Minor GC，但是部分回收器（如Parallel Scavenge回收器）的回收策略也可以直接跳过Minor GC而直接出发Major GC</p>
<h2 id="对象流程图"><a href="#对象流程图" class="headerlink" title="对象流程图"></a>对象流程图</h2><p>一个对象在新生代和老年代之间的流动如下图所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start=&gt;start: Start</span><br><span class="line">isObjectSizeTooBig=&gt;condition: 对象大小超过阈值</span><br><span class="line">                              PretenureSizeThreshold</span><br><span class="line">newObjectInTenuredArea=&gt;operation: 在老年代中分配对象</span><br><span class="line">newObjectInEdenArea=&gt;operation: 在Eden区中分配对象</span><br><span class="line">happenMinorGC=&gt;operation: 运行一段时间发生Minor GC</span><br><span class="line">isSurvivorCanContainObject=&gt;condition: 对象是否能在</span><br><span class="line">Survivor区中</span><br><span class="line">存放</span><br><span class="line">moveToSurvivor=&gt;operation: 将对象移动到Survivor区</span><br><span class="line">happenMinorGC1=&gt;operation: 运行一段时间发生Minor GC</span><br><span class="line">isObjectAgeTooBig=&gt;condition: 对象年龄大小大于阈值</span><br><span class="line">						    MaxTernuringThreshold</span><br><span class="line">isSameAgeObjectSizeTooBig=&gt;condition: 相同年龄的对</span><br><span class="line">								   象大小总和大于</span><br><span class="line">								   Survivor区一</span><br><span class="line">								   半大小</span><br><span class="line">moveToTenuredArea=&gt;operation: 将对象移动到老年代</span><br><span class="line">addAge=&gt;operation: 对象年龄加一</span><br><span class="line">end=&gt;end: End</span><br><span class="line"></span><br><span class="line">start-&gt;isObjectSizeTooBig(yes, right)-&gt;newObjectInTenuredArea-&gt;end</span><br><span class="line">isObjectSizeTooBig(no)-&gt;newObjectInEdenArea-&gt;happenMinorGC-&gt;isSurvivorCanContainObject(no)-&gt;moveToTenuredArea-&gt;end</span><br><span class="line">isSurvivorCanContainObject(yes)-&gt;moveToSurvivor-&gt;happenMinorGC1-&gt;isObjectAgeTooBig(yes)-&gt;moveToTenuredArea-&gt;end</span><br><span class="line">isObjectAgeTooBig(no, left)-&gt;isSameAgeObjectSizeTooBig(yes)-&gt;moveToTenuredArea</span><br><span class="line">isSameAgeObjectSizeTooBig(no, left)-&gt;addAge(left)-&gt;happenMinorGC1</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践[M]. 北京：机械工业出版社，2013</p>
<p>[2]Abraham Han. java虚拟机长期存活的对象将进入老年代实验结果与书上不同?[J&#x2F;OL]. <a href="https://www.zhihu.com/question/36339308/answer/68189398">https://www.zhihu.com/question/36339308/answer/68189398</a> , 2018-03-21</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm 内存模型</title>
    <url>/jvm/jvm-memory-model/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在java虚拟机中，其将内存区域划分为：程序计数器、java虚拟机栈、本地方法栈、方法区、堆。这些不同的数据区域存放者不同的数据类型，也拥有不同的作用。其中方法区和堆是线程共享的，程序计数器、java虚拟机栈、本地方法栈是线程私有的。其关系大致如下图所示（图中区域大小并不表示内存中真正的大小）</p>
<span id="more"></span>

<p><img src="/images/jvm.png" alt="jvm内存模型"></p>
<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>程序计数器是一块比较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。也就是说，其用于标识程序下一个执行命令是哪条语句，比如 if 分支、while循环语句的结束和跳转都需要依靠程序计数器来完成，再比如函数A中调用函数B，在函数A调用时会依靠程序计数器中记录相关的值，当函数B调用结束时依靠程序计数器中读取原先的值获取下一条指令，从而保证函数B调用完后仍能继续在函数A中执行后续的语句。此内存区域是唯一 一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域，换句话说，此区域不会发生OutOfMemoryError</p>
<h1 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h1><p>java虚拟机栈描述的是java方法执行的内模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。换句话说，此区域存放着函数内的局部变量，当我们在函数中定义变量时，这些局部变量就存放在这个栈区域中。</p>
<p>这个区域可能会抛出两种异常：</p>
<ul>
<li>StackOverflowError异常：当调用栈深度超过虚拟机允许的栈深度时，抛出此异常。常见于递归调用中。</li>
<li>OutOfMemoryError异常：如果虚拟机栈可以动态扩展但是在扩展时无法申请到足够内存时抛出此异常。</li>
</ul>
<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>本地方法栈与java虚拟机栈类似，只不过java虚拟机栈是非native方法存储的空间，而本地方法栈是native方法存储的空间。其同样会抛出StackOverflowError异常和OutOfMemoryError异常。</p>
<h1 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h1><p>对绝大多数应用来说，堆是java虚拟机中内存最大的一部分，也是垃圾回收的主要区域。这个区域中的内容是共享的，也就是说，在某个函数中创建的对象存放在这个区域时，当函数结束离开，这个对象并不会跟着函数消失，仍然可以被其他函数使用。当我们使用new创建一个对象或数组时，这个新建出来的对象或数组就是存放在堆中。java虚拟机规范中指出，java堆不必处于物理上的连续空间，只需要逻辑上连续即可。</p>
<p>当新建一个对象时，在堆中没有足够的内存分配给对象时，将会抛出OutOfMemoryError异常。</p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>方法区主要用于存储<strong>已</strong>被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。也就是说，Class类的元数据信息（用于准确定义一个类，区分于其他类的信息，比如：类名、访问修饰符等）以及我们在程序中定义的常量和静态变量都存放在此区域中。这个区域也是线程共享的，不受限于具体的类或方法。</p>
<p>当方法区无法满足分配内存需求时，会会抛出OutOfMemoryError异常。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池(Runtime Constant Pool)是方法区中的一个区域，主要用于存放编译期生成的各种字面量和符合引用。我们在程序中定义的常量和Sting变量的值就存放在这个区域中。</p>
<p>虽然这个区域主要用于存放编译期生成的常量，但是这个区域仍然具有动态性。主要是因为java语言并不要求常量一定只有在编译期才能产生，在运行期间也能产生常量并将其放入运行时常量池中，其中最主要的方法便是<code>String.intern()</code>方法。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 周志明，深入理解Java虚拟机：JVM高级特性与最佳实践[M]，北京：机械工业出版社，2013</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm 对象存活判定算法</title>
    <url>/jvm/jvm-object-alive-algorithm/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java虚拟机会自动进行内存管理和垃圾回收，在进行垃圾回收之前，需要先判定对象是否存活，只有对象“死去”（这里并不是指对象消失，而是指根据算法判定对象可以进行垃圾回收）才能被垃圾回收器进行回收。这里主要有两种对象存活判定算法：引用计数法和可达性分析算法。</p>
<span id="more"></span>

<h1 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h1><p>引用计数法（Reference Counting）主要思想是通过给对象增加一个属性用于记录对象被引用的次数，当对象被其他对象引用时计数加一，当某个引用失效时计数减一，如果计数为0，则表示该对象不再被使用，可以在垃圾回收时进行回收。</p>
<p>引用计数法原理以及实现相对简单，一般情况下使用这个算法并没有太大的问题，但是其有一个很大的缺点，就是不能解决循环引用的问题：如果两个对象循环引用，但是并没有其他对象对这两个对象进行引用，从理论上来讲，这两个对象均是可以被垃圾回收的，但是如果是通过引用计数法的方法来判断是非可以回收的话，因为对这两个对象中的任何一个对象，都存在的引用，所以这两个对象都不会被垃圾回收。这在一定程度上来说会造成内存泄漏，所以目前市场上主流的java虚拟机里面没有选用引用计数法来管理内存。</p>
<h1 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h1><p>可达性分析（Reachability Analysis）算法主要思想是通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则表示该对象不再被使用，可以在垃圾回收时进行回收。此方法可以避免引用计数法中的循环引用引起的内存泄漏。如下图所示，Object1、Object2在GC Root1的引用链上，Object3、Objcect4在GC Root2的引用链上，因此这四个对象都是存活的对象，不能进行垃圾回收。而Object5和Object6这两个对象虽然存储循环引用，但是并没有在任何GC Roots的引用链上，因此这两个对象是可以进行垃圾回收的对象。</p>
<p><img src="/images/jvm/reachabilityAnalysis.png" alt="可达性算法图解"></p>
<p>在java语言中，可作为GC Roots的对象包括以下几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即Native方法）引用的对象</li>
</ul>
<h1 id="java中的引用"><a href="#java中的引用" class="headerlink" title="java中的引用"></a>java中的引用</h1><p>无论是通过引用计数法还是通过可达性分析算法来判断对象是否存活，都是根据对象是否被引用进行判断的。在java中有四种引用：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）。这四种引用强度依次减弱。</p>
<ul>
<li>强引用：强引用是代码中普遍存在的，只要强引用存在，垃圾回收器就不会回收强引用的对象。可以通过“Object obj &#x3D; new Object()”之类的new语句建立强引用</li>
<li>软引用：软引用是用来描述一些有用但是非必须的对象。在垃圾回收时，如果内存充足，则不会回收软引用的对象，如果经过一次回收之后内存仍然不足，则会将软引用的对象进行回收。可以通过SoftReference类来实现软引用</li>
<li>弱引用：弱引用也是用来描述非必须对象的，但是其强度比软引用还弱。在垃圾回收时，无论内存是否充足，弱引用的对象都会被回收。可以通过WeakReference类来实现弱引用</li>
<li>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构造影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被垃圾回收器回收时收到一个系统通知。可以通过PhantomReference类来实现虚引用</li>
</ul>
<p>下面程序展示了软引用和弱引用的区别</p>
<p>对于软引用对象，垃圾回收时，由于内存充足，所以不会被回收。而对于弱引用对象，即使内存充足，在垃圾回收时也会被回收。而关于虚引用，则无论是在垃圾回收前还是垃圾回收后，均无法通过虚引用获取实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReferenceType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReferenceType</span><span class="params">(String type)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ReferenceType [type=&quot;</span> + type + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReference</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ReferenceType</span> <span class="variable">strongReferece</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceType</span>(<span class="string">&quot;strong reference&quot;</span>);</span><br><span class="line">        SoftReference&lt;ReferenceType&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;ReferenceType&gt;(<span class="keyword">new</span> <span class="title class_">ReferenceType</span>(<span class="string">&quot;soft reference&quot;</span>));</span><br><span class="line">        WeakReference&lt;ReferenceType&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;ReferenceType&gt;(<span class="keyword">new</span> <span class="title class_">ReferenceType</span>(<span class="string">&quot;weak reference&quot;</span>));</span><br><span class="line">        PhantomReference&lt;ReferenceType&gt; phantomReference = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;ReferenceType&gt;(<span class="keyword">new</span> <span class="title class_">ReferenceType</span>(<span class="string">&quot;phantom reference&quot;</span>), <span class="literal">null</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----before gc----&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;strong reference: &quot;</span> + strongReferece);</span><br><span class="line">        System.out.println(<span class="string">&quot;soft reference: &quot;</span> + softReference.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;weak reference: &quot;</span> + weakReference.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;phantom reference: &quot;</span> + phantomReference.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;----after gc----&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;strong reference: &quot;</span> + strongReferece);</span><br><span class="line">        System.out.println(<span class="string">&quot;soft reference: &quot;</span> + softReference.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;weak reference: &quot;</span> + weakReference.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;phantom reference: &quot;</span> + phantomReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出结果如下</p>
<p><img src="/images/jvm/referenceSampleOutput.png" alt="引用例子输出结果"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 周志明，深入理解Java虚拟机：JVM高级特性与最佳实践[M]，北京：机械工业出版社，2013</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>部分 java 虚拟机参数</title>
    <url>/jvm/jvm-parameter/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在部分程序中，需要进行性能调优，此时需要改变java虚拟机的各个内存区域的默认大小或改变垃圾回收器的策略，而这需要通过改变java虚拟机参数来完成。本文主要记录其中几个常用的参数。</p>
<span id="more"></span>

<h1 id="内存参数列表"><a href="#内存参数列表" class="headerlink" title="内存参数列表"></a>内存参数列表</h1><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>堆的最小值</td>
<td>-Xms20m表示堆的最小值为20m</td>
</tr>
<tr>
<td>-Xmx</td>
<td>堆的最大值</td>
<td>-Xmx20m表示堆的最大值为20m</td>
</tr>
<tr>
<td>-Xss</td>
<td>栈的容量大小</td>
<td>Xss128k：栈的大小为128k</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>方法区内存初始化值</td>
<td>-XX:PermSize&#x3D;10M表示方法区初始化内存大小为10M</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>方法区内存最大值</td>
<td>-XX:MaxPermSize&#x3D;10M表示方法区内存最大值为10M</td>
</tr>
<tr>
<td>-XX:MaxDirectMemorySize</td>
<td>直接内存大小，不指定时，默认与java堆最大值(-Xmx值)一样</td>
<td>-XX:MaxDirectMemorySize&#x3D;10M表示直接内存大小为10M</td>
</tr>
</tbody></table>
<h1 id="垃圾收集器参数列表"><a href="#垃圾收集器参数列表" class="headerlink" title="垃圾收集器参数列表"></a>垃圾收集器参数列表</h1><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Xmn</td>
<td>新生代大小。如：-Xmn10m表示新生代大小为10m</td>
</tr>
<tr>
<td>UseSerialGC</td>
<td>虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial + Serial Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseParNewGC</td>
<td>打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseConcMarkSweepGC</td>
<td>打开此开关后，使用ParNew + CMS + Serial Old的收集器组合进行内容回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后背收集器使用</td>
</tr>
<tr>
<td>UseParallelGC</td>
<td>虚拟机运行在Server模式下的默认值，打开此开关后，使用ParallelScavenge + Serial Old(PS MarkSweep)的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseParallelOldGC</td>
<td>打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>SurvivorRatio</td>
<td>新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Survivor&#x3D;8:1</td>
</tr>
<tr>
<td>PretenureSizeThreshold</td>
<td>直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</td>
</tr>
<tr>
<td>MaxTenuringThreshold</td>
<td>晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代</td>
</tr>
<tr>
<td>UseAdaptiveSizePolicy</td>
<td>动态调整java堆中各个区域的大小以及进入老年代的年龄</td>
</tr>
<tr>
<td>HandlePromotionFailure</td>
<td>是否运行分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况</td>
</tr>
<tr>
<td>ParallelGCThreads</td>
<td>设置并行GC时进行内存回收的线程数</td>
</tr>
<tr>
<td>GCTimeRatio</td>
<td>GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效</td>
</tr>
<tr>
<td>MaxGCPauseMillis</td>
<td>设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效</td>
</tr>
<tr>
<td>CMSInitiatingOccupancyFraction</td>
<td>设置CMS收集器在老年代空间被使用多少后出发垃圾收集。默认值为68%。仅在使用CMS收集器时生效</td>
</tr>
<tr>
<td>UseCMSCompactAtFullCollection</td>
<td>设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在CMS收集器时生效</td>
</tr>
<tr>
<td>CMSFullGCsBeforeCompaction</td>
<td>设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效</td>
</tr>
</tbody></table>
<h1 id="辅助参数列表"><a href="#辅助参数列表" class="headerlink" title="辅助参数列表"></a>辅助参数列表</h1><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+HeapDumpOnOutOfMemoryError</td>
<td>在虚拟机出现内存溢出异常时Dump出当前的内存堆栈存储快照</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>在发生垃圾收集行为时打印内存日志，并且在进程退出的时候输出当前的内存各区域分配情况</td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 周志明，深入理解Java虚拟机：JVM高级特性与最佳实践[M]，北京：机械工业出版社，2013</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-100:Same Tree</title>
    <url>/leetCode/leetCode-100/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两颗树，要求判断两颗树是否相同。如果两颗树的结构以及每个节点的数值相同，则认为两颗树是相同的，否则不相同。题目链接：**<a href="https://leetcode.com/problems/same-tree/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<p>1</p>
<p>&#x2F;\</p>
<p>2 3</p>
<p>1</p>
<p>&#x2F;\</p>
<p>2 3</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：</p>
<p>1</p>
<p>&#x2F;\</p>
<p>2 3</p>
<p>1</p>
<p>&#x2F;\</p>
<p>3 2</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用先序遍历的做法，分别判断每个节点的值是否相同，如果不同，则返回 false，如果都相同，则返回 true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span> || p.val != q.val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-101:Symmetric Tree</title>
    <url>/leetCode/leetCode-101/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一颗二叉树，要求判断二叉树是否是对称的（以根节点的垂直线进行划分）。题目链接：**<a href="https://leetcode.com/problems/symmetric-tree/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,2]</p>
<p>输出：true</p>
<p>解释：树结构如下</p>
<p>  1</p>
<p>&#x2F;  \</p>
<p>2  2</p>
</blockquote>
<blockquote>
<p>输入：[1,2,3]</p>
<p>输出：false</p>
<p>解释：树结构如下</p>
<p>  1</p>
<p>&#x2F;  \</p>
<p>2  3</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>从根节点拆分成两颗树，对于两颗树而言，要对称，则第一颗树的左节点需要对应第二颗树的右节点，第一颗树的右节点需要对应第二颗树的左节点。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode left, TreeNode right)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> || right == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-102:Binary Tree Level Order Traversal</title>
    <url>/leetCode/leetCode-102/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉树，要求按层级遍历输出结果。题目链接：**<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]</p>
<p>表示二叉树</p>
<p>  3</p>
<p>  &#x2F;\</p>
<p>9  20</p>
<p>​    &#x2F;\</p>
<p>  15  7</p>
<p>输出：[[3],[9,20],[15,7]]</p>
</blockquote>
<blockquote>
<p>输入：root &#x3D; [1]</p>
<p>输出：[[1]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用 BFS 遍历输出，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            result.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-103:Binary Tree Zigzag Level Order Traversal</title>
    <url>/leetCode/leetCode-103/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉树，要求按照 <code>Z</code> 字形层级遍历输出。题目链接：**<a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：root&#x3D;[1,2,3]</p>
<p>输出：[[1],[3,2]]</p>
<p>解释：树形状如下</p>
<p>  1</p>
<p> &#x2F; \</p>
<p>2  3</p>
</blockquote>
<blockquote>
<p>输入：root&#x3D;[1]</p>
<p>输出：[[1]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用 BFS 算法进行求解，只不过比寻常的 BFS 算法多了个判断，在输出时多判断一下是放到列表最前面还是最后面。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLeftToRight</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Integer&gt; line = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (isLeftToRight)</span><br><span class="line">                &#123;</span><br><span class="line">                    line.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    line.add(<span class="number">0</span>, node.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            result.add(line);</span><br><span class="line">            </span><br><span class="line">            isLeftToRight = !isLeftToRight;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-104:Maximum Depth of Binary Tree</title>
    <url>/leetCode/leetCode-104/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉树，要求算出二叉树的高度。题目链接：**<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1, 2, null, 3]</p>
<p>输出：3</p>
<p>解释：二叉树如下</p>
<p>  1</p>
<p> &#x2F; </p>
<p>2</p>
<p>&#x2F;</p>
<p>3</p>
</blockquote>
<blockquote>
<p>输入：[1]</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>递归计算子树的高度，取其最大值加一，即是二叉树的高度。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-106:Construct Binary Tree from Inorder and Postorder Traversal</title>
    <url>/leetCode/leetCode-106/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉树的中序遍历数组和后序遍历数组，要求构造这颗树并返回根节点。题目链接：**<a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]</p>
<p>输出：[3,9,20,null,null,15,7]</p>
<p>解释：树的形状如下</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="tree"></p>
</blockquote>
<blockquote>
<p>输入：inorder &#x3D; [-1], postorder &#x3D; [-1]</p>
<p>输出：[-1]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题没有什么特殊的算法，就是按照中序遍历和后序遍历对数组进行拆分，依次构造子树，最后连接成最终结果。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd, <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inStart &gt; inEnd || postStart &gt; postEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> postorder[postEnd];</span><br><span class="line">        <span class="keyword">if</span> (postStart == postEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootValue) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> i - inStart;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> buildTree(inorder, inStart, i - <span class="number">1</span>, postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> buildTree(inorder, i + <span class="number">1</span>, inEnd, postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-107:Binary Tree Level Order Traversal II</title>
    <url>/leetCode/leetCode-107/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉树，要求从下到上，从左到右进行遍历输出。题目链接：**<a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3,4,5]</p>
<p>输出：[[4,5],[2,3],[1]]</p>
<p>解释：树的结构如下</p>
<p>  1</p>
<p> &#x2F; \</p>
<p>2   3</p>
<p>&#x2F;\</p>
<p>4 5</p>
</blockquote>
<blockquote>
<p>输入：[1]</p>
<p>输出：[[1]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用广度优先搜索算法进行遍历，在遍历每一层后，把数据直接放到链表头部。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.add(<span class="number">0</span>, level);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-108:Convert Sorted Array to Binary Search Tree</title>
    <url>/leetCode/leetCode-108/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个升序的整数数组，要求将其转换成高度平衡的搜索二叉树。题目链接：**<a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[-10,-3,0,5,9]</p>
<p>输出：[0,-3,9,-10,null,5]，或，[0,-10,5,null,-3,null,9]</p>
<p>解释：树形状如下</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="第一张图"></p>
<p>或：</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg" alt="第二张图"></p>
</blockquote>
<blockquote>
<p>输入：[1]</p>
<p>输出：[1]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用递归，将数组对半分，中间节点为根节点，左边的数组构成左子树，右边的数组构成右子树。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> convert2BST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">convert2BST</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[start]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[middle]);</span><br><span class="line">        root.left = convert2BST(nums, start, middle - <span class="number">1</span>);</span><br><span class="line">        root.right = convert2BST(nums, middle + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-109:Convert Sorted List to Binary Search Tree</title>
    <url>/leetCode/leetCode-109/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个升序的链表，要求将其转换成高度平衡的搜索二叉树。题目链接：**<a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：1-&gt;2-&gt;3</p>
<p>输出：</p>
<p>  2</p>
<p>&#x2F; \</p>
<p>1 3</p>
</blockquote>
<blockquote>
<p>输入：1</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题跟 <a href="https://guozhchun.github.io/leetCode/leetCode-108/">LeetCode-108</a>类似，只不过前面是数组，这次是链表。解法类似，先找到中间的节点，然后拆分左子树和右子树，依次进行递归构造。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedListToBST</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> convert2BST(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">convert2BST</span><span class="params">(ListNode left, ListNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">while</span> (fast != right &amp;&amp; fast.next != right) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(slow.val);</span><br><span class="line">        root.left = convert2BST(left, slow);</span><br><span class="line">        root.right = convert2BST(slow.next, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-11:Container With Most Water</title>
    <url>/leetCode/leetCode-11/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个非负整数的数组，数组中每个元素的位置代表其在双平面坐标系下横坐标的值，元素的值代表其在双平面坐标系下纵坐标的值。这些元素在坐标系中组成了不同的柱子，要求找出由其中两个柱子所组成的长方形（长方形的宽度是两根柱子的距离，长度是两个柱子中最短柱子的值）的面积最大。题目链接：**<a href="https://leetcode.com/problems/container-with-most-water/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,8,6,2,5,4,8,3,7]</p>
<p>输出：49</p>
<p>解释：由 8 和 7 这两根柱子组成的范围，宽度是 7 （数组最后一个元素 7 和第二个元素 8 之间的距离），长度是 7 （7 和 8 中最小的数字），所以面积是 7 * 7 &#x3D; 49</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="示例图"></p>
<p>说明：此图来自于 leetCode 官网</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h2><p>既然是求任意两个柱子围成的面积的最大值，那么就可以将任意两个柱子围成的面积的所有值都求出，然后取其最大值。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">minNum</span> <span class="operator">=</span> Math.min(height[i], height[j]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> j - i;</span><br><span class="line">                <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> minNum * width;</span><br><span class="line">                <span class="keyword">if</span> (result &lt; area)</span><br><span class="line">                &#123;</span><br><span class="line">                    result = area;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="暴力遍历改进版"><a href="#暴力遍历改进版" class="headerlink" title="暴力遍历改进版"></a>暴力遍历改进版</h2><p>直接暴力破解，耗时较长，有 200ms，所以需要进行改进。仔细观察柱子的分布情况，如果当前两个柱子构成了一个长方形，在将左侧柱子向右移动时，如果下一个柱子的高度比当前柱子的高度低，那么其构成的长方形的面积肯定不会比之前计算的要大。基于此，可以在每次移动左侧柱子的同时记录并比较柱子的高度，避免一些不必要的计算。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentMaxHeight</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentMaxHeight &gt;= height[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            currentMaxHeight = height[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">minNum</span> <span class="operator">=</span> Math.min(height[i], height[j]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> j - i;</span><br><span class="line">                <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> minNum * width;</span><br><span class="line">                <span class="keyword">if</span> (result &lt; area)</span><br><span class="line">                &#123;</span><br><span class="line">                    result = area;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双头指针解法"><a href="#双头指针解法" class="headerlink" title="双头指针解法"></a>双头指针解法</h2><p>虽然第二版的暴力破解相比第一版进行了改进，使时间从 200ms 降到了 100 ms，但是仍然是比较耗时的，毕竟两者的时间复杂度都是 <code>O(n*n)</code>。因此可以使用双头指针的做法将时间复杂度降到 <code>O(n)</code>。具体做法是：定义一个指针指向数组头部，定义另一个指针指向数组尾部，然后计算这两根柱子构成的区域面积，每次移动指针时，将两个柱子中最短的那根柱子向中间进行移动（移动柱子时，长方形宽度变小，因此只能使其长度变大才有可能使面积变大，而只能使短柱子移动才有可能使其长度变大）。此方法参考<a href="https://leetcode.com/articles/container-with-most-water/">https://leetcode.com/articles/container-with-most-water/</a></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> Math.min(height[left], height[right]) * (right - left);</span><br><span class="line">            <span class="keyword">if</span> (area &gt; result)</span><br><span class="line">            &#123;</span><br><span class="line">                result = area;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right])</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h1><ol>
<li><a href="https://leetcode.com/articles/container-with-most-water/">https://leetcode.com/articles/container-with-most-water/</a></li>
</ol>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-112:Path Sum</title>
    <url>/leetCode/leetCode-112/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出一颗树和一个数字 sum ，要求寻找是否存在从树的根节点到叶子节点的路径，使得这个路径上的节点数字之和为 sum。如果存在则返回 true，否则返回 false。题目链接：**<a href="https://leetcode.com/problems/path-sum/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[5,4,8,11,null,13,4,7,2,null,null,null,1]<br>           22</p>
<p>输出：true</p>
<p>解析：输入的树如下，存在路径：5-&gt;4-&gt;11-&gt;2，和为 22，所以返回 true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>问题题意描述得很清楚，解法也简单清晰，直接使用深搜遍历即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; root.val == sum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-110:Balanced Binary Tree</title>
    <url>/leetCode/leetCode-110/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉树，要求判断这颗树是否是平衡二叉树。题目链接：**<a href="https://leetcode.com/problems/balanced-binary-tree/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1]</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：[1, 2]</p>
<p>输出：</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>平衡二叉树的定义，要求左右子树的高度差不能超过1，且左右子树都是平衡二叉树。根据平衡二叉树的定义进行递归求解，由于要算出子树的高度和判断子树是否是平衡树，为了不重复计算，在计算高度的同时判断子树是否是平衡二叉树，如果不是，则返回-1，如果是，则返回树的高度，方便上层节点的计算。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> calcHeight(root);</span><br><span class="line">        <span class="keyword">return</span> height &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcHeight</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> calcHeight(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> calcHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span> || right == -<span class="number">1</span> || Math.abs(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-111:Minimum Depth of Binary Tree</title>
    <url>/leetCode/leetCode-111/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉树，要求找出二叉树的最小高度。题目链接：**<a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3,4,5]</p>
<p>输出：2</p>
<p>解释：树形状如下</p>
<p>  1</p>
<p> &#x2F; \</p>
<p>2  3</p>
<p>&#x2F;\</p>
<p>4 5</p>
</blockquote>
<blockquote>
<p>输入：[]</p>
<p>输出：0</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用递归，算出左子树的最小高度和右子树的最小高度，取其最小值，加一就是本题的答案。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-113:Path Sum II</title>
    <url>/leetCode/leetCode-113/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出一颗树和一个数字 sum ，要求寻找所有从树的根节点到叶子节点的路径，使得这个路径上的节点数字之和为 sum。题目链接：**<a href="https://leetcode.com/problems/path-sum-ii/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[5,4,8,11,null,13,4,7,2,null,null,5,1]<br>           22</p>
<p>输出：[[5, 4, 11, 2],   [5, 8, 4, 5]]</p>
<p>解析：输入的树如下，存在两条路径：5 -&gt; 4 -&gt; 11 -&gt; 2，5 -&gt; 8 -&gt; 4 -&gt; 5，使得路径上数字之和为 22</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     5</span><br><span class="line">    / \</span><br><span class="line">   4   8</span><br><span class="line">  /   / \</span><br><span class="line"> 11  13  4</span><br><span class="line">/  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，直接使用回溯算法进行求解即可。 代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; root.val == sum)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Integer&gt; pathToSave = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path);</span><br><span class="line">            pathToSave.add(root.val);</span><br><span class="line">            result.add(pathToSave);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        path.add(root.val);</span><br><span class="line">        </span><br><span class="line">        findPathSum(root.left, sum - root.val, path, result);   <span class="comment">// 寻找左子树的路径</span></span><br><span class="line">        findPathSum(root.right, sum - root.val, path, result);  <span class="comment">// 寻找右子树的路径</span></span><br><span class="line">        </span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);  <span class="comment">// 移除刚增加的元素，回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        findPathSum(root, sum, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-115:Distinct Subsequences</title>
    <url>/leetCode/leetCode-115/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个字符串 <code>S</code> 和 <code>T</code>，要求找出 <code>S</code> 中的子字符串（保留<code>S</code> 字符串的顺序并在 <code>S</code> 字符串中去掉 0 个或多个字符剩下字符串）中与 <code>T</code> 字符串相等的个数。题目链接：**<a href="https://leetcode.com/problems/distinct-subsequences/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：S &#x3D; “rabbbit”, T &#x3D; “rabbit”</p>
<p>输出：3</p>
</blockquote>
<blockquote>
<p>输入：S &#x3D; “babgbag”, T &#x3D; “bag”</p>
<p>输出：5</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>采用动态规划的方式，用 <code>dp[i][j]</code> 表示 <code>S</code> 串前 <code>i</code> 个字符构成的字符串，其经过变换得到的子字符串等于 <code>T</code> 串前 <code>j</code> 个字符构成的子字符串的个数。动态转移方程为：如果 <code>S[i]</code> 和 <code>T[j]</code> 相等，那 <code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code>，如果 <code>S[i]</code> 和 <code>T[j]</code> 不相等，那 <code>dp[i][j] = dp[i - 1][j]</code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || t == <span class="literal">null</span> || s.length() == <span class="number">0</span> || t.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">sLength</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">tLength</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[sLength][tLength];</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) == t.charAt(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sLength; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == t.charAt(<span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sLength; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; tLength; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == t.charAt(j))</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[sLength - <span class="number">1</span>][tLength - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-114:Flatten Binary Tree to Linked List</title>
    <url>/leetCode/leetCode-114/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉树，要求将二叉树的节点按照先序遍历的方式将其转成链表，链表节点均在树的右节点。题目链接：**<a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,5,3,4,null,6]</p>
<p>这是一个三层的二叉树，从上到下，从左到右的节点是：1，2，5，3，4，null，6。其中 1 的左孩子是 2，右孩子是 5，依次类推。其中 null 表示没有该节点，即 5 没有左孩子</p>
<p>输出：[1,null,2,null,3,null,4,null,5,null,6] </p>
<p>这是一个用树的方式来表示的链表，数节点上左孩子都是 null</p>
</blockquote>
<blockquote>
<p>输入：[1]</p>
<p>输出：[1]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>递归遍历树，先处理左节点，再处理右节点，在将左右孩子树转成链表时，分别记录链表的尾节点，用于在父节点将右孩子连接到左孩子上，否则还需要再次遍历左孩子的链表，造成时间的浪费。需要特别注意的是，在处理过程中，需要将树节点的左孩子置为 null，否则与输出不匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        flattenTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">flattenTree</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftEnd</span> <span class="operator">=</span> flattenTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightEnd</span> <span class="operator">=</span> flattenTree(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (leftEnd != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            leftEnd.right = root.right;</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = <span class="literal">null</span>;   <span class="comment">// 必须置空，否则输出不匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rightEnd != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> rightEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (leftEnd != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> leftEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-116:Populating Next Right Pointers in Each Node</title>
    <url>/leetCode/leetCode-116/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个完全二叉树，要求填充每个节点的下一个节点（指向节点右边的兄弟节点，没有右边的节点则填充为空）。题目链接：**<a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3,4,5,6,7]           </p>
<p>代表这是一个三层的二叉树，从上到下，从左到右的节点是：1，2，3，4，5，6，7。其中 1 的左孩子是 2，右孩子是 3，依次类推</p>
<p>输出：[1,#,2,3,#,4,5,6,7,#]</p>
<p>这是补充上节点右边节点后，按照从上到下，从左到右的节点的遍历的输出结果，其中 # 代表空</p>
</blockquote>
<blockquote>
<p>输入：[1]</p>
<p>输出：[1]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>按照先序遍历树的方式遍历每个节点，在每个节点上，将左孩子的 <code>next</code> 指针指向右孩子，将右孩子的 <code>next</code> 指针指向当前节点的 <code>next</code> 节点的左孩子（如果存在的话，不存在就是 <code>null</code>）。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root.left.next = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.next != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root.right.next = root.next.left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        connect(root.left);</span><br><span class="line">        connect(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-117:Populating Next Right Pointers in Each Node II</title>
    <url>/leetCode/leetCode-117/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉树，要求填充每个节点的下一个节点（指向节点右边的兄弟节点，没有右边的节点则填充为空）。在不算递归栈的情况下，要求空间复杂度是常量。题目链接：**<a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3,4,5,null,7]</p>
<p>这是一个三层的二叉树，从上到下，从左到右的节点是：1，2，3，4，5，null，7。其中 1 的左孩子是 2，右孩子是 3，依次类推。其中 null 表示没有该节点，即 3 没有左孩子</p>
<p>输出：[1,#,2,3,#,4,5,7,#]</p>
<p>这是补充上节点右边节点后，按照从上到下，从左到右的节点的遍历的输出结果，其中 # 代表空</p>
</blockquote>
<blockquote>
<p>输入：[1]</p>
<p>输出：[1]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题跟 <a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node">leetCode-116</a> 类似，唯一的不同是，116 是一颗完全二叉树，而本次仅仅是一个二叉树，中间部分节点可能没有孩子。鉴于此，仍然可以用递归来解答，只不过需要改变一下递归的顺序，不能是 本节点 -&gt; 左孩子 -&gt; 右孩子 的顺序了，因为这样的顺序并不能保证在下一层中节点存在空缺时 next 指针的正确连接（因为本层的 next 指针没有完全连接好，所以不能顺着本层找到下层的节点）。需要改成 本节点 -&gt; next 节点 -&gt; 本节点的左孩子（没有左孩子就用右孩子），这样就能保证对当前节点的孩子进行 next 指针匹配时，当前节点右边的节点的 next 指针都已经匹配完成，从而能够为孩子节点的 next 指针匹配找到正确的节点。另外，需要注意的是，按照递归顺序，在 next 递归中，会存在对节点重复遍历的情况，此时进行剪枝判断，如果 next 的节点的孩子节点的 next 指针已经做了匹配，则不用再次进行遍历。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// root.left != null &amp;&amp; root.left.next != null 是剪枝判断，避免重复遍历</span></span><br><span class="line">        <span class="comment">// root.right != null &amp;&amp; root.right.next != null 是剪枝判断，避免重复遍历</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || (root.left != <span class="literal">null</span> &amp;&amp; root.left.next != <span class="literal">null</span>) || (root.right != <span class="literal">null</span> &amp;&amp; root.right.next != <span class="literal">null</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Node from;    <span class="comment">// 当前节点的某个孩子节点，需要指向 父节点的兄弟节点的孩子</span></span><br><span class="line">        Node first;   <span class="comment">// 当前节点的某个孩子节点，下一层遍历开始的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            first = root.left;</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                root.left.next = root.right;</span><br><span class="line">                from = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                from = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            first = root.right;</span><br><span class="line">            from = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (from != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">to</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> root.next;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    to = temp.left;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    to = temp.right;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            from.next = to;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        connect(root.next);</span><br><span class="line">        connect(first);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-118:Pascal&#39;s Triangle</title>
    <url>/leetCode/leetCode-118/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个正整数 <code>n</code>，要求输出杨辉三角的前 <code>n</code> 行。题目链接：**<a href="https://leetcode.com/problems/pascals-triangle/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：5</p>
<p>输出：[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</p>
<p>解释：杨辉三角如下</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="杨辉三角"></p>
</blockquote>
<blockquote>
<p>输入：1</p>
<p>输出：[[1]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，直接按照杨辉三角的规则进行输出即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            items.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i) &#123;</span><br><span class="line">                    items.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    List&lt;Integer&gt; prev = result.get(i - <span class="number">1</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> prev.get(j - <span class="number">1</span>) + prev.get(j);</span><br><span class="line">                    items.add(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(items);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-119:Pascal&#39;s Triangle II</title>
    <url>/leetCode/leetCode-119/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个正整数 <code>n</code>，要求找出杨辉三角中第 <code>n</code> 行的数字列表。题目链接：<a href="https://leetcode.com/problems/pascals-triangle-ii/"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：3</p>
<p>输出：[1,3,3,1]</p>
</blockquote>
<blockquote>
<p>输入：0</p>
<p>输出：[1]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>观察杨辉三角每一行的数字，可以发现其数字呈现以下规律：<code>1</code>、<code>n</code>、<code>n(n-1)/2</code>、<code>n(n-1)(n-2)/(2*3)</code>、<code>n(n-1)(n-2)(n-3)/(2*3*4)</code></p>
<p>、…、<code>1</code>，所以可以根据此直接算出每一行中的每个数字。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(rowIndex + <span class="number">1</span>);</span><br><span class="line">        result.add(<span class="number">1</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowIndex; i++) &#123;</span><br><span class="line">            prev = prev * (rowIndex - i) / (i + <span class="number">1</span>);</span><br><span class="line">            result.add((<span class="type">int</span>) prev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-12:Integer to Roman</title>
    <url>/leetCode/leetCode-12/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数（阿拉伯数字），要求将其转换罗马数字（字符串）。一般情况下，罗马数字是从左到右是按照从大到小的顺序进行分布的，除了少数几种特殊情况（IV、IX、XL、XC、CD、CM），这些数字的对应规则如下表所示，题目链接：**<a href="https://leetcode.com/problems/integer-to-roman/">点我</a>**</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>罗马数字</th>
<th>阿拉伯数字</th>
</tr>
</thead>
<tbody><tr>
<td>I</td>
<td>1</td>
</tr>
<tr>
<td>V</td>
<td>5</td>
</tr>
<tr>
<td>X</td>
<td>10</td>
</tr>
<tr>
<td>L</td>
<td>50</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
</tr>
<tr>
<td>D</td>
<td>500</td>
</tr>
<tr>
<td>M</td>
<td>1000</td>
</tr>
<tr>
<td>IV</td>
<td>4</td>
</tr>
<tr>
<td>IX</td>
<td>9</td>
</tr>
<tr>
<td>XL</td>
<td>40</td>
</tr>
<tr>
<td>XC</td>
<td>90</td>
</tr>
<tr>
<td>CD</td>
<td>400</td>
</tr>
<tr>
<td>CM</td>
<td>900</td>
</tr>
</tbody></table>
<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：9</p>
<p>输出：IX</p>
</blockquote>
<blockquote>
<p>输入：27</p>
<p>输出：XXVII</p>
<p>解释：X &#x3D; 10, V &#x3D; 5, I &#x3D; 1 。XXVII &#x3D; 10 + 10 + 5 + 1 + 1 &#x3D; 27</p>
</blockquote>
<blockquote>
<p>输入：1994</p>
<p>输出：MCMXCIV</p>
<p>解释： M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4。MCMXCIV &#x3D; 1000 + 900 + 90 + 4 &#x3D; 1994</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>从题目中分析可以得知，对于一个阿拉伯数字，罗马数字会先选择最大的数字字符（<code>M</code>）进行表示，不匹配后再选择第二大的数字字符进行匹配，依次类推，直到最后选择 <code>I</code> 为止。因此，题目的解法就按照这种规则进行模拟拼接每个匹配的字符串。</p>
<h2 id="if-分支判断法"><a href="#if-分支判断法" class="headerlink" title="if 分支判断法"></a>if 分支判断法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1000</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mCount</span> <span class="operator">=</span> num / <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;M&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        num = num % <span class="number">1000</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 900</span></span><br><span class="line">        <span class="keyword">if</span> (num + <span class="number">100</span> &gt;= <span class="number">1000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;CM&quot;</span>);</span><br><span class="line">            num = num % <span class="number">900</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 500</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">500</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">            num = num % <span class="number">500</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 400</span></span><br><span class="line">        <span class="keyword">if</span> (num + <span class="number">100</span> &gt;= <span class="number">500</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;CD&quot;</span>);</span><br><span class="line">            num = num % <span class="number">400</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 100</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cCount</span> <span class="operator">=</span> num / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        num = num % <span class="number">100</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 90</span></span><br><span class="line">        <span class="keyword">if</span> (num + <span class="number">10</span> &gt;= <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">            num = num % <span class="number">90</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 50</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">50</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;L&quot;</span>);</span><br><span class="line">            num = num % <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 40</span></span><br><span class="line">        <span class="keyword">if</span> (num + <span class="number">10</span> &gt;= <span class="number">50</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line">            num = num % <span class="number">40</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">xCount</span> <span class="operator">=</span> num / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; xCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        num = num % <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 9</span></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;IX&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;V&quot;</span>);</span><br><span class="line">            num = num % <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;IV&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;I&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组优化法"><a href="#数组优化法" class="headerlink" title="数组优化法"></a>数组优化法</h2><p>上述解决虽然可以解决问题，但是有太多 if 分支，代码不够简洁，可以用数组进行优化，此方法参考：<a href="https://leetcode.com/problems/integer-to-roman/discuss/6310/My-java-solution-easy-to-understand">https://leetcode.com/problems/integer-to-roman/discuss/6310/My-java-solution-easy-to-understand</a>，优化后的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] numValues = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        String[] symbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numValues.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= numValues[i])</span><br><span class="line">            &#123;</span><br><span class="line">                sb.append(symbols[i]);</span><br><span class="line">                num -= numValues[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://leetcode.com/problems/integer-to-roman/discuss/6310/My-java-solution-easy-to-understand">https://leetcode.com/problems/integer-to-roman/discuss/6310/My-java-solution-easy-to-understand</a></li>
</ol>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-120:Triangle</title>
    <url>/leetCode/leetCode-120/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二维列表，表示一个正三角形，要求找出从三角形的顶点到底部经过的路径的最小值。每次移动只能本数字的左下相邻或者右下相邻的数字移动。题目链接：**<a href="https://leetcode.com/problems/triangle/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[2],[3,4],[6,5,7],[4,1,8,3]]， 表示的三角形如下：<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2<br>&amp;nbsp;&amp;nbsp;3,4<br>&amp;nbsp;6,5,7<br>4,1,8,3<br>输出：11。其经过的路径为：2-&gt;3-&gt;5-&gt;1</p>
</blockquote>
<blockquote>
<p>输入：[[2],[3,4],[6,5,7],[4,10,8,3]]， 表示的三角形如下：<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2<br>&amp;nbsp;&amp;nbsp;3,&amp;nbsp;4<br>&amp;nbsp;6,&amp;nbsp;5,&amp;nbsp;7<br>4,10,8,3</p>
<p>输出：15。其经过的路径为：2-&gt;3-&gt;6-&gt;4</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="二维数组动态规划"><a href="#二维数组动态规划" class="headerlink" title="二维数组动态规划"></a>二维数组动态规划</h2><p>根据题目要求，可以得知，假设 <code>sum[i][j]</code> 表示三角形从顶点开始到达第 <code>i</code> 行第 <code>j</code> 列位置的路径和，则 <code>sum[i][j] = sum[i - 1][j - 1] + a[i][j]</code>  或者 <code>sum[i][j] = sum[i - 1][j] + a[i][j]</code>。因此，只要比较这两个值，就能得到从三角形顶点到达此位置的路径的和的最小值。按照此算法，依次算出当前行每个位置的最小值，然后将这些值进行比较，取出最小值就是三角形顶点到达底部的路径最小和。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (triangle == <span class="literal">null</span> || triangle.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> triangle.size();</span><br><span class="line">        <span class="type">int</span>[][] sum = <span class="keyword">new</span> <span class="title class_">int</span>[size][size];</span><br><span class="line">        sum[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i][<span class="number">0</span>] = sum[i - <span class="number">1</span>][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">            sum[i][i] = sum[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum[i][j] = Math.min(sum[i - <span class="number">1</span>][j - <span class="number">1</span>], sum[i - <span class="number">1</span>][j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> sum[size - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; size; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            result = Math.min(sum[size - <span class="number">1</span>][j], result);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一维数组动态规划"><a href="#一维数组动态规划" class="headerlink" title="一维数组动态规划"></a>一维数组动态规划</h2><p>上面的解法虽然直观，理解起来也比较容易，但是其空间复杂度是 <code>O(n * n)</code>，可以再进一步提升优化成 <code>O(n)</code>，n 是三角形的行数。仔细观察上述的解法，每次计算 <code>sum[i][j]</code> 时，都是用的 <code>sum[i - 1][j - 1]</code> 和 <code>sum[i - 1][j]</code>，也就是说，计算本行的结果只依赖上一行本位置和上一行本位置前一个位置这两个位置的结果，再从题目中可以看出，每一行都比上一行多了一个值。所以，可以考虑，在计算本行结果时，从后面开始往前计算，并且计算结果直接放在本数组中（替换原先的值），这样，既不会因为修改数组的值导致后续的计算读到覆盖后的值，也可以复用数组减少空间的消耗。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (triangle == <span class="literal">null</span> || triangle.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> triangle.size();</span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        sum[<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                sum[j] = Math.min(sum[j], sum[j - <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">            sum[<span class="number">0</span>] = sum[<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> sum[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result = Math.min(result, sum[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-124:Binary Tree Maximum Path Sum</title>
    <url>/leetCode/leetCode-124/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉树，定义路径路为从某个节点开始到另一个节点经过路径上的节点数值之和。要求找出二叉树中路径和的最大值。题目链接：**<a href="https://leetcode.com/problems/binary-tree-maximum-path-sum">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3]</p>
<p>输入代表以下的二叉树</p>
<p> 1</p>
<p>&#x2F; \</p>
<p>2 3</p>
<p>输出：6</p>
<p>路径为：2 -&gt; 1 -&gt; 3</p>
</blockquote>
<blockquote>
<p>输入：[-1,2,3]</p>
<p>输入代表以下的二叉树</p>
<p> -1</p>
<p>&#x2F; \</p>
<p>2 3</p>
<p>输出：4</p>
<p>路径为：2 -&gt; -1 -&gt; 3</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>定义<code>pathSum</code> 为从当前节点出发的路径和的最大值，则对于任何节点作为根节点 <code>root</code> 构成的二叉树，其最大的路径和为 <code>pathSum(root.left)、pathSum(root.right)、pathSum(root.left) + root.val、pathSum(root.right) + root.val、pathSum(root.left) + pathSum(root.right) + root.val、root.val</code> 中的最大值。对于节点 <code>pathSum</code> 值的求解，可以采用二叉树先序遍历的方式，在遍历过程中，不断比较并更新当前的最大路径和的值，到最后遍历结束时，程序中存储的最大路径和变量值就是求解的答案。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        pathSum(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">leftPathSum</span> <span class="operator">=</span> pathSum(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightPathSum</span> <span class="operator">=</span> pathSum(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempSum</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">if</span> (leftPathSum &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tempSum += leftPathSum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rightPathSum &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tempSum += rightPathSum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        maxSum = Math.max(tempSum, maxSum);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(leftPathSum, rightPathSum) + root.val, root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-125:Valid Palindrome</title>
    <url>/leetCode/leetCode-125/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>定义回文串是去除字符串中非字母和数字的其他字符后，将大写字母转成小写字母后，从左到右显示和从右到左显示是相同的字符串。给定一个字符串，要求判断其是否是回文串。题目链接：<a href="https://leetcode.com/problems/valid-palindrome/description/"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：s &#x3D; “A man, a plan, a canal: Panama”</p>
<p>输出：true</p>
<p>解释：取出非字母和空格并将大写字母转成小写字母后，字符串是“amanaplanacanalpanama”</p>
</blockquote>
<blockquote>
<p>输入：s &#x3D; “race a car”</p>
<p>输出：false</p>
<p>解释：取出非字母和空格并将大写字母转成小写字母后，字符串是“raceacar”</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，使用双指针进行遍历判断，过滤掉非字母和数字的字符即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isValidChar(s.charAt(left))) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isValidChar(s.charAt(right))) &#123;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isEqual(s.charAt(left), s.charAt(right))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidChar</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) || (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEqual</span><span class="params">(<span class="type">char</span> first, <span class="type">char</span> second)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (first &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; first &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            first = (<span class="type">char</span>) (first - <span class="string">&#x27;A&#x27;</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (second &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; second &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            second = (<span class="type">char</span>) (second - <span class="string">&#x27;A&#x27;</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> first == second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-126:Word Ladder II</title>
    <url>/leetCode/leetCode-126/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个单词 <code>beginWord</code>、<code>endWord</code> 和一个单词列表 <code>wordList</code>，要求找出将单词 <code>beginWord</code> 变成单词 <code>endWord</code> 的最小的变化序列的列表。每次变化要求只能变化一个字母，而且变化后的单词必须在 <code>wordList</code> 中。题目链接：**<a href="https://leetcode.com/problems/word-ladder-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：beginWord &#x3D; “hit”,       endWord &#x3D; “cog”,      wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p>
<p>输出：[ [“hit”,”hot”,”dot”,”dog”,”cog”], [“hit”,”hot”,”lot”,”log”,”cog”] ]</p>
</blockquote>
<blockquote>
<p>输入：beginWord &#x3D; “hit”,       endWord &#x3D; “cog”,      wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p>
<p>输出：[]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解法一：BFS"><a href="#解法一：BFS" class="headerlink" title="解法一：BFS"></a>解法一：BFS</h2><p>此题跟 <a href="https://guozhchun.github.io/leetCode/leetCode-127">LeetCode127</a> 类似，只不过 LeetCode127 只需要找出最小序列的长度，而此题是要找出最小序列的所有集合。此题仍然可以用广搜的算法进行遍历，由于最终要输出的是最小序列的集合，因此在遍历过程中，存储在队列中的数据结构是序列（路径），而不是字符串（单词）。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">findLadders</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!wordList.contains(endWord))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key: word</span></span><br><span class="line">        <span class="comment">// value: the word list which can transfer from the word with change only one letter</span></span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; transferMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        wordList.add(<span class="number">0</span>, beginWord);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wordList.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">current</span> <span class="operator">=</span> wordList.get(i);</span><br><span class="line">            Set&lt;String&gt; currentWords = transferMap.getOrDefault(current, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">            transferMap.put(current, currentWords);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; wordList.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> wordList.get(j);</span><br><span class="line">                Set&lt;String&gt; nextWords = transferMap.getOrDefault(next, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">                transferMap.put(next, nextWords);</span><br><span class="line">                <span class="keyword">if</span> (isValid(current, next))</span><br><span class="line">                &#123;</span><br><span class="line">                    currentWords.add(next);</span><br><span class="line">                    nextWords.add(current);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        wordList.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; used = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;List&lt;String&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(Arrays.asList(beginWord));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; !isFind)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;String&gt; currentList = queue.poll();</span><br><span class="line">                <span class="type">String</span> <span class="variable">currentWord</span> <span class="operator">=</span> currentList.get(currentList.size() - <span class="number">1</span>);</span><br><span class="line">                used.add(currentWord);</span><br><span class="line">                <span class="keyword">if</span> (currentWord.equals(endWord))</span><br><span class="line">                &#123;</span><br><span class="line">                    result.add(currentList);</span><br><span class="line">                    isFind = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// can not traversal the wordList, or it will be time Time Limit Exceeded</span></span><br><span class="line">                <span class="keyword">for</span> (String word : transferMap.get(currentWord))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!used.contains(word))</span><br><span class="line">                    &#123;</span><br><span class="line">                        List&lt;String&gt; next = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(currentList);</span><br><span class="line">                        next.add(word);</span><br><span class="line">                        queue.offer(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String word, String other)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> word.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (word.charAt(i) != other.charAt(i))</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：BFS-DFS"><a href="#解法二：BFS-DFS" class="headerlink" title="解法二：BFS + DFS"></a>解法二：BFS + DFS</h2><p>此解法是先用 BFS 查找最短的序列长度，在查找过程中，将每次单词变化的列表存在一个 map 中。在找到最短序列长度结束 BFS 后，根据存储的 map 用 DFS 算法复原单词变化的路径。算法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">findLadders</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!wordList.contains(endWord))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; !isFind)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 同一层级的一起清除，避免同一层级的单词相互转换从而导致路径节点数增多</span></span><br><span class="line">            Set&lt;String&gt; currentSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                wordList.remove(current);</span><br><span class="line">                currentSet.add(current);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String current : currentSet)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (current.equals(endWord))</span><br><span class="line">                &#123;</span><br><span class="line">                    isFind = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (String word : wordList)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isValid(current, word))</span><br><span class="line">                    &#123;</span><br><span class="line">                        List&lt;String&gt; nextWordList = map.getOrDefault(current, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">                        nextWordList.add(word);</span><br><span class="line">                        map.put(current, nextWordList);</span><br><span class="line">                        queue.offer(word);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; chain = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        chain.add(beginWord);</span><br><span class="line">        solve(beginWord, endWord, map, chain, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String word, String other)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> word.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (word.charAt(i) != other.charAt(i))</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(String beginWord, String endWord, Map&lt;String, List&lt;String&gt;&gt; map, List&lt;String&gt; chain, List&lt;List&lt;String&gt;&gt; result)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (beginWord.equals(endWord))</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(chain));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; next = map.get(beginWord);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word : next)</span><br><span class="line">        &#123;</span><br><span class="line">            chain.add(word);</span><br><span class="line">            solve(word, endWord, map, chain, result);</span><br><span class="line">            chain.remove(chain.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-127:Word Ladder</title>
    <url>/leetCode/leetCode-127/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个单词 <code>beginWord</code>、<code>endWord</code> 和一个单词列表 <code>wordList</code>，要求找出将单词 <code>beginWord</code> 变成单词 <code>endWord</code> 的最小的变化序列的长度。每次变化要求只能变化一个字母，而且变化后的单词必须在 <code>wordList</code> 中。题目链接：**<a href="https://leetcode.com/problems/word-ladder/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出："><a href="#样例输入输出：" class="headerlink" title="样例输入输出："></a>样例输入输出：</h1><blockquote>
<p>输入：beginWord &#x3D; “hit”,       endWord &#x3D; “cog”,      wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p>
<p>输出：5</p>
<p>解释：变化的序列为：”hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”</p>
</blockquote>
<blockquote>
<p>输入：beginWord &#x3D; “hit”,       endWord &#x3D; “cog”,      wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p>
<p>输出：0</p>
<p>解释：cog 不在 wordList 中</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用广搜算法进行遍历搜索，在搜索过程中，为了避免重复搜索，可以用一个数组来标识已经搜索过的单词。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> wordList.size();</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[length];</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> queue.size(); k &gt; <span class="number">0</span>; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (current.equals(endWord))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!used[i] &amp;&amp; isValid(current, wordList.get(i)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        queue.offer(wordList.get(i));</span><br><span class="line">                        used[i] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String word, String other)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> word.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (word.charAt(i) != other.charAt(i))</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-128:Longest Consecutive Sequence</title>
    <url>/leetCode/leetCode-128/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，要求在 <code>O(n)</code> 的时间复杂度内找出数组中最长连续序列的元素个数。题目链接：**<a href="https://leetcode.com/problems/longest-consecutive-sequence/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[100, 4, 200, 1, 3, 2]</p>
<p>输出：4</p>
<p>说明：最长连续序列为 1 2 3 4，序列中元素个数为 4</p>
</blockquote>
<blockquote>
<p>输入：[1, 2, 3, 4, 6, 7, 8, 9, 10]</p>
<p>输出：5</p>
<p>说明：最长连续序列为 6 7 8 9 10，序列中元素个数为 5</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>遍历数组，将数组中每个元素放在 map 中，然后重新遍历数组中每个元素，以该元素为起点，每次加一，看新的数字是否在 map 中，如果在，则说明新的数字存在数组，同时也说明这个新的数字与当前元素是能构成连续序列的，如果不在，则说明新的数字不在数组中，结束循环。同样，以该元素为终点，每次减一，重复上述步骤，直到条件不满足为止。这样就能找出包含当前元素的最长序列的起始和终止的数字，进而获取到包含当前元素的最长序列的元素个数。在循环遍历数组时，每次比较最长序列的元素个数，取其最大值，当数组遍历完成时，变量保存的最大值就是求解的值。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;Integer, Boolean&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(nums.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(num, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!map.get(num))</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> num + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (!map.getOrDefault(next, <span class="literal">true</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    map.put(next, <span class="literal">true</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    next = next + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">front</span> <span class="operator">=</span> num - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (!map.getOrDefault(front, <span class="literal">true</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    map.put(front, <span class="literal">true</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    front = front - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (count &gt; maxCount)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxCount = count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-129:Sum Root to Leaf Numbers</title>
    <url>/leetCode/leetCode-129/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉树，用树的路径表示一个数字（从根节点到叶子节点经过的节点按先后顺序组成的数字），要求找出所有树路径代表的数字之和。题目链接：**<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1, 2, 3]</p>
<p>输出：25</p>
<p>说明：输入代表以下的树</p>
<p>1</p>
<p>&#x2F; \</p>
<p>2  3</p>
<p>树路径代表的数字为：12、13，和为 25</p>
</blockquote>
<blockquote>
<p>输入：[1, 2, 3, 4]</p>
<p>输出：137</p>
<p>说明：输入代表以下的树</p>
<p>   1</p>
<p>  &#x2F;    \</p>
<p>2       3</p>
<p>&#x2F;</p>
<p>4</p>
<p>树路径代表的数字为：124、13，和为137</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>采用先序遍历树的方式，遍历过程中记录从根节点到当前节点路径代表的数字，每次在到达叶子节点时，将这个数字加到全局变量中。待树遍历结束后，全局变量的值就是答案。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sumNumbers(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root, <span class="type">int</span> num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        num = num * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            total += num;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sumNumbers(root.left, num);</span><br><span class="line">        sumNumbers(root.right, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-13:Integer to Roman</title>
    <url>/leetCode/leetCode-13/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个罗马数字，要求将其转换成整数（阿拉伯数字）。这些数字的对应规则如下表所示，题目链接：**<a href="https://leetcode.com/problems/roman-to-integer/">点我</a>**</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>罗马数字</th>
<th>阿拉伯数字</th>
</tr>
</thead>
<tbody><tr>
<td>I</td>
<td>1</td>
</tr>
<tr>
<td>V</td>
<td>5</td>
</tr>
<tr>
<td>X</td>
<td>10</td>
</tr>
<tr>
<td>L</td>
<td>50</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
</tr>
<tr>
<td>D</td>
<td>500</td>
</tr>
<tr>
<td>M</td>
<td>1000</td>
</tr>
<tr>
<td>IV</td>
<td>4</td>
</tr>
<tr>
<td>IX</td>
<td>9</td>
</tr>
<tr>
<td>XL</td>
<td>40</td>
</tr>
<tr>
<td>XC</td>
<td>90</td>
</tr>
<tr>
<td>CD</td>
<td>400</td>
</tr>
<tr>
<td>CM</td>
<td>900</td>
</tr>
</tbody></table>
<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：IX</p>
<p>输出：9</p>
</blockquote>
<blockquote>
<p>输入：XXVII</p>
<p>输出：27</p>
<p>解释：X &#x3D; 10, V &#x3D; 5, I &#x3D; 1 。XXVII &#x3D; 10 + 10 + 5 + 1 + 1 &#x3D; 27</p>
</blockquote>
<blockquote>
<p>输入：MCMXCIV</p>
<p>输出：1994</p>
<p>解释： M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4。MCMXCIV &#x3D; 1000 + 900 + 90 + 4 &#x3D; 1994</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>根据上述表格，从左到右依次遍历字符串，对字符进行匹配，遇到 <code>I、X、C</code> 这三个字符时，将其后面的字符也一起进行连接进行匹配。将每次匹配得到的数字进行相加即可得到最终结果。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">symbols</span> <span class="operator">=</span> s + <span class="string">&quot;$&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> symbols.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">current</span> <span class="operator">=</span> symbols.charAt(i);</span><br><span class="line">            <span class="type">char</span> <span class="variable">next</span> <span class="operator">=</span> symbols.charAt(i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (current == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans += <span class="number">900</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (next == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans += <span class="number">400</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                ans += <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (current == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += <span class="number">500</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (current == <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans += <span class="number">90</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (next == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans += <span class="number">40</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                ans += <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (current == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += <span class="number">50</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (current == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans += <span class="number">9</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (next == <span class="string">&#x27;V&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans += <span class="number">4</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (current == <span class="string">&#x27;V&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += <span class="number">5</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>此解法参考 <a href="https://leetcode.com/problems/roman-to-integer/discuss/252172/Java-Easy-to-understand-(35ms)">https://leetcode.com/problems/roman-to-integer/discuss/252172/Java-Easy-to-understand-(35ms)</a>。主要是利用了「单个罗马数字从右到左值依次递增，两个罗马数字右边数字值大于左边数字值，并且右边数字值减左边数字值的结果就是这两个罗马数字转换的结果」的特点进行求解。因此可以从右到左遍历字符串，对每个字符，将其对应的数字与上个字符对应的数字进行比较，如果当前数字大于或者等于右边的数字，说明这是一个罗马数字，直接将对应的数字加到结果中。如果当前数字小，说明这是由当前数字和右边的数字构成一个整体的罗马数字，由于上一个循环中已经将右边的数字加到结果中，因此，此时需要从结果中减去当前数字，才能保证由这两个罗马数字构成的整体的正确转换。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">postNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> map.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= postNum)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans -= num;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            postNum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://leetcode.com/problems/roman-to-integer/discuss/252172/Java-Easy-to-understand-(35ms)">https://leetcode.com/problems/roman-to-integer/discuss/252172/Java-Easy-to-understand-(35ms)</a></li>
</ol>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-130:Surrounded Regions</title>
    <url>/leetCode/leetCode-130/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二维数组，数组中的元素为 <code>X</code> 和 <code>O</code>，要求将数组被 <code>X</code> 包围的 <code>O</code> 转成 <code>X</code>，如果 <code>O</code> 的区域中有任何一个元素在边界上，则这个区域不进行转换。题目链接：**<a href="https://leetcode.com/problems/surrounded-regions">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入： [[“X”,”X”,”X”,”X”],[“X”,”O”,”O”,”X”],[“X”,”X”,”O”,”X”],[“X”,”O”,”X”,”X”]] </p>
<p>输出： [[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”O”,”X”,”X”]] </p>
</blockquote>
<blockquote>
<p>输入：[[“X”,”X”,”X”,”X”],[“X”,”O”,”O”,”X”],[“X”,”X”,”O”,”X”],[“X”,”O”,”O”,”X”]] </p>
<p>输出：[[“X”,”X”,”X”,”X”],[“X”,”O”,”O”,”X”],[“X”,”X”,”O”,”X”],[“X”,”O”,”O”,”X”]] </p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用深搜，对边界上的 <code>O</code> 区域先设置一个临时的值 <code>T</code>，然后再对二维数组中的 <code>O</code> 元素进行搜索遍历，将其变成 <code>X</code>，最后遍历二维数据，将 <code>T</code> 还原成 <code>O</code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        changeBoundaryValue(board);</span><br><span class="line">        changeCellValue(board);</span><br><span class="line">        recoverBoundaryValue(board);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recoverBoundaryValue</span><span class="params">(<span class="type">char</span>[][] board)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">changeCellValue</span><span class="params">(<span class="type">char</span>[][] board)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; rows - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; cols - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    change(board, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">changeBoundaryValue</span><span class="params">(<span class="type">char</span>[][] board)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                change(board, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (board[i][cols - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                change(board, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, i, cols - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                change(board, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="number">0</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (board[rows - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                change(board, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, rows - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">char</span> targetValue, <span class="type">char</span> toValue, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isInBoard(board, i, j) || board[i][j] != targetValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = toValue;</span><br><span class="line">        change(board, targetValue, toValue, i - <span class="number">1</span>, j);</span><br><span class="line">        change(board, targetValue, toValue, i + <span class="number">1</span>, j);</span><br><span class="line">        change(board, targetValue, toValue, i, j - <span class="number">1</span>);</span><br><span class="line">        change(board, targetValue, toValue, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isInBoard</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;=<span class="number">0</span> &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h2><p>上个版本中，在对边界的 <code>O</code> 区域设值 <code>T</code> 后，仔细观察二维数组中的值，可以发现剩下的 <code>O</code> 区域上的值必然会被变成  <code>X</code>，而 <code>T</code> 也必然会变成 <code>O</code>，所以，在对边界区域设值后，没有必要在搜索 <code>O</code> 的区域设值，只需要直接遍历二维数组，将每个 <code>O</code> 元素变成 <code>X</code>，将每个 <code>T</code> 元素变成 <code>O</code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        changeBoundaryValue(board);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">changeBoundaryValue</span><span class="params">(<span class="type">char</span>[][] board)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                change(board, i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (board[i][cols - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                change(board, i, cols - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                change(board, <span class="number">0</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (board[rows - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                change(board, rows - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isInBoard(board, i, j) || board[i][j] != <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = <span class="string">&#x27;T&#x27;</span>;</span><br><span class="line">        change(board, i - <span class="number">1</span>, j);</span><br><span class="line">        change(board, i + <span class="number">1</span>, j);</span><br><span class="line">        change(board, i, j - <span class="number">1</span>);</span><br><span class="line">        change(board, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isInBoard</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;=<span class="number">0</span> &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-131:Palindrome Partitioning</title>
    <url>/leetCode/leetCode-131/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串，要求将字符串分割成子字符串列表，且列表中每个子字符串都是回文字符串。要求将所有可能的分割结果返回。题目链接：**<a href="https://leetcode.com/problems/palindrome-partitioning">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：”aab”</p>
<p>输出：[[“a”, “a”, “b”], [“aa”, “b”]]</p>
</blockquote>
<blockquote>
<p>输入：”a”</p>
<p>输出：[[a]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>循环遍历字符串，每次截取前面的子字符串，判断是否是回文串，如果是放入列表中，将后半段字符串进行下个递归计算，不是则跳过本次递归。最后待分割的字符串为空时，则将列表的字符串集合放入结果集中。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;String, Boolean&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        partition(s, map, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">partition</span><span class="params">(String str, Map&lt;String, Boolean&gt; map, List&lt;String&gt; current, List&lt;List&lt;String&gt;&gt; result)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(current));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> str.substring(<span class="number">0</span>, i);</span><br><span class="line">            <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> str.substring(i);</span><br><span class="line">            <span class="keyword">if</span> (!isPalindrome(map, prefix))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current.add(prefix);</span><br><span class="line">            partition(suffix, map, current, result);</span><br><span class="line">            current.remove(current.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(Map&lt;String, Boolean&gt; map, String str)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(str))</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(str, isPalindrome(str));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map.get(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String str)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> len / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) != str.charAt(len - i - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>解法一耗时比较长，有 20 ms。观察解法一中，每次都截取了字符串，相对比较耗时，可以采用下标来进行标识判断，这样就避免了每次都截取字符串，可以节省时间，此种做法耗时 2 ms。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        partition(s, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">partition</span><span class="params">(String str, <span class="type">int</span> index, List&lt;String&gt; current, List&lt;List&lt;String&gt;&gt; result)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == str.length())</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(current));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index + <span class="number">1</span>; i &lt;= str.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(str, index, i - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                current.add(str.substring(index, i));</span><br><span class="line">                partition(str, i, current, result);</span><br><span class="line">                current.remove(current.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> (end - start + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(start + i) != str.charAt(end - i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-132:Palindrome Partitioning II</title>
    <url>/leetCode/leetCode-132/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串，要求找出最小分割次数，使分割后的字符串都是回文字符串。题目链接：**<a href="https://leetcode.com/problems/palindrome-partitioning-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：aaa</p>
<p>输出：0</p>
</blockquote>
<blockquote>
<p>输入：aab</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用动态规划进行求解。用 <code>dp[i]</code> 表示字符串中 <code>0~i</code> 构成的子字符串所需要的最小分割次数。则动态转移方程为 <code>如果 0 到 i 组成的子字符是回文字符串，则 dp[i] = 0，否则 dp[i] = min(dp[i], dp[k] + 1)(k 从 0 到 i - 1)（其中，k + 1 到 i 组成的子字符串是一个回文字符串）</code>。至于判断从 <code>i</code> 到 <code>j</code> 构成的字符串是否是回文字符串，同样可以用动态规划进行求解，其动态转移方程为 <code>dp[i][j] = dp[i + 1][j - 1] &amp;&amp; a[i + 1] == a[j - 1]</code>。这样在后续进行比较中就能直接获取到对应的值而不用每次都进行回文串的判断，减少时间消耗。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCut</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] palindromeArray = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">        handlePalindromeArray(s, palindromeArray);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] minCuts = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        Arrays.fill(minCuts, Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (palindromeArray[<span class="number">0</span>][i])</span><br><span class="line">            &#123;</span><br><span class="line">                minCuts[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (palindromeArray[j + <span class="number">1</span>][i] &amp;&amp; (minCuts[j] + <span class="number">1</span>) &lt; minCuts[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    minCuts[i] = minCuts[j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minCuts[s.length() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePalindromeArray</span><span class="params">(String str, <span class="type">boolean</span>[][] dp)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; str.length(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> j; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j || i == j - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = str.charAt(i) == str.charAt(j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (str.charAt(i) == str.charAt(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-133:Clone Graph</title>
    <url>/leetCode/leetCode-133/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个无向连通图，要求将图进行深拷贝。题目链接：**<a href="https://leetcode.com/problems/clone-graph">点我</a>**</p>
<span id="more"></span>

<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用深搜算法遍历每个节点，为了保证遍历过程中邻节点的正确性，将已经访问过的节点存在数组中，后续查找邻节点时直接从数组中进行获取，这样既能保证节点的正确性，也能提高访问效率。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; neighbors;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,List&lt;Node&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">cloneGraph</span><span class="params">(Node node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node[] nodes = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">101</span>];</span><br><span class="line">        copy(node, nodes, <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">101</span>]);</span><br><span class="line">        <span class="keyword">return</span> nodes[node.val];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(Node source, Node[] nodes, <span class="type">boolean</span>[] visited)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[source.val])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[source.val] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (nodes[source.val] == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nodes[source.val] = <span class="keyword">new</span> <span class="title class_">Node</span>(source.val, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">dest</span> <span class="operator">=</span> nodes[source.val];</span><br><span class="line">        <span class="keyword">for</span> (Node neighbor : source.neighbors)</span><br><span class="line">        &#123;</span><br><span class="line">            copy(neighbor, nodes, visited);</span><br><span class="line">            dest.neighbors.add(nodes[neighbor.val]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-135:Candy</title>
    <url>/leetCode/leetCode-135/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数组，表示每个小孩的排名，现在给小孩分配糖果，要求满足：每个小孩至少分到一个糖果，排名比旁边高的小孩分配到的糖果要多于旁边的小孩。求出分配的糖果数量总和最小的值。题目链接：**<a href="https://leetcode.com/problems/candy/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,0,2]</p>
<p>输出：5</p>
<p>解释：第一个小孩分配 2 个糖果，第二个小孩分配 1 个糖果，第三个小孩分配 2 个糖果</p>
</blockquote>
<blockquote>
<p>输入：[1,2,2]</p>
<p>输出：4</p>
<p>输出：第一个小孩分配 1 个糖果，第二个小孩分配 2 个糖果，第三个小孩分配 1 个糖果</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>要让分配的糖果总数最小，就需要在每个人拥有一个糖果后，找出数组中的升序序列和降序序列，然后对这子序列的小孩的糖果数依次加一（升序序列：从左到右，依次加一；降序序列：从右到左，依次加一）。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings == <span class="literal">null</span> || ratings.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ratings.length == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> begin + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; ratings.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 找出升序序列</span></span><br><span class="line">            <span class="keyword">while</span> (index &lt; ratings.length &amp;&amp; ratings[index - <span class="number">1</span>] &lt; ratings[index])</span><br><span class="line">            &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> index - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找出降序序列</span></span><br><span class="line">            <span class="keyword">while</span> (index &lt; ratings.length &amp;&amp; ratings[index - <span class="number">1</span>] &gt; ratings[index])</span><br><span class="line">            &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (top - begin &gt; index - top - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// top 放在升序序列中</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">ascendingLength</span> <span class="operator">=</span> top - begin + <span class="number">1</span>;</span><br><span class="line">                sum += ascendingLength * (ascendingLength - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">descendingLength</span> <span class="operator">=</span> index - top - <span class="number">1</span>;</span><br><span class="line">                sum += descendingLength * (descendingLength - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// top 放在降序序列中</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">ascendingLength</span> <span class="operator">=</span> top - begin;</span><br><span class="line">                sum += ascendingLength * (ascendingLength - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">descendingLength</span> <span class="operator">=</span> index - top;</span><br><span class="line">                sum += descendingLength * (descendingLength - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 排名相等，不用额外分配糖果，直接跳过</span></span><br><span class="line">            <span class="keyword">while</span> (index &lt; ratings.length &amp;&amp; ratings[index - <span class="number">1</span>] == ratings[index])</span><br><span class="line">            &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            begin = index - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-136:Single Number</title>
    <url>/leetCode/leetCode-136/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个非空整数数组，数组中的元素要么出现两次，要么只出现一次。要求在 <code>O(n)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度内将数组中只出现一次的数字找到并返回。题目链接：**<a href="https://leetcode.com/problems/single-number/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3,4,2,3,1]</p>
<p>输出：4</p>
</blockquote>
<blockquote>
<p>输入：[1]</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题如果去除时间复杂度和空间复杂度的限制，会有多种解法，其中一种直观的方法是使用 map 存储每个数字出现的次数，然后将出现一次的数字返回。但这不满足题目对空间复杂度的要求。要想在  <code>O(n)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度内解答此题，可以利用<strong>异或</strong>运算的特点，将数组中所有元素进行异或，最终剩下的数字就是只出现一次的数字（出现两次的数字异或后为 0）， 代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-137:Single Number II</title>
    <url>/leetCode/leetCode-137/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，里面有一个数字出现一次，其他数字出现三次，要求用 <code>O(1)</code> 的空间复杂度、<code>O(n)</code> 的时间复杂度将只出现一次的数字找出来。题目链接：**<a href="https://leetcode.com/problems/single-number-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [2,2,3,2]</p>
<p>输出：3</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [0,1,0,1,0,1,99]</p>
<p>输出：99</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题最简单是用一个 <code>map</code> 来存储数字出现的次数。但是这样不满足 <code>O(1)</code> 空间复杂度的要求。由于题目中除了某个数字外其他数字都出现 3 次，因此可以基于每个数字的二进制位进行统计，如果某个位置出现次数的余数不是 3 的整数倍，则说明这个位置是出现 1 次的数字对应的位置（即数字映射到当前位的数为 1），然后将每个位置的数进行或运算就能得到只出现一次的数字了。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">                count += (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                result = result | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-138:Copy List with Random Pointer</title>
    <url>/leetCode/leetCode-138/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表，链表的节点中有个随机指针，指向链表中的任何一个节点，或者指向空。要求将这个链表进行深度拷贝。题目链接：**<a href="https://leetcode.com/problems/copy-list-with-random-pointer/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><p>无</p>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用一个 map 存储原先老节点和新节点的对应关系，第一次循环遍历链表，复制链表的 next 指针指向的内容，同时将新老节点的映射关系进行存储。第二次循环遍历链表，根据原先链表节点的随机指针指向的节从  map 中取出对应的新节点，并将当前遍历到的新节点的随机指针指向这个新的随机节点，从而完成链表随机指针的复制。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">        map.put(head, newHead);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> newHead;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">pNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(p.val);</span><br><span class="line">            current.next = pNew;</span><br><span class="line">            map.put(p, pNew);</span><br><span class="line">            p = p.next;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">pNew</span> <span class="operator">=</span> map.get(p);</span><br><span class="line">            pNew.random = map.get(p.random);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-139:Word Break</title>
    <url>/leetCode/leetCode-139/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串和一个字符串列表，要求判断是否能将字符串分割成列表中的字符串，列表中的字符串可以重复使用。题目链接：**<a href="https://leetcode.com/problems/word-break/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”]</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解法一：递归（超时）"><a href="#解法一：递归（超时）" class="headerlink" title="解法一：递归（超时）"></a>解法一：递归（超时）</h2><p>直接使用递归的做法，每次遍历字符串列表，判断剩余的字符串是否有以字符串列表中的字符串开头的，如果有，则移动查找的指针到下个位置（指针移动距离为匹配的字符串长度），继续下一轮搜索，如果搜索指针移动到最后，则说明原始字符串能切割成功，否则说明切割不成功。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> wordBreak(s, <span class="number">0</span>, wordDict);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String str, <span class="type">int</span> startIndex, List&lt;String&gt; wordDict)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex == str.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.indexOf(word, startIndex) == startIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> wordBreak(str, startIndex + word.length(), wordDict);</span><br><span class="line">                <span class="keyword">if</span> (isFind)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：递归-剪枝"><a href="#解法二：递归-剪枝" class="headerlink" title="解法二：递归+剪枝"></a>解法二：递归+剪枝</h2><p>解法一中直接用递归，虽然简单，但是超时了，原因是可能存在重复搜索的过程。因此，增加一个数组记录当前位置是否搜索过，如果已经搜索过，则直接返回结果，不重复进行，从而达到剪枝的效果，也称之为记忆化搜索。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] flags = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> wordBreak(s, <span class="number">0</span>, flags, wordDict);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String str, <span class="type">int</span> startIndex, <span class="type">int</span>[] flags, List&lt;String&gt; wordDict)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex == str.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags[startIndex] == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.indexOf(word, startIndex) == startIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> wordBreak(str, startIndex + word.length(), flags, wordDict);</span><br><span class="line">                <span class="keyword">if</span> (isFind)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                flags[startIndex] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-140:Word Break II</title>
    <url>/leetCode/leetCode-140/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串 <code>s</code> 和字符串数组 <code>wordDict</code>，要求将字符串 <code>s</code> 切割成单词组成的句子，其中每个单词都来自 <code>wordDict</code> 中的字符串，<code>wordDict</code> 中的字符串可以重复使用。返回所有满足要求的句子列表。题目链接：**<a href="https://leetcode.com/problems/word-break-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：s &#x3D; “catsanddog”   wordDict &#x3D; [“cat”, “cats”, “and”, “sand”, “dog”]</p>
<p>输出：[“cats and dog”, “cat sand dog”]</p>
</blockquote>
<blockquote>
<p>输入：s &#x3D; “pineapplepenapple”    wordDict &#x3D; [“apple”, “pen”, “applepen”, “pine”, “pineapple”]</p>
<p>输出：[“pine apple pen apple”, “pineapple pen apple”, “pine applepen apple”]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解法一：单纯回溯（超时）"><a href="#解法一：单纯回溯（超时）" class="headerlink" title="解法一：单纯回溯（超时）"></a>解法一：单纯回溯（超时）</h2><p>最直观简单的做法就是使用回溯算法，没有使用记忆化搜索进行剪枝，这也算是暴力的一种做法吧。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        wordBreak(s, <span class="number">0</span>, wordDict, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">wordBreak</span><span class="params">(String str, <span class="type">int</span> startIndex, List&lt;String&gt; wordDict, List&lt;String&gt; current, List&lt;String&gt; result)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex == str.length())</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(convert(current));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.startsWith(word, startIndex))</span><br><span class="line">            &#123;</span><br><span class="line">                current.add(word);</span><br><span class="line">                wordBreak(str, startIndex + word.length(), wordDict, current, result);</span><br><span class="line">                current.remove(current.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">convert</span><span class="params">(List&lt;String&gt; strList)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String str : strList)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(str).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：回溯-记忆化搜索剪枝"><a href="#解法二：回溯-记忆化搜索剪枝" class="headerlink" title="解法二：回溯+记忆化搜索剪枝"></a>解法二：回溯+记忆化搜索剪枝</h2><p>单纯使用回溯算法暴力搜索超时了，所以加上记忆化搜索，对不满足要求的重复搜索的过程进行剪枝处理，减少时间损耗。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] flags = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        wordBreak(s, <span class="number">0</span>, wordDict, flags, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String str, <span class="type">int</span> startIndex, List&lt;String&gt; wordDict, <span class="type">int</span>[] flags, List&lt;String&gt; current, List&lt;String&gt; result)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags[startIndex] == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startIndex == str.length())</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(convert(current));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.startsWith(word, startIndex))</span><br><span class="line">            &#123;</span><br><span class="line">                current.add(word);</span><br><span class="line">                <span class="keyword">if</span> (wordBreak(str, startIndex + word.length(), wordDict, flags, current, result))</span><br><span class="line">                &#123;</span><br><span class="line">                    isFind = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不能直接使用 else，否则如果存在多种情况（部分情况满足，部分情况不满足）的时候，会缺少解</span></span><br><span class="line">                <span class="keyword">if</span> (!isFind)</span><br><span class="line">                &#123;</span><br><span class="line">                    flags[startIndex] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                current.remove(current.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isFind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">convert</span><span class="params">(List&lt;String&gt; strList)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String str : strList)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(str).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-141:Linked List Cycle</title>
    <url>/leetCode/leetCode-141/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表，要求判断链表是否存在环。题目链接：**<a href="https://leetcode.com/problems/linked-list-cycle/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：<img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png"></p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：1</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题是判断链表是否存在循环的经典解法，使用快慢指针进行判断，如果两指针相遇，就说明存在循环，否则不存在循环。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (right != <span class="literal">null</span> &amp;&amp; right.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            right = right.next.next;</span><br><span class="line">            left = left.next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-142:Linked List Cycle II</title>
    <url>/leetCode/leetCode-142/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表，要求判断链表是否存在环，如果存在环，则返回环的入口节点，否则返回 <code>null</code>。题目链接：**<a href="https://leetcode.com/problems/linked-list-cycle-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png"></p>
<p>输出：Node(2)</p>
</blockquote>
<blockquote>
<p>输入：1</p>
<p>输出：null</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单的做法是使用一个 set 来保存遍历过的节点，如果后续第一次遇到已经遍历过的节点，那就说明这个节点是环的入口节点，否则不存在环。但是此做法需要用额外的空间来保存。</p>
<p>优化一点的做法是，使用快慢指针，按照判断是否存在环的做法进行查找，如果找到环，假设此时环外的链表长度为 <code>a</code>，环起始节点到相遇节点的距离为 <code>b</code>，环内相遇节点剩下的距离为 <code>c</code>，则存在以下表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slow = a + b    // 当slow指针开始进入环后，此时无论fast指针在哪，slow指针不用走一圈就能与fast指针相遇</span><br><span class="line">fast = a + b + n(b + c)    // n 表示 fast 指针绕环 n 圈</span><br><span class="line">fast = 2 * slow</span><br></pre></td></tr></table></figure>

<p>根据上述表达式可以得出以下公式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = (n - 1)(b + c) + c</span><br></pre></td></tr></table></figure>

<p>可以看到，环外的链表距离等于相遇节点环内剩余距离加上 <code>n - 1</code> 圈环长度。因此，此时如果用一个指针从链表头部开始，与 slow 指针同时开始一步步遍历，最终两个指针相遇就是环的入口。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">         <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">             fast = fast.next.next;</span><br><span class="line">             slow = slow.next;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">         <span class="keyword">while</span> (p != slow) &#123;</span><br><span class="line">             p = p.next;</span><br><span class="line">             slow = slow.next;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/">https://leetcode.cn/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-143:Reorder List</title>
    <url>/leetCode/leetCode-143/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表，用 <code>L0→L1→…→Ln-1→Ln</code> 表示，要求在不改变节点值的情况下将链表改成以下顺序：<code>L0→Ln→L1→Ln-1→L2→Ln-2→…</code>。题目链接：**<a href="https://leetcode.com/problems/reorder-list">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：1-&gt;2-&gt;3-&gt;4</p>
<p>输出：1-&gt;4-&gt;2-&gt;3</p>
</blockquote>
<blockquote>
<p>输入：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>输出：1-&gt;5-&gt;2-&gt;4-&gt;3</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题最简单的解法就是遍历一遍，在遍历过程中用一个数组来存储每个节点，然后遍历数组中的节点，根据规则将每个节点的 <code>next</code> 指针指向对应节点即可。但是这种做法需要花费 <code>O(n)</code> 的空间复杂度。一般而言，leetcode 上链表的题目，都是用 <code>O(1)</code> 的空间复杂度进行求解的。针对此题，一种 <code>O(1)</code>的空间复杂度的解法如下：</p>
<ul>
<li><p>首先将链表对半拆分，拆成两个子链表。可以用快慢指针进行拆分，时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(1)</code></p>
</li>
<li><p>其次，对后半部分的链接进行倒序。时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(1)</code></p>
</li>
<li><p>最后，合并前后两个子链表。时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(1)</code></p>
</li>
</ul>
<p>总体而言，时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(1)</code></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// split the list</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">half</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prevEnd</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">null</span> &amp;&amp; next.next != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = next.next.next;</span><br><span class="line">            prevEnd = half;</span><br><span class="line">            half = half.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prevEnd.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reverse the post half list</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">postHead</span> <span class="operator">=</span> reverseList(half);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// merge two half list</span></span><br><span class="line">        mergeList(head, postHead);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeList</span><span class="params">(ListNode firstHead, ListNode secondHead)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> firstHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> secondHead;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="literal">null</span> &amp;&amp; first.next != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">secondNext</span> <span class="operator">=</span> second.next;</span><br><span class="line">            second.next = first.next;</span><br><span class="line">            first.next = second;</span><br><span class="line">            first = second.next;</span><br><span class="line">            second = secondNext;</span><br><span class="line">        &#125;</span><br><span class="line">        first.next = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">        <span class="keyword">while</span> (head.next != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">            head.next = next.next;</span><br><span class="line">            next.next = dummyNode.next;</span><br><span class="line">            dummyNode.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-147:Insertion Sort List</title>
    <url>/leetCode/leetCode-147/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表，要求用插入排序的方式对链表进行升序排序。题目链接：**<a href="https://leetcode.com/problems/insertion-sort-list/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：4-&gt;2-&gt;1-&gt;3</p>
<p>输出：1-&gt;2-&gt;3-&gt;4</p>
</blockquote>
<blockquote>
<p>输入：-1-&gt;5-&gt;3-&gt;4-&gt;0</p>
<p>输出：-1-&gt;0-&gt;3-&gt;4-&gt;5</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>直接使用插入排序的算法进行排序。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">insertionSortList</span><span class="params">(ListNode head)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(Integer.MIN_VALUE, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> p.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> dummy;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isMove</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (q.next != current)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (q.next.val &lt; current.val)</span><br><span class="line">                &#123;</span><br><span class="line">                    q = q.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p.next = current.next;</span><br><span class="line">                    current.next =q.next;</span><br><span class="line">                    q.next = current;</span><br><span class="line">                    isMove = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (isMove)</span><br><span class="line">            &#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-148:Sort List</title>
    <url>/leetCode/leetCode-148/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表，要求用 <code>O(nlog n)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度，对链表进行排序。题目链接：**<a href="https://leetcode.com/problems/sort-list">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：4-&gt;2-&gt;1-&gt;3</p>
<p>输出：1-&gt;2-&gt;3-&gt;4</p>
</blockquote>
<blockquote>
<p>输入：-1-&gt;5-&gt;3-&gt;4-&gt;0</p>
<p>输出：-1-&gt;0-&gt;3-&gt;4-&gt;5</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用归并排序算法，由于要求空间复杂度为常量，所以此处不用递归，而用递推。具体做法是：将链表按长度为 <code>n</code>（n &#x3D; 1, 2, 4, 8, 16, …）分割成不同的子链表，再将相邻的两个子链表进行归并排序。重复执行以上过程，直到 <code>n = length / 2</code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> countListLength(head);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= length; i *= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nextHead</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">prevEnd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (nextHead != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> nextHead;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> cutList(first, i);</span><br><span class="line">                nextHead = cutList(second, i);</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">tempHead</span> <span class="operator">=</span> mergeList(first, second);</span><br><span class="line">                <span class="keyword">if</span> (prevEnd == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    head = tempHead;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    prevEnd.next = tempHead;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (tempHead.next != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tempHead = tempHead.next;</span><br><span class="line">                &#125;</span><br><span class="line">                tempHead.next = nextHead;</span><br><span class="line">                prevEnd = tempHead;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">mergeList</span><span class="params">(ListNode first, ListNode second)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (second == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> second;</span><br><span class="line">        <span class="keyword">if</span> (first.val &lt; second.val)</span><br><span class="line">        &#123;</span><br><span class="line">            head = first;</span><br><span class="line">            p1 = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = second;</span><br><span class="line">            p2 = second.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val &lt; p2.val)</span><br><span class="line">            &#123;</span><br><span class="line">                current.next = p1;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                current.next = p2;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            current.next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            current.next = p1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 截取链表前 n 个节点组成子链表，返回截取后剩下链表的首节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 链表首节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n    截取的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 截取后剩下链表的首节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">cutList</span><span class="params">(ListNode head, <span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; n &amp;&amp; current != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (current != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = current.next;</span><br><span class="line">            current.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countListLength</span><span class="params">(ListNode head)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            length++;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-149:Max Points on a Line</title>
    <url>/leetCode/leetCode-149/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二维数组表示二维坐标系上的不同坐标，这些不同的坐标构成了很多条直线，要求直线上拥有最多的坐标数量。题目链接：**<a href="https://leetcode.com/problems/max-points-on-a-line/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：points &#x3D; [[1,1],[2,2],[3,3]]</p>
<p>输出：3</p>
<p>说明：这三个坐标都在同一条直线上</p>
</blockquote>
<blockquote>
<p>输入：points &#x3D; [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</p>
<p>输出：4</p>
<p>说明：[3,2],[4,1],[2,3],[1,4] 这四个坐标在同一条直线上</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>循环遍历每个坐标，针对每个坐标，找出其他坐标与这个坐标构成的直线，如果斜率相同，说明是同一条直线，则计数加一，同时更新最大的坐标数量。需要注意的是，斜率之间的比较不能使用 double 进行比较，因为这是不准确的，用 BigDecimal 进行比较规避此问题。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPoints</span><span class="params">(<span class="type">int</span>[][] points)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; points.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> points[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">infiniteCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            Map&lt;BigDecimal, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; points.length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> points[j][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">y2</span> <span class="operator">=</span> points[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x1 == x2)</span><br><span class="line">                &#123;</span><br><span class="line">                    infiniteCount++;</span><br><span class="line">                    count = Math.max(count, infiniteCount);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">double</span> <span class="variable">k</span> <span class="operator">=</span> (y2 - y1) * <span class="number">1.0</span> / (x2 - x1);</span><br><span class="line">                <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> map.getOrDefault(BigDecimal.valueOf(k), <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">                count = Math.max(count, nums);</span><br><span class="line">                map.put(BigDecimal.valueOf(k), nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-15:3Sum</title>
    <url>/leetCode/leetCode-15/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出一个数组，要求找出其中三个数相加值为 0 的所有组合。需要注意的是，输出不能包括相同的三元数组。例如：[1, 0, -1]、[1, -1, 0]、[-1, 0, 1]、[-1, 1, 0]、[1, -1, 1]、[0, 1, -1]这几个属于相同的三元数组，只需要输出其中个任何一个即可。题目链接：**<a href="https://leetcode.com/problems/3sum/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[-1, 0, 1, 2, -1, -4]</p>
<p>输出：[[-1, 0, 1],  [-1, -1, 2]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此问题不能使用暴力的做法，这样至少需要三层循环，时间复杂度为<code>O(n^3)</code>，再加上对三元数组的去重，可能需要增加额外的循环导致增加额外的复杂度。即使将三元数组用一个类来表示，用set对其进行去重，整个求解过程也需要花费<code>O(n^3)</code>的时间复杂度，很容易超时。因此需要寻求另外的解法方法。</p>
<p>使用暴力主要是因为数组是无序的，如果数组是有序的，可以使用双头指针来减少一层循环。主要做法如下</p>
<ul>
<li>对数组进行升序排序得到有序的数组</li>
<li>对数组进行遍历，此次遍历是获得第三元数组中的第一个数，在此层遍历中，需要跳过已经遍历过的相同的项，这样既不会产生相同的三元数组，更能节省不必要的循环</li>
<li>在内部循环中，定义首尾两个指针，依次判断首指针数、尾指针数、外层循环数三者之和是否为0。<ul>
<li>如果为0，则加入结果链表中。同时移动首尾指针跳过相同的项</li>
<li>如果大于0，说明尾指针的数过大，要将尾指针向前移动一位，然后继续循环比较</li>
<li>如果小于0，说明首指针的数过小，要将首指针向后移动一位，然后继续循环比较</li>
</ul>
</li>
</ul>
<p>此过程，排序时间复杂度为<code>O(nlogn)</code>，获取所有结果是两层循环，时间负责度为<code>O(n^2)</code>，总体时间复杂度为<code>O(n^2)</code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 跳过相同项</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[start] + nums[end] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    List&lt;Integer&gt; triplet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">                    triplet.addAll(Arrays.asList(nums[i], nums[start], nums[end]));</span><br><span class="line">                    result.add(triplet);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 跳过相同项</span></span><br><span class="line">                    <span class="keyword">while</span> (start &lt; len - <span class="number">1</span> &amp;&amp; nums[start] == nums[start + <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        start++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 跳过相同项</span></span><br><span class="line">                    <span class="keyword">while</span> (end &gt; <span class="number">0</span> &amp;&amp; nums[end] == nums[end - <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        end--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    start++;</span><br><span class="line">                    end--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[start] + nums[end] &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    end--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h1><ol>
<li><a href="https://leetcode.com/problems/3sum/discuss/7380/Concise-O(N2)-Java-solution">https://leetcode.com/problems/3sum/discuss/7380/Concise-O(N2)-Java-solution</a></li>
<li><a href="https://leetcode.com/problems/3sum/discuss/134544/my-solution-in-java-O(n2)">https://leetcode.com/problems/3sum/discuss/134544/my-solution-in-java-O(n2)</a></li>
</ol>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-150:Evaluate Reverse Polish Notation</title>
    <url>/leetCode/leetCode-150/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串数组，表示算术的后缀表达式，并且保证这个表达式是合法的，要求算出这个表达式的值。题目链接：**<a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[“2”, “1”, “+”, “3”, “*”]</p>
<p>输出：9</p>
<p>解释：((2 + 1) * 3) &#x3D; 9</p>
</blockquote>
<blockquote>
<p>输入：[“10”, “6”, “9”, “3”, “+”, “-11”, “<em>“, “&#x2F;“, “</em>“, “17”, “+”, “5”, “+”]</p>
<p>输出：22</p>
<p>解释：((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5 &#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5 &#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5 &#x3D; ((10 * 0) + 17) + 5 &#x3D; (0 + 17) + 5 &#x3D; 17 + 5 &#x3D; 22</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用栈来保存运算的数，遍历数组，如果遇到数字，则压入栈中，如果遇到运算符合，则弹出栈顶元素作为第二个操作数，再弹出栈顶元素作为第一个运算数，对其进行运算得到结果压入栈中。运算结束后，栈顶的元素就是表达式的结果。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens == <span class="literal">null</span> || tokens.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tokens.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tokens[i].equals(<span class="string">&quot;+&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> first + second;</span><br><span class="line">                stack.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> first - second;</span><br><span class="line">                stack.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].equals(<span class="string">&quot;*&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> first * second;</span><br><span class="line">                stack.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].equals(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> first / second;</span><br><span class="line">                stack.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(Integer.parseInt(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-151:Reverse Words in a String</title>
    <url>/leetCode/leetCode-151/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串，由单词和空格组成，要求将字符串中单词进行倒序（单词间用一个空格分隔）。题目链接：**<a href="https://leetcode.com/problems/reverse-words-in-a-string/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：”  Bob    Loves  Alice   “</p>
<p>输出：”Alice Loves Bob”</p>
</blockquote>
<blockquote>
<p>输入：”a good   example”</p>
<p>输出：”example good a”</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>使用 <code>split</code> 函数对字符串按空格分隔，然后从后往前拼接字符串。这种做法简单，但是消耗空间比较多。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String[] words = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> words.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (words[i].length() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.append(words[i]).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>从后往前遍历字符串，遇到非空格的字符，则从此处向前查找最后一个空格，然后切割出单词进行拼接。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">spaceIndex</span> <span class="operator">=</span> s.lastIndexOf(<span class="string">&#x27; &#x27;</span>, i);</span><br><span class="line">                sb.append(s.substring(spaceIndex + <span class="number">1</span>, i + <span class="number">1</span>)).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                i = spaceIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-152:Maximum Product Subarray</title>
    <url>/leetCode/leetCode-152/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，要求从数组中找出连续子数组，使得子数组中的元素乘积最大，将最大乘积值返回。题目链接：**<a href="https://leetcode.com/problems/maximum-product-subarray/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[2,3,-2,4]</p>
<p>输出：6</p>
</blockquote>
<blockquote>
<p>输入：[-2,0,-1]</p>
<p>输出：0</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解决一：暴力"><a href="#解决一：暴力" class="headerlink" title="解决一：暴力"></a>解决一：暴力</h2><p>此问题最简单直接的方式，就是两层 for 循环直接暴力求解。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            product = Math.max(current, product);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                current = current * nums[j];</span><br><span class="line">                product = Math.max(current, product);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h2><p>暴力求解比较耗时，稍微好点的方式是使用动态规划。此解法参考：</p>
<p>用 <code>dpMaxs[i]</code> 表示以 <code>nums[i]</code> 结尾的连续子数组的乘积的最大值，用 <code>dpMins[i]</code> 表示以 <code>nums[i]</code> 结尾的连续子数组的乘积的最小值。考虑 <code>nums[i]</code> 是正负数的情况。如果是正数，那前面的乘积必须得是正数，且值越大越好。如果是负数，那前面的乘积必须是负数，且值越小越好。所以就有以下的动态转换方程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dpMaxs[i] = max(dpMaxs[i - <span class="number">1</span>] * nums[i], dpMins[i - <span class="number">1</span>] * nums[i], nums[i])</span><br><span class="line">dpMins[i] = min(dpMaxs[i - <span class="number">1</span>] * nums[i], dpMins[i - <span class="number">1</span>] * nums[i], nums[i])</span><br></pre></td></tr></table></figure>

<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] dpMaxs = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span>[] dpMins = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(dpMaxs, Integer.MIN_VALUE);</span><br><span class="line">        Arrays.fill(dpMins, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        dpMaxs[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dpMins[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dpMaxs[i] = Math.max(Math.max(dpMaxs[i - <span class="number">1</span>] * nums[i], dpMins[i - <span class="number">1</span>] * nums[i]), nums[i]);</span><br><span class="line">            dpMins[i] = Math.min(Math.min(dpMaxs[i - <span class="number">1</span>] * nums[i], dpMins[i - <span class="number">1</span>] * nums[i]), nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(dpMaxs).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-leetcode-solution/">https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-leetcode-solution/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-153:Find Minimum in Rotated Sorted Array</title>
    <url>/leetCode/leetCode-153/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个旋转过的升序数组，要求找出数组中的最小元素。题目链接：**<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[3,4,5,1,2]</p>
<p>输出：1</p>
</blockquote>
<blockquote>
<p>输入：[4,5,6,7,0,1,2]</p>
<p>输出：0</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题最直观暴力的一种做法就是顺序遍历找出最小的元素。但是这很明显就无法利用 “升序” 的这一特点。所以遍历数组肯定不是题目的本意。观察旋转的升序数组，可以发现，如果数组第一个数字比最后一个数字大，那就说明数组是旋转过的，可以不断使用二分查找的方式进行排查过滤。如果数组第一个元素比最后一个数字大，那说明数组已经是有序的升序数组了，此时直接返回第一个元素即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[start] &lt; nums[end])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[start];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> != end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[start] &gt; nums[middle])</span><br><span class="line">            &#123;</span><br><span class="line">                end = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                start = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(nums[start], nums[end]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-154:Find Minimum in Rotated Sorted Array II</title>
    <url>/leetCode/leetCode-154/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个升序的整形数组，数组中包含重复数字，要求找出数组中最小的数字。题目链接：**<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,3,5]</p>
<p>输出：1</p>
</blockquote>
<blockquote>
<p>输入：[2,2,2,0,1]</p>
<p>输出：0</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题跟 <a href="https://guozhchun.github.io/leetCode/leetCode-153/">LeetCode-153</a> 类似，只不过此处在数组中加入了重复元素。做法跟原先也差不多，只需要在进行二分查找前对重复元素进行排除处理即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt; nums[nums.length - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> != end &amp;&amp; start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[start] == nums[start + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[end] == nums[end - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 先判断一下跳出循环，避免在计算 middle 时将 middle 变成了 start，从而遗漏元素</span></span><br><span class="line">            <span class="keyword">if</span> (start + <span class="number">1</span> == end)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[start] &lt; nums[middle])</span><br><span class="line">            &#123;</span><br><span class="line">                start = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                end = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(nums[start], nums[end]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-155:Min Stack</title>
    <url>/leetCode/leetCode-155/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>要求实现一个<code>MinStack</code>，里面包含以下函数</p>
<ul>
<li><code>push</code>：向栈中压入元素</li>
<li><code>pop</code>：弹出栈顶元素</li>
<li><code>top</code>：返回栈顶元素</li>
<li><code>getMin</code>：返回当前栈中元素的最小值</li>
</ul>
<p>要求上述每个操作都在 <code>O(1)</code> 的时间复杂度内完成。题目链接：**<a href="https://leetcode.com/problems/min-stack/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br></pre></td></tr></table></figure>

<p>输出：[null,null,null,null,-3,null,0,-2]</p>
<p>解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin(); // return -3</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();    // return 0</span><br><span class="line">minStack.getMin(); // return -2</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用两个栈，一个栈用来存在每次操作的数字，另一个栈用来存储当前栈中的最小值，每次入栈操作时，都将最小值的栈顶元素和要入栈的元素进行比较，将值小的值放入最小值栈中，出栈的时候两个栈的栈顶元素都要出栈。在调用 <code>getMin</code> 时，直接返回最小值栈的栈顶元素即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; numStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minNumStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        numStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minNumStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        numStack.push(val);</span><br><span class="line">        <span class="keyword">if</span> (minNumStack.isEmpty()) &#123;</span><br><span class="line">            minNumStack.push(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(val, minNumStack.peek());</span><br><span class="line">        minNumStack.push(min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        numStack.pop();</span><br><span class="line">        minNumStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minNumStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-16:3Sum Closest</title>
    <url>/leetCode/leetCode-16/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出一个无重复数字的整形数组和一个目标数字，要求找出数组中三个数字之和与目标数字最相近。题目链接：**<a href="https://leetcode.com/problems/3sum-closest/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：数组：[-1, 2, 1, -4]，目标数字：1</p>
<p>输出：2</p>
<p>解释：(-1 + 2 + 1 &#x3D; 2)</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="暴力查询"><a href="#暴力查询" class="headerlink" title="暴力查询"></a>暴力查询</h2><p>此种方法最为简单，就是用三层循环，找出数组中三个数字的所有组合，并将组合的和与目标数字进行比较，将最相近的那项值输出。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minVal</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + <span class="number">1</span>; k &lt; length; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[k];</span><br><span class="line">                    <span class="keyword">if</span> (Math.abs(sum - target) &lt; minVal)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minVal = Math.abs(sum - target);</span><br><span class="line">                        result = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双头指针查询"><a href="#双头指针查询" class="headerlink" title="双头指针查询"></a>双头指针查询</h2><p>使用暴力查询的方法虽然能够解决此题，但是时间复杂度过高，有<code>O(n^3)</code>，如果对数组进行排序，再使用双头指针进行遍历，则可以减少一层循环，使时间复杂度为<code>O(n^2)</code>。具体做法如下</p>
<ul>
<li>对数组进行升序排序，获取有序数组</li>
<li>用一层循环遍历数组，获取三项中的第一项的值</li>
<li>在内部循环中，定义首尾两个指针，依次判断首指针数、尾指针数、外层循环数三者之和与目标数字之间的差距<ul>
<li>如果三者之和大于目标数字，则将尾指针向前移动一位，同时判断此时三者之和和目标数字之间的差距是否最小，如果最小，则记录此数。</li>
<li>如果三者之和小于目标数字，则将首指针向后移动一位，同时判断此时三者之和和目标数字之间的差距是否最小，如果最小，则记录此数。</li>
<li>如果三者之和等于目标数字，则目标数字就是要寻找的答案（因为相差为0），直接返回目标数字。</li>
</ul>
</li>
</ul>
<p>现在证明这种方法为什么有效。由于有一层循环对数组进行变量，每次循环取出的数组值作为三个数字中的第一个数字，因此只需要证明内部循环两个数字之和与目标数字和第一个数字之差之间的距离最小即可。由于在每层循环下，目标数字与第一个数字之差<code>m = |targetNum - firstNum|</code>是固定的，所以，只需要找出<code>nums[startIndex] + nums[endIndex] </code>与<code>m</code>的差距最小即可。如果内部循环采用两层循环变量数组取出所有的组合，无疑可以保证得到正确答案。而采用双头指针的方式进行循环，在<code>startIndex</code>和<code>endIndex</code>相互靠拢的过程中，两个指针产生的组合都会进行比较，假设最后到达<code>startIndex + k</code>的位子，此方式相比暴力查询的方式是少了对<code>nums[startIndex]</code>到<code>nums[startIndex + k - 1]</code>这中间的组合进行比较，也少了<code>nums[startIndex + k + 1]</code>到<code>nums[endIndex]</code>中间的组合进行比较。因此只需要证明<code>nums[startIndex]</code>到<code>nums[startIndex + k - 1]</code>中的任意两个数之和与<code>m</code>之间的差距大于<code>nums[startIndex] + nums[endIndex] </code>与<code>m</code>的差距，<code>nums[startIndex + k + 1]</code>到<code>nums[endIndex]</code>中的任意两个数之和与<code>m</code>直接的差距大于<code>nums[startIndex] + nums[endIndex] </code>与<code>m</code>的差距即可。</p>
<p>现在证明<code>nums[startIndex]</code>到<code>nums[startIndex + k - 1]</code>中的任意两个数之和与<code>m</code>之间的差距大于<code>nums[startIndex] + nums[endIndex] </code>与<code>m</code>的差距。假设a、b是<code>nums[startIndex]</code>到<code>nums[startIndex + k - 1]</code>中的任意两个数，则有<code>a &lt; b &lt; nums[startIndex] &lt; nums[endIndex]</code>，且<code>a + nums[endIndex] &lt; m</code>，<code>b + nums[endIndex] &lt; m</code>，<code>a + b &lt; m</code>。后面这三个表达式可以从移动首指针向后一位得出结论。因此只需要证明<code>m - a - b &gt; |nums[startIndex] + nums[endIndex] - m|</code></p>
<ul>
<li>假设<code>nums[startIndex] + nums[endIndex] - m &gt; 0</code>，则只需证明<code>m - a - b &gt; nums[startIndex] + nums[endIndex] - m</code>。由于<code>a + nums[endIndex] &lt; m</code>，<code>b + nums[endIndex] &lt; m</code>，<code>nums[startIndex] &lt; nums[endIndex]</code>，所以<code>a + b + nums[startIndex] + nums[endIndex] &lt; a + b + nums[endIndex] + nums[endIndex] &lt; m + m</code>，所以<code>m - a - b &gt; nums[startIndex] + nums[endIndex] - m</code>得证。</li>
<li>假设<code>nums[startIndex] + nums[endIndex] - m &lt; 0</code>，则只需证明<code>m - a - b &gt; m - nums[startIndex] - nums[endIndex]</code>，由于<code>a &lt; b &lt; nums[startIndex] &lt; nums[endIndex]</code>，所以<code>a + b &lt; nums[startIndex] + nums[endIndex]</code>，所以<code>m - a - b &gt; m - nums[startIndex] - nums[endIndex]</code>得证。</li>
</ul>
<p>现在证明<code>nums[startIndex + k + 1]</code>到<code>nums[endIndex]</code>中的任意两个数之和与<code>m</code>直接的差距大于<code>nums[startIndex] + nums[endIndex] </code>与<code>m</code>的差。假设a、b是<code>nums[startIndex + k + 1]</code>到<code>nums[endIndex]</code>中的任意两个数，则有<code>nums[startIndex] &lt; nums[endIndex] &lt; a &lt; b</code>，且<code>nums[startIndex] + a &gt; m</code>， <code>nums[startIndex] + b &gt; m</code>，<code>a + b &gt; m</code>，后面这三个表达式可以从移动尾指针向前一位得出结论。因此只需要证明<code>a + b - m &gt; |nums[startIndex] + nums[endIndex] - m|</code></p>
<ul>
<li>假设<code>nums[startIndex] + nums[endIndex] - m &gt; 0</code>，则只需要证明<code>a + b - m &gt; nums[startIndex] + nums[endIndex] - m</code>。由于<code>a &gt; b &gt; nums[endIndex] &gt; nums[startIndex]</code>，因此<code>a + b &gt; nums[startIndex] + nums[endIndex]</code>，所以<code>a + b - m &gt; nums[startIndex] + nums[endIndex] - m </code>得证。</li>
<li>假设<code>nums[startIndex] + nums[endIndex] - m &lt; 0</code>，则只需要证明<code>a + b - m &gt; m - nums[startIndex] - nums[endIndex] </code>。由于<code>nums[startIndex] + a &gt; m</code>， <code>nums[startIndex] + b &gt; m</code>，<code>a + b &gt; m</code>，所以<code>a + b + nums[startIndex] + nums[endIndex] &gt; a + b + nums[startIndex] + nums[startIndex] &gt; m + m</code>，所以<code>a + b - m &gt; m - nums[startIndex] - nums[endIndex] </code>得证。</li>
</ul>
<p>综上所述，此方法有效。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minVal</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (startIndex &lt; endIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[startIndex] + nums[endIndex];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">                &#123;</span><br><span class="line">                    endIndex--;</span><br><span class="line">                    <span class="keyword">if</span> (sum - target &lt; minVal)</span><br><span class="line">                    &#123;</span><br><span class="line">                        result = sum;</span><br><span class="line">                        minVal = sum - target;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">                &#123;</span><br><span class="line">                    startIndex++;</span><br><span class="line">                    <span class="keyword">if</span> (target - sum &lt; minVal)</span><br><span class="line">                    &#123;</span><br><span class="line">                        result = sum;</span><br><span class="line">                        minVal = target - sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-160:Intersection of Two Linked Lists</title>
    <url>/leetCode/leetCode-160/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个链表，要求判断两个链表是否相交，如果相交，则返回相交的节点，否则返回 <code>null</code>。题目链接：<a href="https://leetcode.com/problems/intersection-of-two-linked-lists"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</p>
<p>输出：8</p>
<p>解释：两个链表如下所示</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="链表图片"></p>
</blockquote>
<blockquote>
<p>输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</p>
<p>输出：2</p>
<p>解释：两个链表如下所示</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="链表图片"></p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>先分别计算两个链表的长度，然后将链表长度对齐，从对齐节点开始依次向后遍历链表直到两个指针指向的节点相同（同个节点或者都是<code>null</code>），代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthA</span> <span class="operator">=</span> calcLength(headA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthB</span> <span class="operator">=</span> calcLength(headB);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span> (lengthA &gt; lengthB) &#123;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">            lengthA--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (lengthB &gt; lengthA) &#123;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">            lengthB--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcLength</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-162:Find Peak Element</title>
    <url>/leetCode/leetCode-162/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整形数组，要求找出数组中任意一个 <code>peak元素下标</code>（<code>peak元素</code>定义：比左边和右边的元素值都大）。题目链接：**<a href="https://leetcode.com/problems/find-peak-element/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [1,2,3,1]</p>
<p>输出：2</p>
<p>说明：元素 3 比左边元素 2 大，比右边元素 1 大，所以返回其下标 2</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [1,2,1,3,5,6,4]</p>
<p>输出：5</p>
<p>说明：元素 6 比左边元素 5 大，比右边元素 4 大，故返回其下标 5。另外，如果返回下标 1 也是正确的，因为元素 2 比左边元素 1 和右边元素 1 都大，所以下标 1 的元素也是一个 peak 元素</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解法一：遍历"><a href="#解法一：遍历" class="headerlink" title="解法一：遍历"></a>解法一：遍历</h2><p>直接使用 for 循环进行遍历查找，找到就直接返回下标。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;=<span class="number">1</span> || nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>] &amp;&amp; nums[i] &gt; nums[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                               </span><br><span class="line">        <span class="keyword">return</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：二分查找"><a href="#解法二：二分查找" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h2><p>此种解法参考：<a href="https://leetcode.com/problems/find-peak-element/solution/%E3%80%82%E4%B8%BB%E8%A6%81%E6%98%AF%E5%B0%86%E6%95%B0%E7%BB%84%E4%B8%AD%E9%97%B4%E5%85%83%E7%B4%A0%E4%B8%8E%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%AD%E9%97%B4%E5%85%83%E7%B4%A0%E5%88%9A%E5%A5%BD%E6%AF%94%E7%9B%B8%E9%82%BB%E7%9A%84%E5%85%83%E7%B4%A0%E9%83%BD%E5%A4%A7%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%8B%E6%A0%87%E5%B0%B1%E6%98%AF%E8%A6%81%E6%89%BE%E7%9A%84%E5%80%BC%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%AD%E9%97%B4%E5%85%83%E7%B4%A0%E6%AF%94%E5%B7%A6%E8%BE%B9%E5%85%83%E7%B4%A0%E5%A4%A7%EF%BC%8C%E8%AF%B4%E6%98%8E%E5%9C%A8%E5%BD%93%E5%89%8D%E8%8C%83%E5%9B%B4%E5%86%85%E4%B8%AD%E9%97%B4%E5%85%83%E7%B4%A0%E5%91%88%E4%B8%8A%E5%8D%87%E7%9A%84%E8%B6%8B%E5%8A%BF%EF%BC%8C%E6%89%80%E4%BB%A5%E8%A6%81%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%8F%B3%E4%BE%A7%E6%9F%A5%E6%89%BE%EF%BC%8C%E5%8F%8D%E4%B9%8B%EF%BC%8C%E5%88%99%E5%9C%A8%E5%B7%A6%E4%BE%A7%E8%BF%9B%E8%A1%8C%E6%9F%A5%E6%89%BE%E3%80%82%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B">https://leetcode.com/problems/find-peak-element/solution/。主要是将数组中间元素与相邻元素进行比较，如果中间元素刚好比相邻的元素都大，那么这个元素下标就是要找的值。如果中间元素比左边元素大，说明在当前范围内中间元素呈上升的趋势，所以要找目标值只能在右侧查找，反之，则在左侧进行查找。代码如下</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; nums[middle + <span class="number">1</span>] &amp;&amp; middle &gt; <span class="number">0</span> &amp;&amp; nums[middle] &gt; nums[middle - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; nums[middle + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只能是 left，不能是 right，因为 [2, 1] 时，right 是 -1</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.com/problems/find-peak-element/solution/">https://leetcode.com/problems/find-peak-element/solution/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-165:Compare Version Numbers</title>
    <url>/leetCode/leetCode-165/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个字符串，分别由数字和<code>.</code> 构成，表示两个版本号，要求对这两个版本号进行比较，如果第一个小于第二个，则返回 <code>-1</code>，如果第一个大于第二个，则返回 <code>1</code>，否则返回 <code>0</code>。题目链接：**<a href="https://leetcode.com/problems/compare-version-numbers/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：version1 &#x3D; “1.01”, version2 &#x3D; “1.001”</p>
<p>输出：0</p>
</blockquote>
<blockquote>
<p>输入：version1 &#x3D; “0.1”, version2 &#x3D; “1.1”</p>
<p>输出：-1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>直接用 <code>split</code> 函数对 <code>.</code> 进行分割，分别比较每个子字符串（将子字符串转成 10 进制数字进行比较，目的是取出前置 0 的干扰）。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String version1, String version2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        String[] v1s = version1.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        String[] v2s = version2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> v1s.length &lt; v2s.length ? v1s.length : v2s.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Integer.parseInt(v1s[i], <span class="number">10</span>) - Integer.parseInt(v2s[i], <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == v1s.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> v1s.length; i &lt; v2s.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Integer.parseInt(v2s[i], <span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span> (temp &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> v2s.length; i &lt; v1s.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Integer.parseInt(v1s[i], <span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span> (temp &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-166:Fraction to Recurring Decimal</title>
    <url>/leetCode/leetCode-166/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个整数，表示被除数和除数，要求用字符串表示他们的商。如果是无限循环小数，则用 <code>()</code> 将循环部分包起来。题目链接：**<a href="https://leetcode.com/problems/fraction-to-recurring-decimal/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：numerator &#x3D; 1, denominator &#x3D; 2</p>
<p>输出：”0.5”</p>
</blockquote>
<blockquote>
<p>输入：numerator &#x3D; 4, denominator &#x3D; 333</p>
<p>输出：”0.(012)”</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题主要是模拟除法的计算过程，对于每一轮过程，需要将余数乘10然后除以除数，与此同时，需要判断余数是否在之前的计算中出现过，如果出现，则表示这是一个无限循环小数，并且是从当前开始进行循环。</p>
<p>此题的另一个需要注意的地方是输入的数是 <code>int</code>的范围，可能存在负数，在计算过程中就可能出现超出 <code>int</code> 范围的数，因此需要将正两个数转成 <code>long</code> 类型，以方便计算，确保计算过程中不出错。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fractionToDecimal</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">signStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((numerator &lt; <span class="number">0</span> &amp;&amp; denominator &gt; <span class="number">0</span>) || (numerator &gt; <span class="number">0</span> &amp;&amp; denominator &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            signStr = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 考虑到 -2147483648 取绝对值后仍然为 -2147483648，此处用 long 类型表示</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">divisor</span> <span class="operator">=</span> Math.abs((<span class="type">long</span>) numerator);</span><br><span class="line">        <span class="type">long</span> <span class="variable">divider</span> <span class="operator">=</span> Math.abs((<span class="type">long</span>) denominator);</span><br><span class="line"></span><br><span class="line">        Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">intNum</span> <span class="operator">=</span> divisor / divider;</span><br><span class="line">        <span class="type">long</span> <span class="variable">modNum</span> <span class="operator">=</span> divisor % divider;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">decimalStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (modNum != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(modNum)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">loopStartIndex</span> <span class="operator">=</span> map.get(modNum);</span><br><span class="line">                <span class="keyword">return</span> signStr + intNum + <span class="string">&quot;.&quot;</span> + decimalStr.substring(<span class="number">0</span>, loopStartIndex) + <span class="string">&quot;(&quot;</span> + decimalStr.substring(loopStartIndex) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(modNum, index);</span><br><span class="line">            index++;</span><br><span class="line">            divisor = modNum * <span class="number">10</span>;</span><br><span class="line">            modNum = divisor % divider;</span><br><span class="line">            divisor = divisor / divider;</span><br><span class="line">            decimalStr.append(divisor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (decimalStr.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> signStr + intNum + <span class="string">&quot;.&quot;</span> + decimalStr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> signStr + intNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-167:Two Sum II - Input Array Is Sorted</title>
    <url>/leetCode/leetCode-167/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个非递减的整数数组，要求在 <code>O(1)</code> 的空间复杂度内找出数组中两个元素和等于目标数字的元素。题目链接：**<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9</p>
<p>输出：[1, 2]</p>
<p>解释：数组中 2 + 7 &#x3D; 9，对应数组下标 0 和 1，返回下标加一的值：1 和 2</p>
</blockquote>
<blockquote>
<p>输入：numbers &#x3D; [2,3,4], target &#x3D; 6</p>
<p>输出：[1, 3]</p>
<p>解释：数组中 2 + 4 &#x3D; 6，对应数组下标 0 和 2，返回下标加一的值：1 和 3</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题最简单的做法是用两个 for 循环进行遍历元素判断，但是这样无法利用数组非递减的排序特性。优化的做法是使用双指针，一个在数组开始地方，一个在数组结束地方，如果这两个指针所指元素和大于目标元素，则将右边的指针向左移动，如果这两个指针所指元素和小于目标元素，则将左边的指针向右移动。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[left] + numbers[right] == target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (numbers[left] + numbers[right] &gt; target) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-168:Excel Sheet Column Title</title>
    <url>/leetCode/leetCode-168/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数字，要求将其转换成Excel表格表头字母。其转换规则如下：<code>A -&gt; 1、B -&gt; 2、C -&gt; 3、... Z -&gt; 26、AA -&gt; 27、AB -&gt; 28、AC -&gt; 29...</code>。题目链接：<a href="https://leetcode.com/problems/excel-sheet-column-title"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：1</p>
<p>输出：A</p>
</blockquote>
<blockquote>
<p>输入：701</p>
<p>输出：ZY</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题是一道类似26进制的转换题，只是没有0，所以只要对26的倍数的值进行额外处理即可，其他操作方式跟进制转换一样。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">convertToTitle</span><span class="params">(<span class="type">int</span> columnNumber)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = &#123;<span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (columnNumber != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">modNum</span> <span class="operator">=</span> columnNumber % <span class="number">26</span>;</span><br><span class="line">            sb.append(chars[modNum]);</span><br><span class="line">            columnNumber /= <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">if</span> (modNum == <span class="number">0</span>) &#123;</span><br><span class="line">                columnNumber--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-171:Excel Sheet Column Number</title>
    <url>/leetCode/leetCode-171/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个 EXCEL 表格的表头，要求换算成对应的数字。<code>A -&gt; 1, B -&gt; 2, C -&gt; 3, ..., Z -&gt; 26, AA -&gt; 27, AB -&gt; 28, ...</code>。题目链接：<a href="https://leetcode.com/problems/excel-sheet-column-number"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：A</p>
<p>输出：1</p>
</blockquote>
<blockquote>
<p>输入：ZY</p>
<p>输出：701</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题与 <a href="https://guozhchun.github.io/leetCode/leetCode-168/">LeetCode-168</a> 是一种类似26进制的相互转换关系，直接按进制转换的方式进行求解即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">titleToNumber</span><span class="params">(String columnTitle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">factor</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> columnTitle.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            num += ((columnTitle.charAt(i) - <span class="string">&#x27;A&#x27;</span>) + <span class="number">1</span>) * factor;</span><br><span class="line">            factor = factor * <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-169:Majority Element</title>
    <url>/leetCode/leetCode-169/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数组，数组中有个元素的数量超过数组总数的一半，要求找出该元素。题目链接：<a href="https://leetcode.com/problems/majority-element/"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[3,2,3]</p>
<p>输出：3</p>
</blockquote>
<blockquote>
<p>输入：[2,2,1,1,1,2,2]</p>
<p>输出：2</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单的做法是用 <code>map</code> 存储数字及其出现的次数，然后找出最大次数的元素即是求解的答案。另一种简单的做法是排序，然后返回中位数（因为目标元素出现了至少 <code>n / 2</code>次）。但是这两种解决都不能在 <code>O(1)</code> 的空间复杂度、<code>O(n)</code> 的时间复杂度内求解。</p>
<p>更优化的做法是使用Boyer-Moore 算法：先用 <code>candidate</code> 表示候选的数，用 <code>count</code> 表示当前候选数剩余的数量，遍历数组，如果当前元素和候选数相同，则 <code>count + 1</code>，否则 <code>count - 1</code>，如果 <code>count</code> 为零，则将当前元素赋值给 <code>candidate</code>，遍历结束后，<code>count</code> 值一定大于0，此时 <code>candidate</code> 的值就是求解的值。此算法可以换另一种理解，因为求解的值的数量超过一半，所以剩下的元素和目标元素进行抵扣消极后，目标元素仍然有剩余。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == candidate) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    candidate = num;</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/">多数元素 - 多数元素 - 力扣（LeetCode）</a> </p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-17:Letter Combinations of a Phone Number</title>
    <url>/leetCode/leetCode-17/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串，字符串中只包含数字 2 ~ 9，每个数字对应的字母如下所示，要求将给定的数字的字符串转成对应的字母字符串组合。题目链接：**<a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">点我</a>**</p>
<blockquote>
<p>2：a、b、c</p>
<p>3：d、e、f</p>
<p>4：g、h、i</p>
<p>5：j、k、l</p>
<p>6：m、n、o</p>
<p>7：p、q、r、s</p>
<p>8：t、u、v</p>
<p>9：w、x、y、z</p>
</blockquote>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><p><em>注意：输出结果顺序可以不一致</em></p>
<blockquote>
<p>输入：”23”</p>
<p>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p>
</blockquote>
<blockquote>
<p>输入：”32”</p>
<p>输出：[“da”,”db”,”dc”,”ea”,”eb”,”ec”,”fa”,”fb”,”fc”]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题就是将各个数字对应的字母进行组合，输出所有可能的组合，直接进行模拟输出即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length() &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[][] digitLetters = &#123;&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">                                 &#123;<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;,</span><br><span class="line">                                 &#123;<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>&#125;,</span><br><span class="line">                                 &#123;<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>&#125;,</span><br><span class="line">                                 &#123;<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;,</span><br><span class="line">                                 &#123;<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>&#125;,</span><br><span class="line">                                 &#123;<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>&#125;,</span><br><span class="line">                                 &#123;<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> digits.charAt(<span class="number">0</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">char</span>[] letters = digitLetters[digit - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; letters.length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            combinations.add(String.valueOf(letters[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> digits.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            digit = digits.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            letters = digitLetters[digit - <span class="number">2</span>];</span><br><span class="line">            List&lt;String&gt; newCombinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String combination : combinations)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; letters.length; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    newCombinations.add(combination + letters[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            combinations = newCombinations;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-172:Factorial Trailing Zeroes</title>
    <url>/leetCode/leetCode-172/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数 <code>n</code>，要求找出 <code>n!</code>  的值末尾右多少个 <code>0</code>，题目链接：<a href="https://leetcode.com/problems/factorial-trailing-zeroes/"><strong>点我</strong></a> </p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：5</p>
<p>输出：1</p>
<p>解释：5! &#x3D; 5 * 4 * 3 * 2 * 1 &#x3D; 120，末尾有一个0</p>
</blockquote>
<blockquote>
<p>输入：2</p>
<p>输出：0</p>
</blockquote>
<h1 id="问题解放"><a href="#问题解放" class="headerlink" title="问题解放"></a>问题解放</h1><p>此题简单的做法按阶乘做法进行计算，中间数字如果末尾是0，则除10并计数加一，为了相乘的结果不溢出，中间需要进行模100的操作。但是这样的时间复杂度是 <code>O(n)</code>。可以进一步优化。</p>
<p>观察阶乘算法过程，我们可以知道，末尾的 <code>0</code> 是由 <code>2</code>  和 <code>5</code> （包括 2 和 5 的倍数）产生的，因此只需要找到 <code>1</code> 到 <code>n</code> 中 <code>2</code> 和 <code>5</code> 的质因子个数即可。由于 <code>2</code> 的质因数个数比 <code>5</code> 的多，因此只需要找到 <code>5</code> 的质因数的个数即可得到最终阶乘结果末尾0的个数。更进一步，观察阶乘的过程，<code>5</code> 质因数的产生是**每5个数产生一个5的质因子，每 5 * 5 个数会产生 2 个质因子，每 5 * 5 * 5 个数会产生 3 个质因子…**，因此，该求解过程变成，<code>n</code> 中被 <code>5</code> 整除的个数加上被 <code>5 * 5</code> 整除的个数加上被 <code>5 * 5 * 5</code> 整除的个数…</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = n / <span class="number">5</span>;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/factorial-trailing-zeroes/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-3/">详细通俗的思路分析 - 阶乘后的零 - 力扣（LeetCode）</a> </p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-173:Binary Search Tree Iterator</title>
    <url>/leetCode/leetCode-173/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉搜索树，要求按照中序输出的方式构造二叉搜索树的迭代器。其中 <code>next</code> 和 <code>hasNext</code> 函数的时间复杂度为 <code>O(1)</code>，空间复杂度为 <code>O(h), h 指树的高度</code>。题目链接：**<a href="https://leetcode.com/problems/binary-search-tree-iterator/">点我</a>**</p>
<span id="more"></span>

<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用一个栈来存储中序遍历过程中的左节点，调用 <code>next</code> 函数时，直接从栈中取出元素，同时判断该节点是否有右节点，如果有，则将该节点右子树的左节点遍历放入栈中。调用 <code>hasNext</code> 函数时，直接判断栈是否有空，为空则返回 false，否则返回 true。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        addStack(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        addStack(current.right);</span><br><span class="line">        <span class="keyword">return</span> current.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addStack</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-179:Largest Number</title>
    <url>/leetCode/leetCode-179/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整形数组，要求将数组中的元素进行拼接，返回拼接后的数字最大的值。题目链接：**<a href="https://leetcode.com/problems/largest-number">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [10,2]</p>
<p>输出：210</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [3,30,34,5,9]</p>
<p>输出：9534330</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>将数组中整数转成字符串，然后用字符串进行比较，如果 <code>a + b</code> 比 <code>b + a</code>， 则 <code>a</code> 放前面，<code>b</code> 放后面。排序后，将字符串进行连接就是最终的结果。需要注意的是前置 0 的情况，需要将前置 0 进行排除。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">largestNumber</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Arrays.stream(nums).mapToObj(String::valueOf).sorted((a, b) -&gt; (b + a).compareTo(a + b)).collect(Collectors.joining());</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; result.length() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.charAt(i) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; result.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                index = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.charAt(i) != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.substring(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-174:Dungeon Game</title>
    <url>/leetCode/leetCode-174/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二维矩阵，表示迷宫，每个格子表示一个房间，骑士在左上角，公主在右下角，每个单元格中的数字表示骑士进入房间需要消耗的健康值（用负数进行表示）或获得补充的健康值（用正数进行表示），骑士每次只能向右或向做进入下一个房间，骑士最小的健康值为 1，如果骑士健康值低于 1 ，则营救失败。要求找出骑士到达公主位置的路径中，骑士的初始健康值的最小值。题目链接：**<a href="https://leetcode-cn.com/problems/dungeon-game/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[-2,-3,3],[-5,-10,1],[10,30,-5]]</p>
<p>输出：7</p>
</blockquote>
<blockquote>
<p>输入：[[ 100 ]]</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此解法参考：<a href="https://leetcode-cn.com/problems/dungeon-game/solution/di-xia-cheng-you-xi-by-leetcode-solution/%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%98%AF%E4%BB%8E%E5%8F%B3%E4%B8%8B%E8%A7%92%E5%BC%80%E5%A7%8B%E5%90%91%E5%B7%A6%E4%B8%8A%E8%A7%92%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86%E8%AE%A1%E7%AE%97%E3%80%82%E7%94%A8">https://leetcode-cn.com/problems/dungeon-game/solution/di-xia-cheng-you-xi-by-leetcode-solution/，主要是使用动态规划，并且是从右下角开始向左上角进行遍历计算。用</a> <code>cost[i][j]</code> 表示从位置 <code>[i, j]</code> 到右下角位置所需的最小初始化的值，则 <code>cost[i][j]</code>  的取值是右边的路径和下边路径消耗健康值的最小值。在同一路径下，从上个房间到当前房间，计算当前房间所需的最小健康值的公式为：<code>max(1, 上个房间所需的最小初始化健康值 - 当前房间的值)</code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateMinimumHP</span><span class="params">(<span class="type">int</span>[][] dungeon)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> dungeon.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] cost = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">        cost[row - <span class="number">1</span>][col - <span class="number">1</span>] = calcCost(<span class="number">1</span>, dungeon[row - <span class="number">1</span>][col - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            cost[i][col - <span class="number">1</span>] = calcCost(cost[i + <span class="number">1</span>][col - <span class="number">1</span>], dungeon[i][col - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> col - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            cost[row - <span class="number">1</span>][j] = calcCost(cost[row - <span class="number">1</span>][j + <span class="number">1</span>], dungeon[row - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> col - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                cost[i][j] = Math.min(calcCost(cost[i + <span class="number">1</span>][j], dungeon[i][j]), calcCost(cost[i][j + <span class="number">1</span>], dungeon[i][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cost[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcCost</span><span class="params">(<span class="type">int</span> frontCost, <span class="type">int</span> currentCell)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentCell &gt;= frontCost)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> frontCost - currentCell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/dungeon-game/solution/di-xia-cheng-you-xi-by-leetcode-solution/">https://leetcode-cn.com/problems/dungeon-game/solution/di-xia-cheng-you-xi-by-leetcode-solution/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-18:4Sum</title>
    <url>/leetCode/leetCode-18/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个可能包含重复数字的数组和一个目标数字，要求找出所有由数组中的 4 个元素构成的集合的和等于目标数字。结果集中不能包含重复集合。例如：[1, -1, 0, 0]、[-1, 1, 0, 0]、[1, 0, 0, -1]、[1, 0, -1, 0]、[-1, 0, 0, 1]、[-1, 0, 1, 0]、[0, 0, 1, -1]、[0, 0, -1, 1]、[0, 1, 0, -1]、[0, -1, 0, 1]、[0, 1, -1, 0]、[0, -1, 1, 0] 这几个集合属于同一个集合，只需要输出其中一个即可。题目链接：**<a href="https://leetcode.com/problems/4sum/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1, 0, -1, 0, -2, 2]     0</p>
</blockquote>
<blockquote>
<p>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题跟 <a href="https://guozhchun.github.io/leetCode/leetCode-15/">leetCode-15:3sum</a> 类似，只是需要在其外层多加一层循环遍历另一个数字即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 跳过重复的数字，避免产生重复组合</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 跳过重复的数字，避免产生重复组合</span></span><br><span class="line">                <span class="keyword">if</span> (j != i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[start] + nums[end] == target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                        temp.addAll(Arrays.asList(nums[i], nums[j], nums[start], nums[end]));</span><br><span class="line">                        result.add(temp);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 跳过重复元素</span></span><br><span class="line">                        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[end] == nums[end - <span class="number">1</span>])</span><br><span class="line">                        &#123;</span><br><span class="line">                            end--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[start] == nums[start + <span class="number">1</span>])</span><br><span class="line">                        &#123;</span><br><span class="line">                            start++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        start++;</span><br><span class="line">                        end--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[start] + nums[end] &lt; target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        start++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        end--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-189:Rotate Array</title>
    <url>/leetCode/leetCode-189/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数组和一个非负整数 <code>k</code>，要求将数组末尾 <code>k</code> 个数字进行翻转到数组前面来。题目链接：**<a href="https://leetcode.com/problems/rotate-array/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3</p>
<p>输出：[5,6,7,1,2,3,4]</p>
<p>解释：第一次旋转后数组为：[7,1,2,3,4,5,6]</p>
<p>第二次旋转后数组为：[6,7,1,2,3,4,5]</p>
<p>第三次旋转后数组为：[5,6,7,1,2,3,4]</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2</p>
<p>输出：[3,99,-1,-100]</p>
<p>解释：第一次旋转后数组为：[99,-1,-100,3]</p>
<p>第二次旋转后数组为：[3,99,-1,-100]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>暴力解法，按照题意，一次挪动一个元素。此解法时间复杂度为 <code>O(nk)</code>，空间复杂度为 <code>O(1)</code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt;= <span class="number">1</span> || k % nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> k % nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[nums.length - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(nums, <span class="number">0</span>, nums, <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">            nums[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>利用额外空间存储变化的元素，将旋转的元素列表存储到临时数组中，然后将数组剩余的元素挪到目标位置，最后将临时数组的元素放入原先数组中。此种解法时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(k)</code>，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt;= <span class="number">1</span> || k % nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> k % nums.length;</span><br><span class="line">        <span class="type">int</span>[] temp = Arrays.copyOfRange(nums, nums.length - n, nums.length);</span><br><span class="line">        System.arraycopy(nums, <span class="number">0</span>, nums, n, nums.length - n);</span><br><span class="line">        System.arraycopy(temp, <span class="number">0</span>, nums, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>利用数组翻转的特性，先将数组全部倒序，然后对前 <code>k</code> 个元素进行倒序，再对数组后部分 <code>nums.length - k</code> 个元素进行倒序。此种解法的时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(1)</code>。此做法参考：<a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/">https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/</a></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt;= <span class="number">1</span> || k % nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> k % nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, n, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/">https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-187:Repeated DNA Sequences</title>
    <url>/leetCode/leetCode-187/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串，只包含 <code>A</code>、<code>C</code>、<code>G</code>、<code>T</code>  四个字母，要求找出所有长度是10的子字符串（不重复）且该子字符串出现次数大于1次。题目链接：**<a href="https://leetcode.com/problems/repeated-dna-sequences/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：s &#x3D; “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”</p>
<p>输出：[“AAAAACCCCC”,”CCCCCAAAAA”]</p>
</blockquote>
<blockquote>
<p>输入：s &#x3D; “AAAAAAAAAAAAA”</p>
<p>输出：[“AAAAAAAAAA”]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，直接用一个 set 来存储每个子字符串，每次取出新的字符串时判断是否已经存在，如果存在，则放入结果集中，否则继续取下一个子字符串。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findRepeatedDnaSequences</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= s.length() - <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> s.substring(i, i + <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(temp))</span><br><span class="line">            &#123;</span><br><span class="line">                result.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                set.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-19:Remove Nth Node From End of List</title>
    <url>/leetCode/leetCode-19/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表和一个正整数 n ，要求从链表中删除倒数第 n 个节点并返回链表的头节点。其中输入的 n 保证在合法范围内。要求只能遍历一次链表。题目链接：**<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3,4,5]    5</p>
<p>输出：[2,3,4,5]</p>
</blockquote>
<blockquote>
<p>输入：[1,2,3,4,5]    3</p>
<p>输出：[1,2,4,5]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用两个指针，其中一个指针先走，走到距离头节点 n 个节点时，后续该指针继续往后遍历时，另一个指针从头节点开始，随着第一个指针每次移动一个节点向后遍历直到链表尾节点。当第一个指针移动到尾节点时，如果与另一个指针的距离刚好是 n 个几点，则删除另一个指针后面的节点，否则说明 n 刚好等于链表的长度，即要删除的节点是首节点。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 题目保证输入 n 合法</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pLeft</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pRight</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pRight.next != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pRight = pRight.next;</span><br><span class="line">            gap++;</span><br><span class="line">            <span class="comment">// gap 等于 n 时，说明找到了两个指针的间距，此时只需要继续遍历直到链表最后一个元素</span></span><br><span class="line">            <span class="comment">// 此时 pLeft 指针所指的下一个节点就是要删除的“倒数第 n 个节点”</span></span><br><span class="line">            <span class="keyword">if</span> (gap &gt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                pLeft = pLeft.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果两个指针的间隔小于 n，说明 n 是链表的长度，也就是要删除第一个节点</span></span><br><span class="line">        <span class="comment">// 否则直接删除 pLeft指针的下一个节点即可</span></span><br><span class="line">        <span class="keyword">if</span> (gap &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;            </span><br><span class="line">            pLeft.next = pLeft.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-190:Reverse Bits</title>
    <url>/leetCode/leetCode-190/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个32位无符号整数，要求将其按位翻转。题目链接：<a href="https://leetcode.com/problems/reverse-bits"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：n &#x3D; 00000010100101000001111010011100</p>
<p>输出：00111001011110000010100101000000</p>
</blockquote>
<blockquote>
<p>输入：n &#x3D; 00000000000000000000000000000001</p>
<p>输出：10000000000000000000000000000000</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>按位运算倒置，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> n &amp; <span class="number">1</span>;</span><br><span class="line">            result = result | (last &lt;&lt; (<span class="number">31</span> - i));</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-191:Number of 1 Bits</title>
    <url>/leetCode/leetCode-191/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数，要求找出这个整数对应的二进制数字中包含 <code>1</code> 的个数。题目链接：<a href="https://leetcode.com/problems/number-of-1-bits"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：3</p>
<p>输出：2</p>
<p>解释：3对应的二进制为 00000000000000000000000000000011，总共有 2 个 1</p>
</blockquote>
<blockquote>
<p>输入：0</p>
<p>输出：0</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>对二进制数的每一位与 1 进行按位与运算，如果是 1 就累加，最终累计值就是答案。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-198:House Robber</title>
    <url>/leetCode/leetCode-198/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数组，表示每个房间的金钱。有一个小偷要从这些房间中将金钱偷走，但是不能偷相邻的两个房间。问小偷能偷走的最大金钱数。题目链接：**<a href="https://leetcode.com/problems/house-robber/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3,1]</p>
<p>输出：4</p>
<p>说明：小偷偷编号 0（金钱为1）和编号 2 （金钱为 3）的房间，总价值为 4</p>
</blockquote>
<blockquote>
<p>输入：[2,7,9,3,1]</p>
<p>输出：12</p>
<p>说明：小偷偷编号 0 （金钱为 2）、编号 2（金钱为 9）、编号为 4（金钱为 1）的房间，总价值 12</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用动态规划进行求解。假设用 <code>dp[i]</code> 表示从 <code>0</code> 到 <code>i</code> 的房间中，小偷能获取的最大价值。则动态转移方程为 <code>dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])</code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-199:Binary Tree Right Side View</title>
    <url>/leetCode/leetCode-199/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉树，要求按照从上到下的顺序输出其右视图的节点值。题目链接：**<a href="https://leetcode.com/problems/binary-tree-right-side-view/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入： [1,2,3,null,5,null,4]</p>
<p>输出：[1, 3, 4]</p>
<p>说明：</p>
<p> 1    &lt;—-</p>
<p>&#x2F; \</p>
<p>2 3  &lt;—-</p>
<p>\  \</p>
<p>5  4  &lt;—-</p>
</blockquote>
<blockquote>
<p>输入：[1,null,3]</p>
<p>输出：[1,3]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题就是求出树的每一层中最后节点。使用广搜的做法，从上到下依次输出每层的最后一个节点值即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextCount; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                current = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (current.left != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.add(current.left);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (current.right != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.add(current.right);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            nextCount = count;</span><br><span class="line">            <span class="keyword">if</span> (current != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result.add(current.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-2:Add Two Numbers</title>
    <url>/leetCode/leetCode-2/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个链表，链表中的数字是非负整数，表示一个整数的逆序，要求将这两个链表进行相加。其实就是模拟大数相加的过程。题目链接：**<a href="https://leetcode.com/problems/add-two-numbers/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入： (2 -&gt; 4 -&gt; 3)   (5 -&gt; 6 -&gt; 4)</p>
<p>输出： (7 -&gt; 0 -&gt; 8)</p>
</blockquote>
<blockquote>
<p>输入： (1)  (9 -&gt; 9 -&gt; 2)</p>
<p>输出： (0 -&gt; 0 -&gt; 3)</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="直接模拟相加"><a href="#直接模拟相加" class="headerlink" title="直接模拟相加"></a>直接模拟相加</h2><p>遍历链表，对遍历过的节点的值进行相加，再与前一个节点产生的进位进行相加，再将结果模10得到本新节点的值，将和除10得到新的进位与下个节点进行相加。代码实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRemainList</span><span class="params">(ListNode resultCurrent, ListNode p, <span class="type">int</span> prevCarryNum)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (prevCarryNum &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> prevCarryNum;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += p.val;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            resultCurrent.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            resultCurrent = resultCurrent.next;</span><br><span class="line">            prevCarryNum = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resultCurrent.next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> l1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> l2;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>((p1.val + p2.val) % <span class="number">10</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">resultCurrent</span> <span class="operator">=</span> result;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prevCarryNum</span> <span class="operator">=</span> (p1.val + p2.val) / <span class="number">10</span>;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> p1.val + p2.val + prevCarryNum;</span><br><span class="line">            resultCurrent.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            prevCarryNum = sum / <span class="number">10</span>;</span><br><span class="line">            resultCurrent = resultCurrent.next;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            handleRemainList(resultCurrent, p2, prevCarryNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            handleRemainList(resultCurrent, p1, prevCarryNum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码主要是同时遍历链表，遇到一个链表为空时，处理剩下的链表，代码有点啰嗦，leetcode上有更简便的写法，请参考**<a href="https://leetcode.com/articles/add-two-numbers/">这里</a>**</p>
<h2 id="使用BigInteger"><a href="#使用BigInteger" class="headerlink" title="使用BigInteger"></a>使用BigInteger</h2><p>本题是模拟两个大数相加的过程，在java库中已经有<code>BigInteger</code>类实现了大数相加、相减、相乘、相除等功能，因此可以直接使用这个类来完成本题。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getStringNumber</span><span class="params">(ListNode p)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(p.val);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">firstNum</span> <span class="operator">=</span> getStringNumber(l1);</span><br><span class="line">        <span class="type">String</span> <span class="variable">secondNum</span> <span class="operator">=</span> getStringNumber(l2);</span><br><span class="line">        </span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">firstBigNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(firstNum);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">secondBigNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(secondNum);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">sumString</span> <span class="operator">=</span> firstBigNum.add(secondBigNum).toString();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(sumString).reverse();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(Integer.valueOf(Character.toString(sb.charAt(<span class="number">0</span>))));</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sb.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            current.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(Integer.valueOf(Character.toString(sb.charAt(i))));</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于传入的参数是链表，且是逆序的数字，因此需要先将其转出正序整数的字符串，然后使用<code>BigInteger.add</code>进行相加。最后再将结果转出逆序的整数字符串，再构造链表返回。由于此过程涉及转换比较多，因此效率低下，不如第一种效率好。但是当传入参数为字符串并且要求返回的参数为字符串时，此种方法不比第一种差，且可读性较好。</p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-20:Valid Parentheses</title>
    <url>/leetCode/leetCode-20/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串，只包含<code>&#123;</code>、<code>&#125;</code>、<code>[</code>、<code>]</code>、<code>(</code>、<code>)</code>。要求判断这个字符串是否是符合括号的原则的。题目链接：**<a href="https://leetcode.com/problems/valid-parentheses/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：{[]}</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：{[}]</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用栈存储左括号，遍历字符串，每次遇到左括号时压入栈，遇到右括号时，查看栈顶的左括号是否与这个右括号对应，如果对应，则将栈顶元素出栈，否则说明字符串不合法。当字符串遍历结束时，如果栈中元素为空，说明字符串合法，否则字符串不合法。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;[&#x27;</span> || ch == <span class="string">&#x27;(&#x27;</span> || ch == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(Character.valueOf(ch));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">char</span> <span class="variable">topCh</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topCh == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topCh == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topCh == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-200:Number of Islands</title>
    <url>/leetCode/leetCode-200/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二维数组，其中 <code>0</code> 表示水，<code>1</code> 表示陆地，要求找出岛屿（<code>1</code>相连但是被 <code>0</code> 包围）的数量。题目链接：**<a href="https://leetcode-cn.com/problems/number-of-islands/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<p>[<br>[‘1’,’1’,’1’,’1’,’0’],<br>[‘1’,’1’,’0’,’1’,’0’],<br>[‘1’,’1’,’0’,’0’,’0’],<br>[‘0’,’0’,’0’,’0’,’0’]<br>]</p>
<p>输出：1</p>
</blockquote>
<blockquote>
<p>输入：</p>
<p>[<br>[‘1’,’1’,’0’,’0’,’0’],<br>[‘1’,’1’,’0’,’0’,’0’],<br>[‘0’,’0’,’1’,’0’,’0’],<br>[‘0’,’0’,’0’,’1’,’1’]<br>]</p>
<p>输出：3</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>循环遍历每个元素，如果遇到 <code>1</code> ，则使用广搜算法，将当前与这个 <code>1</code> 相连的所有 <code>1</code> 都变成 <code>2</code>，同时记录更新当前岛屿数量加一，遍历结束后，最终累计的结果就是岛屿的数量。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    travelIsland(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">travelIsland</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] dx = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dy = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] begin = &#123;i, j&#125;;</span><br><span class="line">        queue.offer(begin);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span>[] current = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; dx.length; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span>[] next = &#123;current[<span class="number">0</span>] + dx[k], current[<span class="number">1</span>] + dy[k]&#125;;</span><br><span class="line">                <span class="keyword">if</span> (next[<span class="number">0</span>] &gt;=<span class="number">0</span> &amp;&amp; next[<span class="number">0</span>] &lt; grid.length &amp;&amp; next[<span class="number">1</span>] &gt;= <span class="number">0</span> &amp;&amp; next[<span class="number">1</span>] &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[next[<span class="number">0</span>]][next[<span class="number">1</span>]] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    grid[next[<span class="number">0</span>]][next[<span class="number">1</span>]] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                    queue.offer(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-201:Bitwise AND of Numbers Range</title>
    <url>/leetCode/leetCode-201/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个整数，第一个数小于第二个数，要求求出这两个数（包含）之间的所有数的二进制数 “与” 运算后的结果。题目链接：**<a href="https://leetcode.com/problems/bitwise-and-of-numbers-range/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[5, 7]</p>
<p>输出：4</p>
<p>说明：5  的二进制数是 101，6 的二进制数是110，7 的二进制数是 111，三个二进制数求与运算后是 100，对应 10 进制数 4</p>
</blockquote>
<blockquote>
<p>输入：[0, 1]</p>
<p>输出：0</p>
<p>说明：0 的二进制数是 0，1 的二进制数是 1，两者求与运算后是 0，对应 10 进制数 0</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题参考 <a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/shu-zi-fan-wei-an-wei-yu-by-leetcode-solution/">https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/shu-zi-fan-wei-an-wei-yu-by-leetcode-solution/</a>。从两个数围起来的范围数进行分析，对这些数进行求与运算，实际上是求边界数的二进制数的公共前缀。因此只需要将边界值的数向右移位直到两者相等，再向左移动对应的位数即可得到答案。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (m &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            m = m &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> m &lt;&lt; count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/shu-zi-fan-wei-an-wei-yu-by-leetcode-solution/">https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/shu-zi-fan-wei-an-wei-yu-by-leetcode-solution/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-202:Happy Number</title>
    <url>/leetCode/leetCode-202/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个正整数，要求判断其是不是 “快乐数”，”快乐数“ 定义是：求数字的每一位数的平方和得到一个新数，判断这个数是否是 <code>1</code>，不是的话重复上述过程，直到数字是 <code>1</code>，或是无线循环。最终如果能得到数字 <code>1</code>， 则说明这个数是 “快乐数”，否则不是。题目链接：<a href="https://leetcode.com/problems/happy-number"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：19</p>
<p>输出：true</p>
<p>解释：</p>
<p>1 * 1 + 9 * 9 &#x3D; 82</p>
<p>8 * 8 + 2 * 2 &#x3D; 68</p>
<p>6 * 6 + 8 * 8 &#x3D; 100</p>
<p>1 * 1 + 0 * 0 + 0 * 0 &#x3D; 1</p>
</blockquote>
<blockquote>
<p>输入：2</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，直接按照题目意思进行模拟计算判断即可，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!str.equals(<span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> str.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                sum += num * num;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            str = String.valueOf(sum);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(str)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            set.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-203:Remove Linked List Elements</title>
    <url>/leetCode/leetCode-203/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表和一个数字，要求删除链表中出现该数字的节点。题目链接：**<a href="https://leetcode.com/problems/remove-linked-list-elements/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3,4,1,2,3]   3</p>
<p>输出：[1,2,4,1,2]</p>
</blockquote>
<blockquote>
<p>输入：[1,1]   1</p>
<p>输出：[]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>直接遍历遍历，删除匹配的节点即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.next.val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                p.next = p.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-204:Count Primes</title>
    <url>/leetCode/leetCode-204/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数，要求找出比这个数小的质数的个数。题目链接：**<a href="https://leetcode.com/problems/count-primes/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：10</p>
<p>输出：4</p>
<p>解释：质数为：2，3，5，7</p>
</blockquote>
<blockquote>
<p>输入：1</p>
<p>输出：0</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题最简单的解法是遍历每个数，分别对每个数进行判断，但是这样时间复杂度太高。优化一点的做法是，遍历前 <code>sqrt(n)</code> 的数，对于每个质数，分别 <code>*2、*3、*4...</code> 得到新的数，这些数绝对是合数，后续不用再判断，再优化一点的做法是，对每个质数 <code>a</code>，从 <code>a * a</code> 开始计算，因为 <code>a * 2、 a * 3、 a * 4、 a * 5、 a * (a - 1)</code> 都在之前的 <code>2、3、4、5、...、a - 1</code>中计算过。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">boolean</span>[] isPrimes = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            isPrimes[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrimes[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; i * j &lt; n; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    isPrimes[i * j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrimes[i])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-205:Isomorphic Strings</title>
    <url>/leetCode/leetCode-205/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个字符串，要求判断两个字符串是否是同构字符串。同构字符串的定义：可以按照某种规则将一个字符串中所有字符映射成另一个字符串的字符。每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身 。题目链接：<a href="https://leetcode.com/problems/isomorphic-strings"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：s &#x3D; “paper”, t &#x3D; “title”</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：s &#x3D; “badc”, t &#x3D; “baba”</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题关键在于读懂题意，按照题目意思维护两个字符串的映射规则，只要两个字符串中映射规则中不重复即可，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] lefts = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="type">char</span>[] rights = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="type">boolean</span>[] leftUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="type">boolean</span>[] rightUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftUsed[s.charAt(i)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lefts[s.charAt(i)] != t.charAt(i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightUsed[t.charAt(i)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rights[t.charAt(i)] != s.charAt(i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lefts[s.charAt(i)] = t.charAt(i);</span><br><span class="line">                rights[t.charAt(i)] = s.charAt(i);</span><br><span class="line">                leftUsed[s.charAt(i)] = <span class="literal">true</span>;</span><br><span class="line">                rightUsed[t.charAt(i)] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-208:Implement Trie (Prefix Tree)</title>
    <url>/leetCode/leetCode-208/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个前缀树的数据结构和函数定义，要求实现函数内容。题目链接：**<a href="https://leetcode.com/problems/implement-trie-prefix-tree/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<p>[“Trie”, “insert”, “search”, “search”, “startsWith”, “insert”, “search”] </p>
<p>[[], [“apple”], [“apple”], [“app”], [“app”], [“app”], [“app”]]</p>
<p>输出：[null, null, true, false, true, null, true]</p>
<p>解释：</p>
<p>Trie trie &#x3D; new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   &#x2F;&#x2F; return True<br>trie.search(“app”);     &#x2F;&#x2F; return False<br>trie.startsWith(“app”); &#x2F;&#x2F; return True<br>trie.insert(“app”);<br>trie.search(“app”);     &#x2F;&#x2F; return True</p>
</blockquote>
<blockquote>
<p>输入：</p>
<p>[“Trie”, “insert”, “search”,] </p>
<p>[[], [“aaa”], [“bbb”]]</p>
<p>输出：[null, null, false]</p>
<p>解释：</p>
<p>Trie trie &#x3D; new Trie();<br>trie.insert(“aaa”);<br>trie.search(“bbb”);     &#x2F;&#x2F; return False</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>新建一个数据结构用于表示前缀树中的节点，由于题目中有说明字符串只包含 26 个小写字母，因此可以数组来表示孩子节点的数量。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        Node[] children;</span><br><span class="line">        <span class="type">boolean</span> isEnd;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.ch = ch;</span><br><span class="line">            children = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : word.toCharArray())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (current.children[index] == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                current.children[index] = <span class="keyword">new</span> <span class="title class_">Node</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        current.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : word.toCharArray())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (current.children[index] == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.children[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> current.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : prefix.toCharArray())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (current.children[index] == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.children[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-207:Course Schedule</title>
    <url>/leetCode/leetCode-207/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出一个数字表示课程的数量，再给出一个二维数组表示课程的依赖关系，如 [1, 2] 表示课程 1 必须在课程 2 之前完成。要求判断给出的课程数量和课程的依赖关系，能否顺利学完所有的课程。题目链接：**<a href="https://leetcode.com/problems/course-schedule/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：2, [[1, 0]] </p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：2, [[0, 1], [1, 0]]</p>
<p>输出：false</p>
<p>解释：[0, 1] 表示课程 0 需要在课程 1 之前完成学习，[1, 0] 表示课程 1 需要在课程 0 之前完成学习，这使得课程 0 和课程 1 之间有个依赖循环，所以无法正常顺利完成所有的课程学习。</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>课程排序问题是典型的拓扑排序问题的应用，所以这题直接使用拓扑排序进行求解即可。</p>
<h2 id="普通版本"><a href="#普通版本" class="headerlink" title="普通版本"></a>普通版本</h2><p>使用一个 map 来存储节点和这个节点的前向节点（依赖的节点），后续进行拓扑排序时，在队列中每取出一个入度为 0 的节点，则从 map 中的 value 值依赖列表中删除课程值，如果删除后依赖列表为空，则表明此时这个 map 的 key 值代表的课程没有其他依赖的课程，可以取出放入队列中（即，从 map 中删除此元素），在遍历完所有入度是 0 的节点后，如果 map 中仍然存在元素，则表明有课程存在循环依赖的关系，不能正常完成所有课程的学习。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算每个节点的入度</span></span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; nodeIn = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prerequisites.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">from</span> <span class="operator">=</span> prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">to</span> <span class="operator">=</span> prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            List&lt;Integer&gt; inList = nodeIn.getOrDefault(to, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">            inList.add(from);</span><br><span class="line">            nodeIn.put(to, inList);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将入度为零的节点放入课程列表中</span></span><br><span class="line">        List&lt;Integer&gt; courseList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">course</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">if</span> (!nodeIn.containsKey(course))</span><br><span class="line">            &#123;</span><br><span class="line">                courseList.add(course);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 依次取出课程列表中课程，并取出其他课程对此课程的依赖</span></span><br><span class="line">        <span class="keyword">while</span> (!courseList.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">course</span> <span class="operator">=</span> courseList.remove(<span class="number">0</span>);</span><br><span class="line">            Iterator&lt;Map.Entry&lt;Integer, List&lt;Integer&gt;&gt;&gt; iterator = nodeIn.entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">            &#123;</span><br><span class="line">                Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry = iterator.next();</span><br><span class="line">                List&lt;Integer&gt; inList = entry.getValue();</span><br><span class="line">                inList.remove(course);   <span class="comment">// 去除其他课程对当前课程的依赖</span></span><br><span class="line">                <span class="comment">// 如果其他课程没有任何依赖的课程，则将其加入课程列表中，同时删除其依赖关系</span></span><br><span class="line">                <span class="keyword">if</span> (inList.isEmpty())</span><br><span class="line">                &#123;</span><br><span class="line">                    courseList.add(entry.getKey());</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在遍历完课程列表后，如果还存在依赖关系，则说明存在循环依赖</span></span><br><span class="line">        <span class="keyword">return</span> nodeIn.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进版本"><a href="#改进版本" class="headerlink" title="改进版本"></a>改进版本</h2><p>此版本是对上一个版本的改进。主要是直接用一个数组来表示各个课程的节点入度数，替换掉 map 的表示方式。同时在进行拓扑排序时，由原先对 map 的结构遍历和更新改成对数组的遍历和更新。此外，再用一个变量来表示已经排序的元素，当所有入度为 0 的节点遍历结束后，如果已经排序的元素数量和课程的总数相同，则说明可以正常顺利完成所有课程的学习，否则，存在循环依赖，不能完成所有课程的学习。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算课程的入度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prerequisites.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            indegree[prerequisites[i][<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将入度为零的节点放入课程列表中</span></span><br><span class="line">        List&lt;Integer&gt; courseList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                courseList.add((Integer)i);</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 依次取出课程列表中课程，并取出其他课程对此课程的依赖</span></span><br><span class="line">        <span class="keyword">while</span> (!courseList.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">course</span> <span class="operator">=</span> courseList.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prerequisites.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 其他课程依赖此课程，则删除此依赖关系</span></span><br><span class="line">                <span class="keyword">if</span> (prerequisites[i][<span class="number">0</span>] == course)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 依赖当前课程的其他课程的入度减一</span></span><br><span class="line">                    indegree[prerequisites[i][<span class="number">1</span>]]--;</span><br><span class="line">                    <span class="comment">// 入度为零，表明不需要依赖其他课程了，将此课程取出放入课程列表中</span></span><br><span class="line">                    <span class="keyword">if</span> (indegree[prerequisites[i][<span class="number">1</span>]] == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        courseList.add(prerequisites[i][<span class="number">1</span>]);</span><br><span class="line">                        num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-206:Reverse Linked List</title>
    <url>/leetCode/leetCode-206/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表，要求将其反转。题目链接：**<a href="https://leetcode.com/problems/reverse-linked-list/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>输出：5-&gt;4-&gt;3-&gt;2-&gt;1</p>
</blockquote>
<blockquote>
<p>输入：1</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题很明确，也没什么算法，直接反转即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">        <span class="keyword">while</span> (head.next != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">            dummy.next = head.next;</span><br><span class="line">            head.next = head.next.next;</span><br><span class="line">            dummy.next.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-209:Minimum Size Subarray Sum</title>
    <url>/leetCode/leetCode-209/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个正整数数组和一个正整数，要求找出数组中连续子数组的元素和等于目标元素，返回最小的子数组的元素个数。如果没有满足要求，则返回 0 。题目链接：**<a href="https://leetcode.com/problems/minimum-size-subarray-sum/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</p>
<p>输出：2</p>
</blockquote>
<blockquote>
<p>输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]</p>
<p>输出：0</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用首尾两个指针表示子数组的范围。首先，移动右边指针直到子数组元素和大于等于目标数字，计算此刻的子数组元素个数，然后移动左边的指针，直至子数组元素和小于目标数字。在这个过程中，不断更新最小子数组的元素个数。待遍历结束，判断是否有满足要求的子数组，如果有，则返回计算出来的最小子数组元素个数，如果没有，则返回 0。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; nums.length)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            end++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                count = Math.min(count, end - start);</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count == Integer.MAX_VALUE ? <span class="number">0</span> : count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-21:Merge Two Sorted Lists</title>
    <url>/leetCode/leetCode-21/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个有序链表，要求将其合并成一个有序链表返回。题目链接：**<a href="https://leetcode.com/problems/merge-two-sorted-lists/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</p>
<p>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
</blockquote>
<blockquote>
<p>输入：1-&gt;2-&gt;3-&gt;4,   1</p>
<p>输出：1-&gt;1-&gt;2-&gt;3-&gt;4</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>直接用归并法即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> l1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (p1.val &gt; p2.val)</span><br><span class="line">        &#123;</span><br><span class="line">            p1 = l2;</span><br><span class="line">            p2 = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> p1;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (p1.next != <span class="literal">null</span> &amp;&amp; p1.next.val &lt; p2.val)</span><br><span class="line">            &#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> p1.next;</span><br><span class="line">            p1.next = p2;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-210:Course Schedule II</title>
    <url>/leetCode/leetCode-210/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出一个数字表示课程的数量，再给出一个二维数组表示课程的依赖关系，如 [0, 1] 表示课程 1 必须在课程 0 之前完成。要求找出课程的先后学习顺序，如果给出的课程依赖关系不能存在循环依赖，则返回空数组。题目链接：**<a href="https://leetcode.com/problems/course-schedule-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：2, [[1, 0]] </p>
<p>输出：[0,1]</p>
</blockquote>
<blockquote>
<p>输入：2, [[0, 1], [1, 0]]</p>
<p>输出：[]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>直接用拓扑排序进行求解，将每次的学习的课程保存在数组中，最后判断是否存在循环依赖关系，如果存在则返回空数组，否则返回结果数组。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] nodeIns = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prerequisites.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nodeIns[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; courses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeIns[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                courses.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] studyCoures = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!courses.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">course</span> <span class="operator">=</span> courses.get(<span class="number">0</span>);</span><br><span class="line">            courses.remove(<span class="number">0</span>);</span><br><span class="line">            studyCoures[index] = course;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prerequisites.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (prerequisites[i][<span class="number">1</span>] == course)</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeIns[prerequisites[i][<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="keyword">if</span> (nodeIns[prerequisites[i][<span class="number">0</span>]] == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        courses.add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (index == numCourses)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> studyCoures;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-211:Design Add and Search Words Data Structure</title>
    <url>/leetCode/leetCode-211/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>要求设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配。其中添加新单词时，新单词只包含小写字母。查找字符串时，字符串只包含 <code>.</code> 和小写字母，<code>.</code> 表示匹配任意一个字符。题目链接：**<a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<p>[“WordDictionary”,”addWord”,”addWord”,”addWord”,”search”,”search”,”search”,”search”]<br>[[],[“bad”],[“dad”],[“mad”],[“pad”],[“bad”],[“.ad”],[“b..”]]</p>
<p>输出：</p>
<p>[null,null,null,null,false,true,true,true]</p>
<p>解释：</p>
<p>WordDictionary wordDictionary &#x3D; new WordDictionary();<br>wordDictionary.addWord(“bad”);<br>wordDictionary.addWord(“dad”);<br>wordDictionary.addWord(“mad”);<br>wordDictionary.search(“pad”); &#x2F;&#x2F; return False<br>wordDictionary.search(“bad”); &#x2F;&#x2F; return True<br>wordDictionary.search(“.ad”); &#x2F;&#x2F; return True<br>wordDictionary.search(“b..”); &#x2F;&#x2F; return True</p>
</blockquote>
<blockquote>
<p>输入：</p>
<p>[“WordDictionary”,”addWord”,”addWord”,”search”,”search”,”search”,”search”,”search”,”search”]<br>[[],[“a”],[“a”],[“.”],[“a”],[“aa”],[“a”],[“.a”],[“a.”]]</p>
<p>输出：</p>
<p>[null,null,null,true,true,false,true,false,false]</p>
<p>解释：</p>
<p>WordDictionary wordDictionary &#x3D; new WordDictionary();<br>wordDictionary.addWord(“a”);<br>wordDictionary.addWord(“a”);<br>wordDictionary.search(“.”); &#x2F;&#x2F; return True<br>wordDictionary.search(“a”); &#x2F;&#x2F; return True<br>wordDictionary.search(“aa”); &#x2F;&#x2F; return False<br>wordDictionary.search(“a”); &#x2F;&#x2F; return True<br>wordDictionary.search(“.a”); &#x2F;&#x2F; return False<br>wordDictionary.search(“a.”); &#x2F;&#x2F; return False</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用前缀树，用单词的每个字母进行构造字典树。在查找时，判断当前字符是否是 <code>.</code> ，如果是，则判断是否存在字符，如果有则继续，否则返回 false。此过程最好使用递归。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node[] children = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEnd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">char</span> ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.ch = ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WordDictionary</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : word.toCharArray())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (current.children[index] == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                current.children[index] = <span class="keyword">new</span> <span class="title class_">Node</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            current = current.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        current.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> search(word.toCharArray(), <span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">char</span>[] words, <span class="type">int</span> startIndex, Node startNode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> startNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; words.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (words[i] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current.children[j] != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">temp</span> <span class="operator">=</span> search(words, i + <span class="number">1</span>, current.children[j]);</span><br><span class="line">                        <span class="keyword">if</span> (temp)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> words[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (current.children[index] == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                current = current.children[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> current.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj.addWord(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-212:Word Search II</title>
    <url>/leetCode/leetCode-212/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个由字母构成的二维数组和一个单词列表，要求找出所有在二维数组中经过上下左右查找拼接而成的单词并且这个单词出现在单词列表中。查找过程中每个单词的每个字母仅能使用一次单元格，且每次仅能从一个单元格的上一个格子、下一个格子、左一个格子、右一个格子中进行查找。题目链接：**<a href="https://leetcode.com/problems/word-search-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：board &#x3D; [[“o”,”a”,”a”,”n”],[“e”,”t”,”a”,”e”],[“i”,”h”,”k”,”r”],[“i”,”f”,”l”,”v”]], words &#x3D; [“oath”,”pea”,”eat”,”rain”]</p>
<p>输出：[“eat”,”oath”]</p>
</blockquote>
<blockquote>
<p>输入：board &#x3D; [[“a”,”b”],[“c”,”d”]], words &#x3D; [“abcb”]</p>
<p>输出：[]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用单词列表中的单词构建字典树，然后遍历二维数组，判断当前单元格是否存在字典树中，如果存在，则继续遍历，如果不存在，则结束此次遍历。对树的每个节点，判断是否是单词的最后一个字母，如果是，则放入结果集中。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node[] children;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="type">boolean</span> isEnd;</span><br><span class="line">        String word;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.ch = ch;</span><br><span class="line">            children = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">            word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> buildTree(words);</span><br><span class="line">        Set&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[][] isUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                find(board, i, j, root, result, isUsed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j, Node root, Set&lt;String&gt; result, <span class="type">boolean</span>[][] isUsed)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.isEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(root.word);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length || isUsed[i][j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> board[i][j] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.children[index] == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isUsed[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        find(board, i + <span class="number">1</span>, j, root.children[index], result, isUsed);</span><br><span class="line">        find(board, i - <span class="number">1</span>, j, root.children[index], result, isUsed);</span><br><span class="line">        find(board, i, j + <span class="number">1</span>, root.children[index], result, isUsed);</span><br><span class="line">        find(board, i, j - <span class="number">1</span>, root.children[index], result, isUsed);</span><br><span class="line"></span><br><span class="line">        isUsed[i][j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">buildTree</span><span class="params">(String[] words)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word : words)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (current.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    current.children[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">Node</span>(ch);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                current = current.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            current.isEnd = <span class="literal">true</span>;</span><br><span class="line">            current.word = word;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-213:House Robber II</title>
    <url>/leetCode/leetCode-213/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个首尾相连的环形数组，表示每个房间的金钱。有一个小偷要从这些房间中将金钱偷走，但是不能偷相邻的两个房间。问小偷能偷走的最大金钱数。题目链接：**<a href="https://leetcode.com/problems/house-robber-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[2,3,2]</p>
<p>输出：3</p>
<p>说明：小偷偷编号为 1（金钱为 3）的房间，总价值为 3。不能偷编号 0（金钱为2）和编号 2 （金钱为 2）的房间，因为这两个房间是相邻的</p>
</blockquote>
<blockquote>
<p>输入：[1,2,3,1]</p>
<p>输出：4</p>
<p>说明：小偷偷编号 0（金钱为1）和编号 2 （金钱为 3）的房间，总价值为 4</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题跟 <a href="https://guozhchun.github.io/leetCode/leetCode-198/">LeetCode-198</a> 类似，只不过多了个条件，数组是首尾相连的。所以可以基于 LeetCode-198 的基础，分别作出两种假设，第一种是第一个房间不偷，那最后一个房间就可以偷，此时可以用 LeetCode-198 的解法求出小偷能偷到的最大价值。第二种是第一个房间偷，那最后一个房间不偷，此时同样用 LeetCode-198  的解法求出小偷能偷到的最大价值。将这两种方式下的值进行比较，返回其最大值，就是本题的解。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个不偷</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个偷</span></span><br><span class="line">        <span class="type">int</span>[] dp2 = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp2[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp2[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp2[i] = Math.max(dp2[i - <span class="number">2</span>] + nums[i], dp2[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[nums.length - <span class="number">1</span>], dp2[nums.length - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-214:Shortest Palindrome</title>
    <url>/leetCode/leetCode-214/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给到一个字符串，在字符串前面添加字符，可以使字符串形成回文字符串，要求找出最小的回文字符串。题目链接：**<a href="https://leetcode.com/problems/shortest-palindrome/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：”aacecaaa”</p>
<p>输出：”aaacecaaa”</p>
</blockquote>
<blockquote>
<p>输入：”aa”</p>
<p>输出：”aa”</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解法一：双指针（超时）"><a href="#解法一：双指针（超时）" class="headerlink" title="解法一：双指针（超时）"></a>解法一：双指针（超时）</h2><p>使用首尾两个指针，如果首指针的字符不等于尾指针的字符，则尾指针向后移动首指针的长度，同时将尾指针的字符加到结果集中，然后将首指针恢复为0。如果首尾指针的字符相等，则首指针向右移动一位，尾指针向左移动一位。重复上述过程直到首尾指针相遇。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestPalindrome</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j))</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j = j + i;</span><br><span class="line">                sb.append(s.charAt(j));</span><br><span class="line">                j--;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.append(s).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此解法虽然比较简单，但是超时了。</p>
<h2 id="解法二：KMP（通过）"><a href="#解法二：KMP（通过）" class="headerlink" title="解法二：KMP（通过）"></a>解法二：KMP（通过）</h2><p>此解法参考：<a href="https://leetcode-cn.com/problems/shortest-palindrome/solution/zui-duan-hui-wen-chuan-by-leetcode-solution/%E3%80%82">https://leetcode-cn.com/problems/shortest-palindrome/solution/zui-duan-hui-wen-chuan-by-leetcode-solution/。</a></p>
<p>要找最短的回文字符串，只需要在原有的字符串中找出最长的前缀回文字符串（比如：<code>abaabaceaba</code> 的最长前缀回文字符串是 <code>abaaba</code>），然后进行分割，将后半部分的字符串进行倒序加到原先字符串，即可得到最短的回文字符串。因此，此题就变成了查找字符串中的最长前缀回文字符串。更进一步，如果将原有字符串进行反序，然后将这两个字符串进行匹配，那么当反序的字符串遍历到结束时，原有字符串匹配到的位置进行分割，前面的字符串就是最长的前缀回文字符串。字符串的匹配过程中可以借助 KMP 算法的思想进行求解。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestPalindrome</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">point</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (point &gt; <span class="number">0</span> &amp;&amp; s.charAt(point) != s.charAt(i))</span><br><span class="line">            &#123;</span><br><span class="line">                point = next[point - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(point) == s.charAt(i))</span><br><span class="line">            &#123;</span><br><span class="line">                next[i] = point + <span class="number">1</span>;</span><br><span class="line">                point++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j))</span><br><span class="line">            &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j))</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(s.substring(j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(s.substring(j));</span><br><span class="line">        &#125;</span><br><span class="line">        sb.reverse().append(s);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/shortest-palindrome/solution/zui-duan-hui-wen-chuan-by-leetcode-solution/">https://leetcode-cn.com/problems/shortest-palindrome/solution/zui-duan-hui-wen-chuan-by-leetcode-solution/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-215:Kth Largest Element in an Array</title>
    <url>/leetCode/leetCode-215/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组和数字 k，要求找出数组中第 k 大的数字。题目链接：**<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [3,2,1,5,6,4], k &#x3D; 2</p>
<p>输出：5</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [3,2,3,1,2,4,5,5,6], k &#x3D; 4</p>
<p>输出：4</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用快排的思想进行求解，先挑选一个数，对数组进行划分，大于等于这个数的放数组右边，小于这个数的放数组左边，然后看右边的数量是否大于 k，如果大于 k，则在右边的子数组中继续上述过程的查找，如果小于 k，则在左边的子数组中继续上述过程查找，如果等于 k，则说明当前这个值就是要求解的值。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthNum(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findKthNum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> k)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> to;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> from;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> to;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[start] &lt; nums[index])</span><br><span class="line">            &#123;</span><br><span class="line">                start++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[end] &gt;= nums[index])</span><br><span class="line">            &#123;</span><br><span class="line">                end--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(nums, start, end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[start] &gt; nums[index])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums, start, index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (to - start + <span class="number">1</span> == k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[start];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (to - start + <span class="number">1</span> &gt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> findKthNum(nums, start + <span class="number">1</span>, to, k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findKthNum(nums, from, start - <span class="number">1</span>, k - to + start - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-216:Combination Sum III</title>
    <url>/leetCode/leetCode-216/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数字 <code>k</code> 和数字 <code>n</code>，要求找出 <code>k</code> 个数字的和为 <code>n</code> 的组合，其中组合中的数字为 <code>1</code> 到 <code>9</code>，且不能出现重复。题目链接：**<a href="https://leetcode.com/problems/combination-sum-iii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：k &#x3D; 3, n &#x3D; 9</p>
<p>输出：[[1,2,6],[1,3,5],[2,3,4]]</p>
</blockquote>
<blockquote>
<p>输入：k &#x3D; 4，n &#x3D; 3</p>
<p>输出：[]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，直接使用回溯算法进行求解即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            nums.add(i);</span><br><span class="line">            search(result, nums, i, k, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; nums, <span class="type">int</span> sum, <span class="type">int</span> k, <span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == n)</span><br><span class="line">            &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nums));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.get(nums.size() - <span class="number">1</span>) + <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.add(i);</span><br><span class="line">            search(result, nums, sum + i, k, n);</span><br><span class="line">            nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-217:Contains Duplicate</title>
    <url>/leetCode/leetCode-217/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，要求判断数组中是否包含重复数字，存在重复数字返回 <code>true</code>，否则返回 <code>false</code>。题目链接：**<a href="https://leetcode.com/problems/contains-duplicate/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [1,2,3,1]</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [1,2,3]</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，直接用 <code>set</code> 进行判断即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(num))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-218:The Skyline Problem</title>
    <url>/leetCode/leetCode-218/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二维数组，表示一组建筑的坐标，每个一维数组元素都是一个包含 3 个元素的数组，分别表示建筑的左坐标、建筑的右坐标、建筑的高度。要求列出这群建筑的 “天际线”。</p>
<p>天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],…] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>
<p>题目链接：**<a href="https://leetcode.com/problems/the-skyline-problem/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]</p>
<p>输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]</p>
<p>解释：<img src="https://assets.leetcode.com/uploads/2020/12/01/merged.jpg" alt="image"></p>
</blockquote>
<blockquote>
<p>输入：[[0,2,3],[2,5,3]]</p>
<p>输出：[[0,3],[5,0]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题主要参考：<a href="https://leetcode.cn/problems/the-skyline-problem/solution/gong-shui-san-xie-sao-miao-xian-suan-fa-0z6xc/%E3%80%82%E4%B8%BB%E8%A6%81%E5%81%9A%E6%B3%95%E6%98%AF%E5%85%88%E5%B0%86%E5%BB%BA%E7%AD%91%E7%89%A9%E7%9A%84%E7%9A%84%E7%AB%AF%E7%82%B9%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%EF%BC%88%E5%85%88%E6%8C%89%E6%A8%AA%E5%9D%90%E6%A0%87%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%A8%AA%E5%9D%90%E6%A0%87%E7%9B%B8%E7%AD%89%EF%BC%8C%E5%88%99%E6%8C%89%E9%AB%98%E5%BA%A6%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E3%80%82%E5%A6%82%E6%9E%9C%E9%AB%98%E5%BA%A6%E4%B9%9F%E7%9B%B8%E7%AD%89%EF%BC%8C%E5%88%99%E5%B0%86%E5%8F%B3%E8%BE%B9%E5%BB%BA%E7%AD%91%E7%9A%84%E5%B7%A6%E8%BE%B9%E7%95%8C%E6%8E%92%E5%9C%A8%E5%B7%A6%E8%BE%B9%E5%BB%BA%E7%AD%91%E7%9A%84%E5%8F%B3%E8%BE%B9%E7%95%8C%E5%89%8D%E9%9D%A2%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%90%E7%94%A8%E4%BC%98%E5%85%88%E5%BA%A6%E5%88%97%EF%BC%8C%E9%81%8D%E5%8E%86%E4%B8%8A%E8%BF%B0%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E5%BB%BA%E7%AD%91%E7%9A%84%E5%B7%A6%E8%BE%B9%E7%95%8C%EF%BC%8C%E5%88%99%E5%8A%A0%E5%85%A5%E9%98%9F%E5%88%97%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E5%BB%BA%E7%AD%91%E7%9A%84%E5%8F%B3%E8%BE%B9%E7%95%8C%EF%BC%8C%E5%88%99%E4%BB%8E%E9%98%9F%E5%88%97%E4%B8%AD%E7%A7%BB%E9%99%A4%E3%80%82%E7%84%B6%E5%90%8E%E5%8F%96%E5%87%BA%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E5%BD%93%E5%89%8D%E9%AB%98%E5%BA%A6%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E4%B8%80%E8%87%B4%EF%BC%8C%E5%88%99%E8%AF%B4%E6%98%8E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%BE%B9%E7%95%8C%E7%82%B9%EF%BC%8C%E9%9C%80%E8%A6%81%E8%AE%B0%E5%BD%95%E3%80%82%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B">https://leetcode.cn/problems/the-skyline-problem/solution/gong-shui-san-xie-sao-miao-xian-suan-fa-0z6xc/。主要做法是先将建筑物的的端点进行排序（先按横坐标排序，如果横坐标相等，则按高度进行排序。如果高度也相等，则将右边建筑的左边界排在左边建筑的右边界前面），然后运用优先度列，遍历上述排序后的数组，如果是建筑的左边界，则加入队列中，如果是建筑的右边界，则从队列中移除。然后取出队列的最大值和当前高度进行比较，如果不一致，则说明这是一个边界点，需要记录。代码如下</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">getSkyline</span><span class="params">(<span class="type">int</span>[][] buildings)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lines = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] building : buildings) &#123;</span><br><span class="line">            List&lt;Integer&gt; left = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            left.add(building[<span class="number">0</span>]);</span><br><span class="line">            left.add(-building[<span class="number">2</span>]);</span><br><span class="line">            lines.add(left);</span><br><span class="line">            List&lt;Integer&gt; right = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            right.add(building[<span class="number">1</span>]);</span><br><span class="line">            right.add(building[<span class="number">2</span>]);</span><br><span class="line">            lines.add(right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lines.sort((first, second) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 由于左边高度已经被设置成负值，这里会把相同高度的边进行比较</span></span><br><span class="line">            <span class="comment">// 矩阵左边界会排在另一个（前面的矩阵）矩阵的右边界前面</span></span><br><span class="line">            <span class="comment">// 这样可以保证在后续的计算中不会出现 （2，0）（2，3） 的结果</span></span><br><span class="line">            <span class="keyword">if</span> (first.get(<span class="number">0</span>).equals(second.get(<span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> first.get(<span class="number">1</span>) - second.get(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> first.get(<span class="number">0</span>) - second.get(<span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line">        queue.add(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; line : lines) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.get(<span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(-line.get(<span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.remove(line.get(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentHeight</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">            <span class="keyword">if</span> (currentHeight != tempHeight) &#123;</span><br><span class="line">                tempHeight = currentHeight;</span><br><span class="line">                result.add(Arrays.asList(line.get(<span class="number">0</span>), currentHeight));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/the-skyline-problem/solution/gong-shui-san-xie-sao-miao-xian-suan-fa-0z6xc/">https://leetcode.cn/problems/the-skyline-problem/solution/gong-shui-san-xie-sao-miao-xian-suan-fa-0z6xc/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-22:Generate Parentheses</title>
    <url>/leetCode/leetCode-22/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数，表示括号对的数量，要求找出所有合法的括号组合。题目链接：**<a href="https://leetcode.com/problems/generate-parentheses/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：3</p>
<p>输出：{   “()()()”, “()(())”, “(()())”, “(())()”, “((()))”    }</p>
</blockquote>
<blockquote>
<p>输入：2</p>
<p>输出：{ “()()”, “(())” }</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="递归-剪枝"><a href="#递归-剪枝" class="headerlink" title="递归+剪枝"></a>递归+剪枝</h2><p>直接从第一对括号开始向后搜索直到最后一对括号匹配结束，在每次的搜索过程中，对拿到的字符串，从左到右依次插入一对括号，产生新的字符串，然后进入下一个递归。在产生新的字符串时，判断该字符串是否已经出现过，如果出现过则不进入下一轮递归，避免重复的搜索。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">generateParenthesis</span><span class="params">(List&lt;String&gt; parentheses, String str, <span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!parentheses.contains(str))</span><br><span class="line">            &#123;</span><br><span class="line">                parentheses.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line">        Set&lt;String&gt; newStrSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> str.substring(<span class="number">0</span>, i);</span><br><span class="line">            <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> str.substring(i);</span><br><span class="line">            <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> prefix + <span class="string">&quot;()&quot;</span> + suffix;</span><br><span class="line">            <span class="comment">// 剪枝，避免重复的搜索</span></span><br><span class="line">            <span class="keyword">if</span> (newStrSet.contains(newStr))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            newStrSet.add(newStr);</span><br><span class="line">            generateParenthesis(parentheses, newStr, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        generateParenthesis(result, <span class="string">&quot;()&quot;</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这种递归使用了剪枝进行优化，但是仍然超时了。</p>
<h2 id="尾部递归"><a href="#尾部递归" class="headerlink" title="尾部递归"></a>尾部递归</h2><p>由于上面的递归方式超时，所以需要换另一种方法。由于这种思路从理论上来讲是可行的，所以将尝试将递归改成尾部递归进行求解，同时，在求结果集时，不使用 List 及判重，直接使用 Set 增加新的元素，最后再将 Set 转成 List 返回。实验证明，使用尾部递归的效率远远高于前一种递归加剪枝方法效率。使用这种方法也能保证在时间限制范围内完成所有的求解。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;()&#123;&#123;add(<span class="string">&quot;()&quot;</span>);&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; preRestult = generateParenthesis(n - <span class="number">1</span>);</span><br><span class="line">        Set&lt;String&gt; parentheses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String parenthes : preRestult)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> parenthes.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> parenthes.substring(<span class="number">0</span>, i);</span><br><span class="line">                <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> parenthes.substring(i);</span><br><span class="line">                <span class="type">String</span> <span class="variable">newParenthes</span> <span class="operator">=</span> prefix + <span class="string">&quot;()&quot;</span> + suffix;</span><br><span class="line">                parentheses.add(newParenthes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(parentheses);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-219:Contains Duplicate II</title>
    <url>/leetCode/leetCode-219/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整形数组和一个整数 <code>k</code>，要求判断数组中是否存在两个相等的元素，使其下标之差小于等于 <code>k</code>。题目链接：**<a href="https://leetcode.com/problems/contains-duplicate-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [1,2,3,1], k &#x3D; 3</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [1,2,3,1,2,3], k &#x3D; 2</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，用一个 <code>map</code> 存储数组元素及其下标，然后遍历数组，判断元素是否已经存在 <code>map</code> 中，如果存在，则判断 <code>map</code> 中的下标与当前元素下标之差是否小于等于 <code>k</code>，是则返回，否则将当前元素放入 <code>map</code> 中。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i]) &amp;&amp; Math.abs(map.get(nums[i]) - i) &lt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-220:Contains Duplicate III</title>
    <url>/leetCode/leetCode-220/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数二维数组，以及整数 <code>k</code> 和 <code>t</code>，要求判断数组中是否存在两个元素下标 <code>i</code> 和 <code>j</code>，使得 <code>abs(i - j) &lt;= k</code> 并且 <code>abs(nums[i] - nums[j]) &lt;= t</code>，如果存在则返回 true, 否则返回 false。题目链接：**<a href="https://leetcode.com/problems/contains-duplicate-iii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [1,2,3,1], k &#x3D; 3, t &#x3D; 0</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [1,5,9,1,5,9], k &#x3D; 2, t &#x3D; 3</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用一个容量为 <code>k</code> 的 <code>TreeSet</code> 来存储数组的元素，遍历数组元素，对于每个元素，判断 <code>TreeSet</code> 中是否存在 <code>[num - t, num + t]</code> 中的元素，如果存在，则说明存在重复元素，否则不存在重复元素。为了快速判断 <code>[num - t, num + t]</code> 区间的元素是否在 <code>TreeSet</code> 中，可以使用 <code>ceiling</code> 函数获取 <code>num - t</code> 的值，然后与 <code>num + t</code> 进行比较。需要额外注意的时，运算过程中需要用 <code>long</code> 类型，否则两个数字相加可能超出范围。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyAlmostDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k, <span class="type">int</span> t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeSet&lt;Long&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">temp</span> <span class="operator">=</span> treeSet.ceiling((<span class="type">long</span>) nums[i] - t);</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="literal">null</span> &amp;&amp; temp &lt;= (<span class="type">long</span>) nums[i] + t)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            treeSet.add((<span class="type">long</span>) nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                treeSet.remove((<span class="type">long</span>) nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/solution/cun-zai-zhong-fu-yuan-su-iii-by-leetcode-bbkt/">https://leetcode-cn.com/problems/contains-duplicate-iii/solution/cun-zai-zhong-fu-yuan-su-iii-by-leetcode-bbkt/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-221:Maximal Square</title>
    <url>/leetCode/leetCode-221/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个只包含 <code>0</code> 和 <code>1</code> 的矩阵，要求找出其中最大的正方形的面积。题目链接：**<a href="https://leetcode.com/problems/maximal-square/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：matrix &#x3D; [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]</p>
<p>输出：4</p>
</blockquote>
<blockquote>
<p>输入：matrix &#x3D; [[“0”,”1”],[“1”,”0”]]</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用动态规划，用 <code>dp[i][j]</code> 表示以 <code>(i, j)</code> 为右下角的所有正方形中最大正方形的边长度，则动态转移方程为 <code>dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1(其中，dp[i][j] == 1)</code>，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">edge</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                edge = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">                edge = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; matrix.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; matrix[<span class="number">0</span>].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                edge = Math.max(edge, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> edge * edge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-222:Count Complete Tree Nodes</title>
    <url>/leetCode/leetCode-222/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个完全二叉树，要求用时间复杂度低于 <code>O(n)</code> 的解法算出二叉树的节点数量。题目链接：**<a href="https://leetcode.com/problems/count-complete-tree-nodes/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3]</p>
<p>输出：3</p>
<p>解释：树结构如下</p>
<p> 1</p>
<p>&#x2F; \</p>
<p>2 3</p>
</blockquote>
<blockquote>
<p>输入：[]</p>
<p>输出：0</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>最容易想到的解法是遍历树节点，但是这样的时间复杂度是 <code>O(n)</code> 不满足要求。结合完全二叉树的特点，可以先找出树的高度，计算除最后一层外的树节点数量，然后对每个节点，按右节点向下查找，如果在最后一层有节点，则说明在这一层上此节点左边的节点均存在，此时直接计算节点数量加到结果上，如果最后一层没有节点，则返回开始的地方，将右节点作为根节点进行递归计算。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">            high++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count = (<span class="type">int</span>) (Math.pow(<span class="number">2</span>, high - <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        countNodes(root, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root, <span class="type">int</span> level)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (level != high - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isEnd</span> <span class="operator">=</span> countNodes(root.left, level + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (isEnd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> isEnd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> level;</span><br><span class="line">            <span class="keyword">while</span> (temp != high - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p = p.right;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count += Math.pow(<span class="number">2</span>, (high - level - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> countNodes(root.right, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-223:Rectangle Area</title>
    <url>/leetCode/leetCode-223/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定四个坐标，第一个坐标表示第一个矩形的左下角的坐标，第二个坐标表示第一个矩形的右上角的坐标，第三个坐标表示第二个矩形的左下角的坐标，第四个坐标表示第二个矩形的右上角的坐标。要求求出这两个矩形构成的图形的面积。题目链接：**<a href="https://leetcode.com/problems/rectangle-area/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：ax1 &#x3D; -2, ay1 &#x3D; -2, ax2 &#x3D; 2, ay2 &#x3D; 2, bx1 &#x3D; -2, by1 &#x3D; -2, bx2 &#x3D; 2, by2 &#x3D; 2</p>
<p>输出：16</p>
</blockquote>
<blockquote>
<p>输入：ax1 &#x3D; -3, ay1 &#x3D; 0, ax2 &#x3D; 3, ay2 &#x3D; 4, bx1 &#x3D; 0, by1 &#x3D; -1, bx2 &#x3D; 9, by2 &#x3D; 2</p>
<p>输出：45</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题没有什么算法，就是单纯的数学矩形求面积。只要分别计算出两个矩形的面积之和，再减去两个矩形的相交面积，就能得到最终结果。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">computeArea</span><span class="params">(<span class="type">int</span> ax1, <span class="type">int</span> ay1, <span class="type">int</span> ax2, <span class="type">int</span> ay2, <span class="type">int</span> bx1, <span class="type">int</span> by1, <span class="type">int</span> bx2, <span class="type">int</span> by2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> computeRectangle(ax1, ay1, ax2, ay2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> computeRectangle(bx1, by1, bx2, by2);</span><br><span class="line">        <span class="keyword">return</span> first + second - calcIntersectArea(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">computeRectangle</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (x2 - x1) * (y2 - y1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcIntersectArea</span><span class="params">(<span class="type">int</span> ax1, <span class="type">int</span> ay1, <span class="type">int</span> ax2, <span class="type">int</span> ay2, <span class="type">int</span> bx1, <span class="type">int</span> by1, <span class="type">int</span> bx2, <span class="type">int</span> by2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bx2 &lt;= ax1 || ax2 &lt;= bx1 || ay2 &lt;= by1 || by2 &lt;= ay1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> calcLine(ax1, ax2, bx1, bx2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> calcLine(ay1, ay2, by1, by2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcLine</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> b1, <span class="type">int</span> b2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(b2, a2) - Math.max(b1, a1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-224:Basic Calculator</title>
    <url>/leetCode/leetCode-224/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个算术表达式字符串，只包含 <code>+</code>、<code>-</code>、<code>(</code>、<code>)</code> 、空格和数字，要求算出表达式的值。题目链接：**<a href="https://leetcode.com/problems/basic-calculator/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：s &#x3D; “(1+(4+5+2)-3)+(6+8)”</p>
<p>输出：23</p>
</blockquote>
<blockquote>
<p>输入：s &#x3D; 3- -2</p>
<p>输出：5</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>针对表达式运算，一般都是将中序表达式转成后续表达式，然后结合栈进行求解。本题也不例外，只不过本题中没有乘除的运算，会相对简单一点。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Stack&lt;Integer&gt; numStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Character&gt; opStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isAddNum</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        s = s + <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(ch))</span><br><span class="line">            &#123;</span><br><span class="line">                isAddNum = <span class="literal">true</span>;</span><br><span class="line">                num = num * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isAddNum)</span><br><span class="line">            &#123;</span><br><span class="line">                numStack.push(num);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                isAddNum = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                opStack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (opStack.peek() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    operate(numStack, opStack);</span><br><span class="line">                &#125;</span><br><span class="line">                opStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; s.charAt(index) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    index--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3--2的处理，变成：3-0-2</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || (!Character.isDigit(s.charAt(index)) &amp;&amp; s.charAt(index) != <span class="string">&#x27;)&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    numStack.push(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!opStack.isEmpty() &amp;&amp; opStack.peek() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    operate(numStack, opStack);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                opStack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">(Stack&lt;Integer&gt; numStack, Stack&lt;Character&gt; opStack)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> numStack.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> numStack.pop();</span><br><span class="line">        <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> opStack.pop();</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            numStack.push(first + second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            numStack.push(first - second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-225:Implement Stack using Queues</title>
    <url>/leetCode/leetCode-225/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>要求用队列实现栈的操作。题目链接：<a href="https://leetcode.com/problems/implement-queue-using-stacks"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<p>[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]</p>
<p>输出：</p>
<p>[null, null, null, 1, 1, false]</p>
<p>解释：</p>
<p>MyQueue myQueue &#x3D; new MyQueue();<br>myQueue.push(1); &#x2F;&#x2F; queue is: [1]<br>myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.peek(); &#x2F;&#x2F; return 1<br>myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]<br>myQueue.empty(); &#x2F;&#x2F; return false</p>
</blockquote>
<blockquote>
<p>输入：</p>
<p>[“MyQueue”, “empty”]</p>
<p>[[],[]]</p>
<p>输出：</p>
<p>[null, true]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，直接使用队列的特性进行实现即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queueBak;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">topNum</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queueBak = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            queueBak.offer(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            queue.offer(x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        topNum = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        topNum = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queueBak.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                topNum = queueBak.poll();</span><br><span class="line">                queue.offer(topNum);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> queueBak.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            topNum = queue.poll();</span><br><span class="line">            queueBak.offer(topNum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> topNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.size() == <span class="number">0</span> &amp;&amp; queueBak.size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-226:Invert Binary Tree</title>
    <url>/leetCode/leetCode-226/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉树，要求将二叉树进行反转。题目链接：<a href="https://leetcode.com/problems/invert-binary-tree"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：root &#x3D; [4,2,7,1,3,6,9]</p>
<p>输出：[4,7,2,9,6,3,1]</p>
<p>解释：</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg"></p>
</blockquote>
<blockquote>
<p>输入：root &#x3D; [1]</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用递归将二叉树反转，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-227:Basic Calculator II</title>
    <url>/leetCode/leetCode-227/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串表达式，只包含数字、空格和 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>，已知这个表达式合法，且不会出现负数，对于除法，向下取整，即 3 &#x2F; 2 &#x3D; 1。要求求出这个表达式的值。题目链接：**<a href="https://leetcode.com/problems/basic-calculator-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：5 &#x2F; 2</p>
<p>输出：2</p>
</blockquote>
<blockquote>
<p>输入：4 + 3 *2</p>
<p>输出：10</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>针对表达式求值，将中缀表达式转成后缀表达式，然后运用栈进行求解。针对此题，只包含加减乘除，并没有括号，相比而言会简单点。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Stack&lt;Character&gt; opStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; numStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isAdd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(ch))</span><br><span class="line">            &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                isAdd = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isAdd)</span><br><span class="line">            &#123;</span><br><span class="line">                numStack.push(num);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                isAdd = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!opStack.isEmpty() &amp;&amp; !isHigh(ch, opStack.peek()))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> numStack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> numStack.pop();</span><br><span class="line">                numStack.push(calc(first, second, opStack.pop()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            opStack.push(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isAdd)</span><br><span class="line">        &#123;</span><br><span class="line">            numStack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!opStack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> numStack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> numStack.pop();</span><br><span class="line">            numStack.push(calc(first, second, opStack.pop()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second, <span class="type">char</span> op)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> first + second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> first - second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> first * second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> first / second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isHigh</span><span class="params">(<span class="type">char</span> first, <span class="type">char</span> second)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (first == <span class="string">&#x27;*&#x27;</span> || first == <span class="string">&#x27;/&#x27;</span>) &amp;&amp; (second == <span class="string">&#x27;+&#x27;</span> || second == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-228:Summary Ranges</title>
    <url>/leetCode/leetCode-228/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个不包含重复元素的升序整数数组，要求返回 恰好覆盖数组中所有数字的最小有序区间范围列表。题目链接：<a href="https://leetcode.com/problems/summary-ranges"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [0,1,2,4,5,7]</p>
<p>输出：[“0-&gt;2”,”4-&gt;5”,”7”]</p>
<p>解释：[0,2] –&gt; “0-&gt;2”</p>
<p>[4,5] –&gt; “4-&gt;5”</p>
<p>[7,7] –&gt; “7”</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [0,2,3,4,6,8,9]</p>
<p>输出：[“0”,”2-&gt;4”,”6”,”8-&gt;9”]</p>
<p>解释：[0,0] –&gt; “0”</p>
<p>[2,4] –&gt; “2-&gt;4”</p>
<p>[6,6] –&gt; “6”</p>
<p>[8,9] –&gt; “8-&gt;9”</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，直接按照题意计算即可，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">summaryRanges</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != prev + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (start == prev) &#123;</span><br><span class="line">                    result.add(String.valueOf(start));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(start + <span class="string">&quot;-&gt;&quot;</span> + prev);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                start = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            prev = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start == prev) &#123;</span><br><span class="line">            result.add(String.valueOf(start));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.add(start + <span class="string">&quot;-&gt;&quot;</span> + prev);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-229:Majority Element II</title>
    <url>/leetCode/leetCode-229/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，要求找出所有数组中元素出现个数超过 <code>1/3</code> 的元素。题目链接：<a href="https://leetcode.com/problems/majority-element-ii/"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[3, 2, 3]</p>
<p>输出：[3]</p>
</blockquote>
<blockquote>
<p>输入：[1, 2]</p>
<p>输出：[1, 2]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题跟 <a href="https://guozhchun.github.io/leetCode/leetCode-169/">LeetCode-169</a> 类似，只不过那边是找超过<code>1/2</code> 的数，这边是找超过 <code>1/3</code> 的数，所以做法类似，都是用Boyer-Moore 算法进行求解。显然，数组中元素出现个数超过 <code>1/3</code> 的元素，不会超过两个（只有一个或两个），所以此处在求解过程中，需要分别判断两个候选数，如果是其中一个，则对应数量加一，如果都不是，则两个候选数的数量分别减一，如果候选数数量为0，则用新的数更新候选数。这样，数组在遍历结束后会得到两个候选数，此时还需要进行额外的操作：分别判断这两个候选数是否数量超过 <code>1/3</code>，这是为了避免出现 <code>[1,2,1,1,1,1,1]</code> 这种情况，这种情况候选数有 <code>1</code> 和 <code>2</code>，但是答案显然只有 <code>1</code> 不包含 <code>2</code>，所以最后的判断可以保证得到最终正确的答案。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.singletonList(nums[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">firstCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">secondCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == first) &#123;</span><br><span class="line">                firstCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (num == second) &#123;</span><br><span class="line">                secondCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (firstCount == <span class="number">0</span>) &#123;</span><br><span class="line">                first = num;</span><br><span class="line">                firstCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (secondCount == <span class="number">0</span>) &#123;</span><br><span class="line">                second = num;</span><br><span class="line">                secondCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            firstCount--;</span><br><span class="line">            secondCount--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        firstCount = <span class="number">0</span>;</span><br><span class="line">        secondCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == first) &#123;</span><br><span class="line">                firstCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == second) &#123;</span><br><span class="line">                secondCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (firstCount &gt; nums.length / <span class="number">3</span>) &#123;</span><br><span class="line">            result.add(first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (secondCount &gt; nums.length / <span class="number">3</span>) &#123;</span><br><span class="line">            result.add(second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-23:Merge k Sorted Lists</title>
    <url>/leetCode/leetCode-23/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定 k 个有序的链表，要求将其合并成一个有序的链表返回。题目链接：**<a href="https://leetcode.com/problems/merge-k-sorted-lists/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]</p>
<p>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
</blockquote>
<blockquote>
<p>输入：[]</p>
<p>输出：[]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>利用归并排序的思路，将列表中两两分组，对每组中的两个链表，运用<a href="https://guozhchun.github.io/2019/06/21/leetCode/leetCode-21/">合并两个有序链表</a>的做法将其合并成一个有序的链表，将这些合并后的链表继续两两分组，重复上述过程，直到最后只剩下一个链表，就是合并后的有序的链表。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> l1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (p1.val &gt; p2.val)</span><br><span class="line">        &#123;</span><br><span class="line">            p1 = l2;</span><br><span class="line">            p2 = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> p1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (p1.next != <span class="literal">null</span> &amp;&amp; p1.next.val &lt; p2.val)</span><br><span class="line">            &#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> p1.next;</span><br><span class="line">            p1.next = p2;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (lists.length &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode[] temp = <span class="keyword">new</span> <span class="title class_">ListNode</span>[(lists.length + <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; lists.length)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp[index] = mergeTwoLists(lists[i], lists[i + <span class="number">1</span>]);</span><br><span class="line">                    i += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    temp[index] = lists[i];</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            lists = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-230:Kth Smallest Element in a BST</title>
    <url>/leetCode/leetCode-230/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个搜索二叉树和一个整数 <code>k</code>，要求找出该二叉树中第 <code>k</code> 小的数。题目链接：**<a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1, 2, 3]， k &#x3D; 2</p>
<p>输出：2</p>
<p>树的形状</p>
<p>  2</p>
<p>&#x2F;  \</p>
<p>1  3</p>
</blockquote>
<blockquote>
<p>输入：[1]，k &#x3D; 1</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>利用二叉搜索树中序遍历是一个升序数组的特点，用中序遍历的算法对树进行查找，找到第 <code>k</code> 个数时停止查找。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        isFind(root, k);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFind</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isFind(root.left, k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">            result = root.val;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isFind(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-231:Power of Two</title>
    <url>/leetCode/leetCode-231/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数，要求判断这个整数是否是 <code>2</code> 的幂次方。题目链接：<a href="https://leetcode.com/problems/power-of-two"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：1</p>
<p>输出：true</p>
<p>解释：2 ^ 0 &#x3D; 1</p>
</blockquote>
<blockquote>
<p>输入：6</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>使用循环依次除 2，如果过程中有奇数，则说明这不是一个 2 的幂次方。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>使用 <code>n &amp; (n - 1)</code> 将 <code>n</code> 的最低位 <code>1</code> 置为 <code>0</code> 的方式进行判断，如果 <code>n &amp; (n - 1) == 0</code>，则说明这是一个 <code>2</code> 的幂次方。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-232:Implement Queue using Stacks</title>
    <url>/leetCode/leetCode-232/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>要求用两个栈实现队列。题目链接：<a href="https://leetcode.com/problems/implement-queue-using-stacks"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]</p>
<p>输出：[null, null, null, 1, 1, false]</p>
<p>解释：MyQueue myQueue &#x3D; new MyQueue();</p>
<p>myQueue.push(1); &#x2F;&#x2F; queue is: [1]<br>myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.peek(); &#x2F;&#x2F; return 1<br>myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]<br>myQueue.empty(); &#x2F;&#x2F; return false</p>
</blockquote>
<blockquote>
<p>输入：[“MyQueue”,  “empty”]</p>
<p>[[], []]</p>
<p>输出：[null, true]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用一个栈放置 <code>push</code> 的值，另一个栈放置需要 <code>pop</code> 或 <code>peek</code> 的值，每次出队列时，如果 <code>pop</code> 或 <code>peek</code> 的值的栈为空，则从存储 <code>push</code> 值的栈依次弹出元素放入存储  <code>pop</code> 或 <code>peek</code> 的值的栈中，然后返回栈顶元素。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; bak;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        bak = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        fillBakStack();</span><br><span class="line">        <span class="keyword">return</span> bak.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        fillBakStack();</span><br><span class="line">        <span class="keyword">return</span> bak.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fillBakStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bak.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">                bak.push(stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.empty() &amp;&amp; bak.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-233:Number of Digit One</title>
    <url>/leetCode/leetCode-233/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数字，要求找出从 0 到这个数字中间的每个数字里 1 出现的次数。题目链接：**<a href="https://leetcode.com/problems/number-of-digit-one">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：13</p>
<p>输出：6</p>
</blockquote>
<blockquote>
<p>输入：1</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>最简单粗暴的做法就是遍历每个数字，获取每个数字里 1 的个数，然后累加。但是这样在 n 的值比较大的时候会超时。优化的做法分别求出每个数字位  1 的个数，然后进行相加，此种做法参考：<a href="https://leetcode.cn/problems/number-of-digit-one/solution/shu-zi-1-de-ge-shu-by-leetcode-solution-zopq/%E3%80%82">https://leetcode.cn/problems/number-of-digit-one/solution/shu-zi-1-de-ge-shu-by-leetcode-solution-zopq/。</a></p>
<p>在求每个位的数时，可以先由当前位的高位求出有多少个 <code>10 ^ k</code> 个  <code>1</code>，再求出当前位的地位的数出现 <code>1</code> 的个数，然后两者进行相加。</p>
<p>例如数字 <code>34567</code>，在求百进位数字 1 个数时，由于 <code>0~1000</code> 里百位数字出现的次数为 <code>100</code>（数字 <code>100~199</code>），所以 <code>34567</code> 百位的数字至少为 <code>34 * 100 = 3400</code>（<code>34</code> 由  <code>34567 / 100 = 34</code> 计算而来），此时已经将百位的高位计算剔除，剩下 <code>34567 % 100 = 567</code> 数字判断百位出现 1 的个数。此时分为三种情况：</p>
<ul>
<li>当前数小于 100，百位出现 1 的个数为 0</li>
<li>当前数介于 <code>100 ~ 199</code>，那么出现 1 的个数即为当前剩下的数</li>
<li>当前数大于 <code>199</code> ，那么出现 1 的个数为 100</li>
</ul>
<p>综合三种情况，可以用公式来表示 <code>min(max(num - 100 + 1, 0), 100)</code>，代入计算可以求得值是 <code>100</code>，所以 <code>34567</code>  的百位数结果为 <code>3400 + 100 = 3500</code>。依次类推即可求得每位的数量，最终相加就能得到答案。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt;= n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> pos * <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">modNum</span> <span class="operator">=</span> n % temp;</span><br><span class="line">            <span class="type">int</span> <span class="variable">quotient</span> <span class="operator">=</span> n / temp;</span><br><span class="line">            result += quotient * pos + Math.min(Math.max(<span class="number">0</span>, modNum - pos + <span class="number">1</span>), pos);</span><br><span class="line">            pos *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/number-of-digit-one/solution/shu-zi-1-de-ge-shu-by-leetcode-solution-zopq/">https://leetcode.cn/problems/number-of-digit-one/solution/shu-zi-1-de-ge-shu-by-leetcode-solution-zopq/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-234:Palindrome Linked List</title>
    <url>/leetCode/leetCode-234/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表，要求判断链表是否是一个回文链表。题目链接：<a href="https://leetcode.com/problems/palindrome-linked-list"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：head &#x3D; [1,2,2,1]</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg"></p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：head &#x3D; [1,2]</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg"></p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题最简单的做法是将链表转成数组，然后按回文数组进行判断。但是这样空间复杂度是 <code>O(n)</code>，可以进一步优化：将链表分成前后两半，然后翻转其中一半的链表，将这两个链表进行比较，比较结束后恢复翻转的链表。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">quick</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (quick.next != <span class="literal">null</span> &amp;&amp; quick.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            quick = quick.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">secondHead</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">firstHead</span> <span class="operator">=</span> reverse(head);</span><br><span class="line">        <span class="type">boolean</span> result;</span><br><span class="line">        <span class="keyword">if</span> (quick.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            result = isEqual(firstHead, secondHead.next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = isEqual(firstHead, secondHead);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        reverse(firstHead);</span><br><span class="line">        slow.next = secondHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEqual</span><span class="params">(ListNode first, ListNode second)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="literal">null</span> &amp;&amp; second != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.val != second.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> first == <span class="literal">null</span> &amp;&amp; second == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">other</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="keyword">while</span> (dummy.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">dummyNext</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">            dummy.next = dummyNext.next;</span><br><span class="line">            dummyNext.next = other.next;</span><br><span class="line">            other.next = dummyNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> other.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-235:Lowest Common Ancestor of a Binary Search Tree</title>
    <url>/leetCode/leetCode-235/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个搜索二叉树和两个节点，要求找出两个节点的公共祖先。题目链接：<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</p>
<p>输出：6</p>
<p>解释：树的形状如下</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="binarysearchtree_improved.png (200×190) (leetcode.com)"> </p>
</blockquote>
<blockquote>
<p>输入：root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</p>
<p>输出：2</p>
<p>解释：树的形状如下</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="binarysearchtree_improved.png (200×190) (leetcode.com)"></p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>树是二叉搜索树，可以充分利用这个特点进行搜索，如果 <code>p</code> 和 <code>q</code> 在根节点的左右两边或其中一个节点是根节点，那么这两个节点的最近公共祖先就是根节点，如果 <code>p</code> 和 <code>q</code> 的值都小于根节点的值，那么其最近公共祖先就在左子树中，此时递归搜索左子树即可，如果 <code>p</code> 和 <code>q</code> 的值都大于根节点的值，那么其最近公共祖先就在右子树中，此时递归搜索右子树即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val == p.val || root.val == q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode small;</span><br><span class="line">        TreeNode big;</span><br><span class="line">        <span class="keyword">if</span> (p.val &lt; q.val) &#123;</span><br><span class="line">            small = p;</span><br><span class="line">            big = q;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            small = q;</span><br><span class="line">            big = p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (small.val &lt; root.val &amp;&amp; root.val &lt; big.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (big.val &lt; root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-236:Lowest Common Ancestor of a Binary Tree</title>
    <url>/leetCode/leetCode-236/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉树和两个节点，要求找出这两个节点的最近公共祖先。题目链接：**<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</p>
<p>树的形状如下</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="树形状"></p>
<p>输出：3</p>
</blockquote>
<blockquote>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</p>
<p>树的形状如下</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="树形状"></p>
<p>输出：5</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>遍历树，记录每个节点的父节点，然后从 p 节点往上找，将 p 节点的所有父节点放入 set 中，再从 q  节点往上找，最先遇到存在 set 中的父节点，就是要找的最近公共祖先。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;TreeNode, TreeNode&gt; parentMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        dfs(root.left, root, parentMap);</span><br><span class="line">        dfs(root.right, root, parentMap);</span><br><span class="line">        </span><br><span class="line">        Set&lt;TreeNode&gt; ancestors = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> p;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ancestors.add(current);</span><br><span class="line">            current = parentMap.get(current);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        current = q;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ancestors.contains(current))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">            current = parentMap.get(current);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, TreeNode parent, Map&lt;TreeNode, TreeNode&gt; parentMap)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parentMap.put(root, parent);</span><br><span class="line">        dfs(root.left, root, parentMap);</span><br><span class="line">        dfs(root.right, root, parentMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-237:Delete Node in a Linked List</title>
    <url>/leetCode/leetCode-237/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表中的某个节点（非链表最后一个节点），要求删除这个节点（可以不必在内存中删除，只要求链表中没有这个值的节点即可）。题目链接：**<a href="https://leetcode.com/problems/delete-node-in-a-linked-list/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：head &#x3D; [4,5,1,9], node &#x3D; 1</p>
<p>输出：[4, 5, 9]</p>
</blockquote>
<blockquote>
<p>输入：head &#x3D; [4,5,1,9], node &#x3D; 5</p>
<p>输出：[4, 1, 9]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题跟常规的删除链表节点不一样，常规的是需要知道头节点，然后从链表中将这个节点剔除。但是本题并没有给头节点，同时并不要求这个节点从链表中实质删除这个节点，说明可以删除其他节点，只要链表的数量比原先少1，且顺序保持不变即可。所以，可以把后续的节点值往前移，删除最后一个节点。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span> (node.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.val = node.next.val;</span><br><span class="line">            prev = node;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化一点的做法是，直接将下个节点的值赋给当前节点，然后删除下个节点，这样后续的节点都不用改变。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/solution/shan-chu-lian-biao-zhong-de-jie-dian-by-x656s/">https://leetcode.cn/problems/delete-node-in-a-linked-list/solution/shan-chu-lian-biao-zhong-de-jie-dian-by-x656s/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-238:Product of Array Except Self</title>
    <url>/leetCode/leetCode-238/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，要求返回一个新数组，新数组中的每个元素值是老数组中除了当前索引位置的其他元素的乘积。题目保证所有的乘积都在整形范围内。要求算法的时间复杂度为 <code>O(n)</code>，且求解过程中不能运用除法。题目链接：**<a href="https://leetcode.com/problems/product-of-array-except-self/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3,4]</p>
<p>输出：[24,12,8,6]</p>
</blockquote>
<blockquote>
<p>输入：[-1,1,0,-3,3]</p>
<p>输出：[0,0,9,0,0]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题参考：<a href="https://leetcode-cn.com/problems/product-of-array-except-self/solution/chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-by-leetcode-/%E3%80%82%E4%B8%BB%E8%A6%81%E6%98%AF%E8%BF%90%E7%94%A8%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%8C%E8%A6%81%E8%AE%A1%E7%AE%97%E9%99%A4%E4%BA%86%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%B6%E4%BB%96%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%85%B6%E6%8B%86%E6%88%90%E4%B8%A4%E9%83%A8%E5%88%86%EF%BC%9A%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E5%B7%A6%E8%BE%B9%E5%85%83%E7%B4%A0%E7%9A%84%E4%B9%98%E7%A7%AF%E3%80%81%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E5%8F%B3%E8%BE%B9%E5%85%83%E7%B4%A0%E7%9A%84%E4%B9%98%E7%A7%AF%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86%E8%BF%99%E4%B8%A4%E4%B8%AA%E4%B9%98%E7%A7%AF%E7%9B%B8%E4%B9%98%EF%BC%8C%E5%B0%B1%E5%BE%97%E5%88%B0%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%E7%9A%84%E7%BB%93%E6%9E%9C%E3%80%82%E5%9C%A8%E8%AE%A1%E7%AE%97%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E5%B7%A6%E8%BE%B9%E5%85%83%E7%B4%A0%E7%9A%84%E4%B9%98%E7%A7%AF%E5%8F%AF%E4%BB%A5%E8%BF%90%E7%94%A8%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%8C%E8%AE%A1%E7%AE%97%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E5%8F%B3%E8%BE%B9%E5%85%83%E7%B4%A0%E7%9A%84%E4%B9%98%E7%A7%AF%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%BF%90%E7%94%A8%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%88%E4%BB%8E%E6%9C%AB%E5%B0%BE%E5%BE%80%E5%89%8D%E8%AE%A1%E7%AE%97%EF%BC%89%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E6%B1%82%E5%87%BA%E8%BF%99%E4%B8%A4%E9%83%A8%E5%88%86%EF%BC%8C%E7%84%B6%E5%90%8E%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E6%AF%8F%E4%B8%AA%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%B7%A6%E5%89%8D%E7%BC%80%E7%A7%AF%E5%92%8C%E5%8F%B3%E5%90%8E%E7%BC%80%E7%A7%AF%E8%BF%9B%E8%A1%8C%E7%9B%B8%E4%B9%98%EF%BC%8C%E5%B0%B1%E8%83%BD%E5%BE%97%E5%88%B0%E6%95%B4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E7%BB%93%E6%9E%9C%E3%80%82">https://leetcode-cn.com/problems/product-of-array-except-self/solution/chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-by-leetcode-/。主要是运用前缀和的算法，要计算除了当前元素的其他所有元素的值，可以将其拆成两部分：当前元素左边元素的乘积、当前元素右边元素的乘积，然后将这两个乘积相乘，就得到当前位置的结果。在计算当前元素左边元素的乘积可以运用前缀和的算法，计算当前元素右边元素的乘积也可以运用前缀和的算法（从末尾往前计算），只需要求出这两部分，然后对数组的每个位置的左前缀积和右后缀积进行相乘，就能得到整个数组的结果。</a></p>
<p>为了进一步优化空间，可以把左前缀积暂存在结果数组中，然后用一个变量存放右后缀积，计算过程中从末尾往前遍历，分别更新结果数组的值以及右后缀积的变量值。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            result[i] = result[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">suffixProduct</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = result[i] * suffixProduct;</span><br><span class="line">            suffixProduct = suffixProduct * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/product-of-array-except-self/solution/chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-by-leetcode-/">https://leetcode-cn.com/problems/product-of-array-except-self/solution/chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-by-leetcode-/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-239:Sliding Window Maximum</title>
    <url>/leetCode/leetCode-239/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组和一个表示窗口大小的正整数 <code>k</code>（ <code>k</code> 小于数组长度），窗口从数组左侧向右滑动，要求找出每个滑动窗口期间内数字的最大值。题目链接：**<a href="https://leetcode.com/problems/sliding-window-maximum/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</p>
<p>输出：[3,3,5,5,6,7]</p>
<p>解释：</p>
<p>Window position         &amp;nbsp;&amp;nbsp;&amp;nbsp;       Max</p>
<p>[1  3  -1] -3  5  3  6  7      &amp;nbsp;&amp;nbsp;&amp;nbsp; 3<br> 1 [3  -1  -3] 5  3  6  7     &amp;nbsp;&amp;nbsp;&amp;nbsp;  3<br> 1  3 [-1  -3  5] 3  6  7     &amp;nbsp;&amp;nbsp;&amp;nbsp;  5<br> 1  3  -1 [-3  5  3] 6  7      &amp;nbsp;&amp;nbsp;&amp;nbsp; 5<br> 1  3  -1  -3 [5  3  6] 7      &amp;nbsp;&amp;nbsp;&amp;nbsp; 6<br> 1  3  -1  -3  5 [3  6  7]     &amp;nbsp;&amp;nbsp;&amp;nbsp; 7</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [1,2,3], k &#x3D; 3</p>
<p>输出：[3]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解法一：大顶堆"><a href="#解法一：大顶堆" class="headerlink" title="解法一：大顶堆"></a>解法一：大顶堆</h2><p>使用大顶堆（优先队列）来存储数据，窗口滑动时，将当前值放入堆中，同时取出堆顶的元素，如果元素已经不在窗口范围内，则移除，如果元素在窗口范围内，则放如结果数组中。由于要进行堆顶元素和窗口边界的判断，所以此处需要同时在优先队列中存储数组的元素（用于优先队列比较大小）和元素的下标（用于比较堆顶元素是否在滑动窗口内）。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k, (o1, o2) -&gt; o2[<span class="number">1</span>] - o1[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, nums[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, nums[i]&#125;);</span><br><span class="line">            <span class="keyword">while</span> (queue.peek()[<span class="number">0</span>] &lt; i - k + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            result[i - k + <span class="number">1</span>] = queue.peek()[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：双端队列"><a href="#解法二：双端队列" class="headerlink" title="解法二：双端队列"></a>解法二：双端队列</h2><p>此解法参考：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/shuang-xiang-dui-lie-jie-jue-hua-dong-chuang-kou-2/%E3%80%82%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%E6%9D%A5%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%8B%E6%A0%87%EF%BC%8C%E5%90%8C%E6%97%B6%E7%94%A8%E7%B1%BB%E4%BC%BC%E5%8D%95%E8%B0%83%E9%80%92%E5%87%8F%E6%A0%88%E7%9A%84%E6%80%9D%E6%83%B3%EF%BC%8C%E6%AF%8F%E6%AC%A1%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%98%9F%E5%88%97%E5%B0%BE%E9%83%A8%E6%8C%87%E5%90%91%E7%9A%84%E6%95%B0%E5%AD%97%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%EF%BC%8C%E5%88%99%E5%B0%86%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%E5%87%BA%E9%98%9F%EF%BC%8C%E5%90%8C%E6%97%B6%E5%88%A4%E6%96%AD%E9%98%9F%E9%A6%96%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%8C%83%E5%9B%B4%E5%86%85%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%9C%A8%EF%BC%8C%E5%88%99%E5%B0%86%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0%E5%87%BA%E9%98%9F%E3%80%82%E8%BF%99%E6%A0%B7%E5%A4%84%E7%90%86%E8%BF%87%E5%90%8E%EF%BC%8C%E9%98%9F%E5%88%97%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%8C%87%E5%90%91%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BE%9D%E6%AC%A1%E9%80%92%E5%87%8F%E7%9A%84%EF%BC%8C%E5%B9%B6%E4%B8%94%E9%98%9F%E9%A6%96%E7%9A%84%E5%85%83%E7%B4%A0%E6%8C%87%E5%90%91%E7%9A%84%E6%95%B0%E5%AD%97%E5%B0%B1%E6%98%AF%E5%BD%93%E5%89%8D%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%86%85%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97%E3%80%82%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B">https://leetcode-cn.com/problems/sliding-window-maximum/solution/shuang-xiang-dui-lie-jie-jue-hua-dong-chuang-kou-2/。使用一个队列来存储元素的下标，同时用类似单调递减栈的思想，每次遍历数组元素，如果队列尾部指向的数字小于当前数字，则将队尾元素出队，同时判断队首的元素是否在滑动窗口范围内，如果不在，则将队首元素出队。这样处理过后，队列中每个元素指向的数字是依次递减的，并且队首的元素指向的数字就是当前滑动窗口内的最大数字。代码如下</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt; nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            queue.offerLast(i);</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peekFirst() &lt; i + <span class="number">1</span> - k)</span><br><span class="line">            &#123;</span><br><span class="line">                queue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                result[i + <span class="number">1</span>- k] = nums[queue.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/shuang-xiang-dui-lie-jie-jue-hua-dong-chuang-kou-2/">https://leetcode-cn.com/problems/sliding-window-maximum/solution/shuang-xiang-dui-lie-jie-jue-hua-dong-chuang-kou-2/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-24:Swap Nodes in Pairs</title>
    <url>/leetCode/leetCode-24/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出一个链表，要求按照顺序将链表中每两个节点分成一组，并将组中两个节点交换顺序，重新组成新的链表后返回链表的头节点指针。要求只能使用额外的常量空间。题目链接：**<a href="https://leetcode.com/problems/swap-nodes-in-pairs/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3,4]</p>
<p>输出：[2,1,4,3]</p>
</blockquote>
<blockquote>
<p>输入：[1,2,3]</p>
<p>输出：[2,1,3]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题就是链表的基本使用。只需要定义两个指针，依次对相邻的两个节点进行顺序交换即可。为了能够使链表的第一个和第二个节点能够像其他节点一样进行顺序交换，可以定义一个新的临时头节点放在原先链表的头节点的前面，这样就能在一个循环中完成两个相邻节点顺序的交换。因为是只新建了一个节点，并不是对链表的每个节点都新建节点，所以其占用的空间是常量的，满足题目的要求。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 为了方便使链表第一、二个节点能够跟链表中其他的节点一样进行顺序交换</span></span><br><span class="line">        <span class="comment">// 此处定义一个临时头节点放在原有链表头节点之前</span></span><br><span class="line">        <span class="comment">// 待交换节点完毕后，删除此临时头节点</span></span><br><span class="line">        <span class="comment">// 题目要求只能使用额外的常量空间，此处只是新建一个节点，并不是新建链表中每个节点，是满足常量空间要求的</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tempHeadNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        tempHeadNode.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> tempHeadNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> tempHeadNode.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// p1 == null：说明链表是只有一个节点，或者，链表是双数节点，而且 p2 已经指向链表最后一个节点，已经对完成交换动作</span></span><br><span class="line">        <span class="comment">// p1.next == null：说明链表节点数大于 1，且是单数节点，此时 p1 已经指向链表最后一个节点，交换动作执行完毕</span></span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p1.next != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 交换相邻的两个节点</span></span><br><span class="line">            p2.next = p1.next;</span><br><span class="line">            p1.next = p1.next.next;</span><br><span class="line">            p2.next.next = p1;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 移动指针，进入下一轮循环</span></span><br><span class="line">            p2 = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除临时头部节点，返回正常的头节点指针</span></span><br><span class="line">        head = tempHeadNode.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-240:Search a 2D Matrix II</title>
    <url>/leetCode/leetCode-240/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数二维数组表示矩阵，矩阵中每一行从左到右都是递增的，每一列从上到下都是递增的。要求判断给定的数字是否在矩阵中。题目链接：**<a href="https://leetcode.com/problems/search-a-2d-matrix-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[1,4,5],[2,6,7]]， 8</p>
<p>输出：false</p>
</blockquote>
<blockquote>
<p>输入：[[1,4,5],[2,6,7]]， 4</p>
<p>输出：true</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题最简单粗暴的做法就是直接遍历矩阵，但是这样并没有利用上矩阵的特点：每一行从左到右都是递增的，每一列从上到下都是递增的。所以这样的效率也是最低的。优化一点，可以从上到下每一行进行二分查找，这样也仅是利用了矩阵每一行的数字是递增这一特性，并没有利用每一列数字是递增这一特点，所以这也不是最高效的查找方式。高效的查找方式是：从矩阵的右上角进行查找，如果当前数字比目标数字小，则向下一行进行查找（利用矩阵列数字递增这一特点），如果当前数字比目标数字大，则向左进行查找（利用矩阵行数字递增这一特点），如果查找范围超过矩阵边界，说明目标数字不在矩阵中。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; matrix.length &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-2404:Most Frequent Even Element</title>
    <url>/leetCode/leetCode-2404/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数组，要求找出数组中出现次数最多的偶数，如果有相同的，则返回最小的，如果没找到，则返回 <code>-1</code>。题目链接：<a href="https://leetcode.com/problems/most-frequent-even-element/description"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[0,1,2,2,4,4,1]</p>
<p>输出：2</p>
</blockquote>
<blockquote>
<p>输入：[1,3,5,7]</p>
<p>输出：-1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用一个 map 来存储偶数及其出现的个数，遍历数组，实时更新 map 中的值，同时更新当前的次数最多的最小偶数，遍历结束后，即可获得答案。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mostFrequentEven</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">                map.put(num, count);</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> map.getOrDefault(candidate, Integer.MIN_VALUE);</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; count) &#123;</span><br><span class="line">                    candidate = num;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == count &amp;&amp; num &lt; candidate) &#123;</span><br><span class="line">                    candidate = num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-241:Different Ways to Add Parentheses</title>
    <url>/leetCode/leetCode-241/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个表达式字符串，只包含数字和 <code>+</code>、<code>-</code>、<code>*</code> 符号，要求找出所有为表达式增加括号后的计算结果。题目链接：**<a href="https://leetcode.com/problems/different-ways-to-add-parentheses/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：”2-1-1”</p>
<p>输出：[0,2]</p>
<p>解释：</p>
<p>((2-1)-1) &#x3D; 0<br>(2-(1-1)) &#x3D; 2</p>
</blockquote>
<blockquote>
<p>输入：”2*3-4*5”</p>
<p>输出：[-34,-14,-10,-10,10]</p>
<p>解释：</p>
<p>(2*(3-(4*5))) &#x3D; -34<br>((2*3)-(4*5)) &#x3D; -14<br>((2*(3-4))*5) &#x3D; -10<br>(2*((3-4)*5)) &#x3D; -10<br>(((2*3)-4)*5) &#x3D; 10</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>直接根据题目要求，使用递归方式找出所有为表达式添加括号的式子，计算其结果，进行汇总。为了减少重复计算，可以使用一个 <code>map</code> 将计算过的表达式的值存起来，方便下次直接取用。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">diffWaysToCompute</span><span class="params">(String expression)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> diffWaysToCompute(expression, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">diffWaysToCompute</span><span class="params">(String expression, Map&lt;String, List&lt;Integer&gt;&gt; map)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(expression))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(expression);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (getNextOpIndex(expression, <span class="number">0</span>) == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(Integer.parseInt(expression));</span><br><span class="line">            map.put(expression, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> expression.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getNextOpIndex(expression, i);</span><br><span class="line">            <span class="keyword">if</span> (index == -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;Integer&gt; left = diffWaysToCompute(expression.substring(<span class="number">0</span>, index), map);</span><br><span class="line">            List&lt;Integer&gt; right = diffWaysToCompute(expression.substring(index + <span class="number">1</span>), map);</span><br><span class="line">            result.addAll(calc(left, right, expression.charAt(index)));</span><br><span class="line"></span><br><span class="line">            i = index + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.put(expression, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNextOpIndex</span><span class="params">(String expression, <span class="type">int</span> start)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; expression.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(expression.charAt(i)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">calc</span><span class="params">(List&lt;Integer&gt; left, List&lt;Integer&gt; right, <span class="type">char</span> op)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer leftValue : left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer rightValue : right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> value;</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    value = leftValue + rightValue;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    value = leftValue - rightValue;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    value = leftValue * rightValue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                result.add(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-242:Valid Anagram</title>
    <url>/leetCode/leetCode-242/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个字符串，要求判断两个字符串是否是异位词。异位词的定义：两个字符串的字符种类一样，每个种类的字符个数相同，不要求顺序相同。题目链接：<a href="https://leetcode.com/problems/valid-anagram/"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：s &#x3D; “anagram”, t &#x3D; “nagaram”</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：s &#x3D; “rat”, t &#x3D; “car”</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，因为题目限制了字符串只会由小写字母组成，所以，可以直接用数组表示每个字符的数量，然后比较数组是否相同，如果相同，则是异位词，否则不是。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] first = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] second = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            first[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            second[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first[i] != second[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-25:Reverse Nodes in k-Group</title>
    <url>/leetCode/leetCode-25/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表和一个正整数 k（k 的值小于链表的长度），要求将链表进行分组，每组 k 个节点，在每组中将链表进行倒序，如果最后一组没有 k 个节点，则不用进行逆序，最后将这些分组按顺序连接成新的链表并返回头节点。要求空间复杂度是 <code>O(1)</code>，并且不能改变链表节点中的值。题目链接：**<a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8    k &#x3D; 3</p>
<p>输出：3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;7-&gt;8</p>
</blockquote>
<blockquote>
<p>输入：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8    k &#x3D; 1</p>
<p>输出：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题是链表的基本操作。只需要将链表进行分组，在每组中将链表进行倒序即可。需要注意的是保持链表的连续性，即多个倒序后的分组需要能够连接起来成一个新的链表。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            length++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为了便于操作，定义一个临时的头节点放在链表前面</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pHead</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index + k &lt;= length)</span><br><span class="line">        &#123;</span><br><span class="line">            prev.next = reverseListNode(pHead, k);</span><br><span class="line">            <span class="comment">// k 个节点逆序后，pHead 指向的是该分组的最后一个节点</span></span><br><span class="line">            <span class="comment">// 为了使链表连续，此处需要更新 prev 指针位置</span></span><br><span class="line">            prev = pHead;</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">            index += k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将链表进行倒序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head   链表头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 链表长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 倒序后链表新的头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseListNode</span><span class="params">(ListNode head, <span class="type">int</span> length)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pNext</span> <span class="operator">=</span> p.next;</span><br><span class="line">            p.next = pNext.next;</span><br><span class="line">            pNext.next = head;</span><br><span class="line">            head = pNext;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-257:Binary Tree Paths</title>
    <url>/leetCode/leetCode-257/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉树，要求输出所有二叉树的路径（从根节点到叶子节点的路径），题目链接：<a href="https://leetcode.com/problems/binary-tree-paths"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：root &#x3D; [1,2,3,null,5]</p>
<p>输出：[“1-&gt;2-&gt;5”,”1-&gt;3”]</p>
<p>解释：输入的二叉树如下</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg"></p>
</blockquote>
<blockquote>
<p>输入：root &#x3D; [1]</p>
<p>输出：[1]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用先序遍历方式，将每个节点添加到路径上。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            result.add(String.valueOf(root.val));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;String&gt; left = binaryTreePaths(root.left);</span><br><span class="line">            merge(result, left, String.valueOf(root.val));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;String&gt; right = binaryTreePaths(root.right);</span><br><span class="line">            merge(result, right, String.valueOf(root.val));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(List&lt;String&gt; result, List&lt;String&gt; origin, String value)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String item : origin) &#123;</span><br><span class="line">            result.add(value + <span class="string">&quot;-&gt;&quot;</span> + item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-26:Remove Duplicates from Sorted Array</title>
    <url>/leetCode/leetCode-26/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个已经排序的数组，要求使用 <code>O(1)</code> 的空间复杂度剔除数组中的重复数字。题目链接：**<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1, 1, 2]</p>
<p>输出：[1, 2]</p>
</blockquote>
<blockquote>
<p>输入：[0, 0, 1, 1, 1, 2, 2, 3, 3, 4]</p>
<p>输出：[0, 1, 2, 3, 4]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用一个下标记录变化后的数组的当前位置，遍历原有数组，如果数组当前元素和下标元素相同，则说明是重复元素，此时下标不用动，继续遍历下一个数组元素，如果两者不同，则移动下标到下一个位置，并将当前数组元素填充到下标的位置。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[index])</span><br><span class="line">            &#123;</span><br><span class="line">                index++;</span><br><span class="line">                nums[index] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-260:Single Number III</title>
    <url>/leetCode/leetCode-260/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，数组中的数字有两个只出现一次，其他数字出现两次。要求在时间复杂度 <code>O(n)</code>、空间复杂度 <code>O(1)</code> 的情况下将这两个数字找出来。题目链接：**<a href="https://leetcode.com/problems/single-number-iii">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1, 2, 1, 3, 2, 5]</p>
<p>输出：[3, 5]</p>
</blockquote>
<blockquote>
<p>输入：[1, 3]</p>
<p>输出：[1, 3]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题最简单的做法是用 map 来存储数字出现的次数，但是这需要耗费 <code>O(n)</code> 的空间，不满足题目要求。因此需要考虑位运算的解法，此解法参考：<a href="https://leetcode-cn.com/problems/single-number-iii/solution/cai-yong-fen-zhi-de-si-xiang-jiang-wen-ti-jiang-we/%E3%80%82%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95%E6%98%AF%EF%BC%9A%E5%85%88%E5%B0%86%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%EF%BC%8C%E5%BE%97%E5%88%B0%E4%B8%A4%E4%B8%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97">https://leetcode-cn.com/problems/single-number-iii/solution/cai-yong-fen-zhi-de-si-xiang-jiang-wen-ti-jiang-we/。具体做法是：先将数组中数字进行异或运算，得到两个出现一次的数字</a> A、B 的异或值 X，因为 A、B 不相等，所以 X 不等于 0，那 X 必然存在至少一个位数为 1，根据 <code>x &amp; (-x)</code> 可以获得 X 的最低位为 1 的数，记为 mask，此时对数组中的每个数分别与 mask 进行与运算，可以将原数组分成两个部分：一个是结果为 0 的子数组，一个是结果为 1 的子数组。此时，数字相同（出现两次）的会被分配到同一个子数组中，而 A 和 B（只出现一次的数字）必然分配到不同的子数组中（因为是按照 A 和 B 的异或值的某一位为 1 来区分的）。可以看出，此时两个子数组的特点：只有一个数字出现一次，其他数字出现两次。那么此时求解就可以简化成：在两个子数组中，分别找出只出现一次的数字。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xorNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            xorNum ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> xorNum &amp; (-xorNum);</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; temp) == <span class="number">0</span>) &#123;</span><br><span class="line">                result[<span class="number">0</span>] ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[<span class="number">1</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/single-number-iii/solution/cai-yong-fen-zhi-de-si-xiang-jiang-wen-ti-jiang-we/">https://leetcode-cn.com/problems/single-number-iii/solution/cai-yong-fen-zhi-de-si-xiang-jiang-wen-ti-jiang-we/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-263:Ugly Number</title>
    <url>/leetCode/leetCode-263/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数，要求判断这个数是否是“丑数”。“丑数”定义：只能被 <code>2</code>、<code>3</code>、<code>5</code> 整除的正整数（<code>1</code> 是“丑数”）。题目链接：**<a href="https://leetcode.com/problems/ugly-number/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：6</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：7</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，直接按题意计算判断即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUgly</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span> || n == <span class="number">3</span> || n == <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (n % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; isUgly(n / <span class="number">2</span>)) || (n % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; isUgly(n / <span class="number">3</span>)) || (n % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; isUgly(n / <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-264:Ugly Number II</title>
    <url>/leetCode/leetCode-264/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个正整数 <code>n</code>，要求找出第 <code>n</code> 个“丑数”。“丑数”定义：只能被 <code>2</code>、<code>3</code>、<code>5</code> 整除的正整数（<code>1</code> 是“丑数”）。题目链接：**<a href="https://leetcode.com/problems/ugly-number-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：10</p>
<p>输出：12</p>
<p>解释：“丑数”序列为：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]，第10个数为12</p>
</blockquote>
<blockquote>
<p>输入：1</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>最简单粗暴的方法是对每个正整数依次判断是否是“丑数”，至到找到第 n 个数为止。但是这样做太耗时间。仔细观察“丑数”的定义，可以发现对于大于 1 的正整数，一个数要成为“丑数”，其必须是 <code>2</code>、<code>3</code>、<code>5</code> 的倍数。因此可以简化操作：对每个“丑数”，分别乘以  <code>2</code>、<code>3</code>、<code>5</code> ，得到新的“丑数”，对这些“丑数”进行排序，取出第 n 个数即可。这里可以使用最小堆来实现。但是最小堆内部依赖排序，其时间复杂度为 <code>O(nlgn)</code>，仍然偏大了一点，可以继续优化。</p>
<p>使用类似归并排序的做法，使用 3 路来分别计算当前路径的“丑数”与  <code>2</code>、<code>3</code>、<code>5</code> 相乘的值，每次取出最小的值放入“丑数”列表中，同时更新当前路径的“丑数”，将其更新为：“丑数”列表中，刚才剔除的“丑数”的下一个“丑数”。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] points = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] currents = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span>[] results = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        results[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minNum</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                currents[j] = nums[j] * results[points[j]];</span><br><span class="line">                minNum = Math.min(minNum, currents[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (currents[j] == minNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    points[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            results[index] = minNum;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-268:Missing Number</title>
    <url>/leetCode/leetCode-268/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个长度为 <code>n</code> 的非负整数数组，数组中元素均不相同，且元素都是 <code>[0, n]</code> 之间的某个数，要求找出数组中不在 <code>[0, n]</code> 中的数字。题目链接：<a href="https://leetcode.com/problems/missing-number"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [3,0,1]</p>
<p>输出：2</p>
<p>解释：数组长度为 3，所以元素范围为 [0, 3]，数组中只有元素 0、1、3，缺少 2，所以返回 2</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [0, 1, 2]</p>
<p>输出：3</p>
<p>解释：数组长度为 3，所以元素范围为 [0, 3]，数组中只有元素 0、1、2，缺少 3，所以返回 3</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单的做法是排序后遍历取出缺少的值，这样时间复杂度是 <code>O(nlogn)</code>，另一种降低时间复杂度的做法是使用 <code>set</code> 保存数组元素，然后遍历找出缺失的元素，这样时间复杂度是 <code>O(n)</code>，空间复杂度是 <code>O(n)</code>，再优化点的做法是使用原地哈希方式，将数组元素依次映射到正确位置上，然后遍历数组找出缺失的元素，这样时间复杂度是 <code>O(n)</code>，空间复杂度是 <code>O(1)</code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != nums.length &amp;&amp; nums[i] != i) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[temp];</span><br><span class="line">                nums[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-274:H-Index</title>
    <url>/leetCode/leetCode-274/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，代表一个作为每篇文章的引用次数，要求找出这个作者的H指数（该作者 <code>n</code> 篇文章中总共有 <code>h</code> 篇文章被引用了至少 h 次，剩下的 <code>n - h</code> 篇文章的引用次数不多于 <code>h</code>，如果 <code>h</code> 值有多个，取最大的那个）。题目链接：**<a href="https://leetcode.cn/problems/h-index">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[3,0,6,1,5]</p>
<p>输出：3</p>
</blockquote>
<blockquote>
<p>输入：[1,3,1]</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用排序，将文章引用次数从小到大排序，然后遍历数组，找到元素值大于等于剩下数组个数的地方，此时剩余数组的长度就是求解的答案。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">        Arrays.sort(citations);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; citations.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (citations[i] &gt;= citations.length - i) &#123;</span><br><span class="line">                <span class="keyword">return</span> citations.length - i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> citations[citations.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-275:H-Index II</title>
    <url>/leetCode/leetCode-275/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个排序的整数数组，代表一个作为每篇文章的引用次数，要求在 <code>log(n)</code> 的时间复杂度内找出这个作者的H指数（该作者 <code>n</code> 篇文章中总共有 <code>h</code> 篇文章被引用了至少 h 次，剩下的 <code>n - h</code> 篇文章的引用次数不多于 <code>h</code>，如果 <code>h</code> 值有多个，取最大的那个）。题目链接：**<a href="https://leetcode.com/problems/h-index-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[0,1,3,5,6]</p>
<p>输出：3</p>
</blockquote>
<blockquote>
<p>输入：[1,2,100]</p>
<p>输出：2</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题跟 <a href="https://guozhchun.github.io/leetCode/leetCode-274/">LeetCode-274</a> 类似，只不过本题给出的数组是已经排序好的，同时要求时间复杂度为 <code>log(n)</code>。因此可以按照 LeetCode-274 的思路，在这基础上进行二分查找即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> citations.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (citations[middle] == citations.length - middle) &#123;</span><br><span class="line">                <span class="keyword">return</span> citations.length - middle;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (citations[middle] &lt; citations.length - middle) &#123;</span><br><span class="line">                start = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> citations.length - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-279:Perfect Squares</title>
    <url>/leetCode/leetCode-279/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个正整数，存在一些完全平方数的和等于这个正整数，要求找出数量最小的完全平方数的个数。题目链接：**<a href="https://leetcode.com/problems/perfect-squares/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：12</p>
<p>输出：3</p>
<p>解释：12 &#x3D; 4 + 4 + 4</p>
</blockquote>
<blockquote>
<p>输入：13</p>
<p>输出：2</p>
<p>解释：13 &#x3D; 4 + 9</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用动态规划进行求解，用 <code>dp[n]</code> 表示构成的 n 的完全平方数的最小数量，动态转移方程为 <code>dp[n] = min(dp[n], dp[n - i * i])，其中 1 &lt;= i * i &lt;= n</code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i - j * j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-28:Implement strStr()</title>
    <url>/leetCode/leetCode-28/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出一个待匹配的字符串A和匹配的字符串B，要求判断B是否是A的子字符串。如果是则输出匹配的A字符串的起始下标，如果不是子字符串则输出-1。</p>
<p><em>注意：如果B字符串是空的，返回 0 ，这与<code>String.indexOf</code>函数效果相同</em></p>
<span id="more"></span>

<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="使用java的String类函数"><a href="#使用java的String类函数" class="headerlink" title="使用java的String类函数"></a>使用java的String类函数</h2><p>java库中的String类中已经有<code>indexOf</code>函数可以提供查找子字符串的功能，且其查询效果高效，一般情况下，都是使用此函数直接进行查找，无需自己重复造轮子，而且，即使自己造轮子也不一定比其高效。此实现方式代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack == <span class="literal">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="暴力查询"><a href="#暴力查询" class="headerlink" title="暴力查询"></a>暴力查询</h2><p>当没想到使用库函数时，第一反应是用暴力查询。即对遍历循环A字符串，在每个循环中依次遍历B字符串进行匹配，当全部匹配时，返回A字符串进行匹配的起始下标。循环结束后仍无匹配时返回-1。此种解法的时间复杂度是<code>O(n * m)</code>，其中 n 是A字符串长度，m 是B字符串长度。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack == <span class="literal">null</span> || needle == <span class="literal">null</span> || needle.length() &gt; haystack.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; haystack.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; needle.length(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + j &gt;= haystack.length() || haystack.charAt(i + j) != needle.charAt(j))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (j == needle.length())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h2><p>暴力查询的时间复杂度相对较高，在字符串比较长时效率低，因此可以使用kmp算法进行求解，此算法的时间复杂度为<code>O(m + n)</code>，其中 n 是A字符串长度，m 是B字符串长度。关于kmp算法可以参考**<a href="https://www.bilibili.com/video/av3246487/?from=search&seid=17173603269940723925">这里</a>**。代码实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getPartialMatchTable(String str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] partialMatchTable = <span class="keyword">new</span> <span class="title class_">int</span>[str.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        partialMatchTable[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; str.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (str.charAt(i) != str.charAt(pointer) &amp;&amp; pointer &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pointer = partialMatchTable[pointer - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == str.charAt(pointer))</span><br><span class="line">            &#123;</span><br><span class="line">                partialMatchTable[i] = pointer + <span class="number">1</span>;</span><br><span class="line">                pointer++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                partialMatchTable[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> partialMatchTable;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack == <span class="literal">null</span> || needle == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] partialMatchTable = getPartialMatchTable(needle);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; haystack.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(index))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (index == needle.length() - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> i - index;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                index++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    index = partialMatchTable[index - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>kmp</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-282:Expression Add Operators</title>
    <url>/leetCode/leetCode-282/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数字字符串和一个整数，在数字字符串中间插入 <code>+</code>、<code>-</code>、<code>*</code> 符号构成一个表达式，要求找出所有表达式的值等于目标数字的表达式。题目链接：**<a href="https://leetcode.com/problems/expression-add-operators/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：num &#x3D; “123”,  target &#x3D; 6</p>
<p>输出：[“1*2*3”, “1+2+3”]</p>
</blockquote>
<blockquote>
<p>输入：num &#x3D; “3456237490”, target &#x3D; 9191</p>
<p>输出：[]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>题目要求找出所有的结果，故只能用搜索进行求解。需要注意的是将字符串转成数字时以及运算过程中不要超过整形范围的边界，同时注意数字不能有前置0，但是数字0是允许出现的。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">maxValue</span> <span class="operator">=</span> String.valueOf(Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">addOperators</span><span class="params">(String num, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num.length(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">left</span> <span class="operator">=</span> num.substring(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!isValid(left)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">leftNum</span> <span class="operator">=</span> Integer.parseInt(left, <span class="number">10</span>);</span><br><span class="line">            nums.add(leftNum);</span><br><span class="line">            search(result, num, i + <span class="number">1</span>, nums, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), target);</span><br><span class="line">            nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(List&lt;String&gt; result, String num, <span class="type">int</span> start, List&lt;Integer&gt; nums, List&lt;Character&gt; ops, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == num.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isEqual(nums, ops, target)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> convert(nums, ops);</span><br><span class="line">                result.add(item);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; num.length(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">left</span> <span class="operator">=</span> num.substring(start, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!isValid(left)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">leftNum</span> <span class="operator">=</span> Integer.parseInt(left, <span class="number">10</span>);</span><br><span class="line">            nums.add(leftNum);</span><br><span class="line">            ops.add(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">            search(result, num, i + <span class="number">1</span>, nums, ops, target);</span><br><span class="line">            ops.set(ops.size() - <span class="number">1</span>, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">            search(result, num, i + <span class="number">1</span>, nums, ops, target);</span><br><span class="line">            ops.set(ops.size() - <span class="number">1</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">            search(result, num, i + <span class="number">1</span>, nums, ops, target);</span><br><span class="line"></span><br><span class="line">            nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">            ops.remove(ops.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">convert</span><span class="params">(List&lt;Integer&gt; nums, List&lt;Character&gt; ops)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(nums.get(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ops.size(); i++) &#123;</span><br><span class="line">            sb.append(ops.get(i)).append(nums.get(i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEqual</span><span class="params">(List&lt;Integer&gt; nums, List&lt;Character&gt; ops, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; numQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Character&gt; opQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        numQueue.addLast(nums.get(<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.size()) &#123;</span><br><span class="line">            numQueue.addLast(nums.get(i));</span><br><span class="line">            <span class="keyword">if</span> (ops.get(j) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> numQueue.pollLast();</span><br><span class="line">                <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> numQueue.pollLast();</span><br><span class="line">                <span class="comment">// 避免溢出</span></span><br><span class="line">                <span class="keyword">if</span> (first != <span class="number">0</span> &amp;&amp; Integer.MAX_VALUE / first &lt; second) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> first * second;</span><br><span class="line">                numQueue.addLast(temp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                opQueue.addLast(ops.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!opQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> numQueue.pollFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> numQueue.pollFirst();</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            <span class="keyword">if</span> (opQueue.pollFirst() == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                temp = first + second;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = first - second;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            numQueue.addFirst(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numQueue.pollFirst() == target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num.length() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num.length() &lt; maxValue.length() || num.compareTo(maxValue) &lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-289:Game of Life</title>
    <url>/leetCode/leetCode-289/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二维数组，数组每个元素表示一个细胞，数组值 0 表示细胞死亡，数组值 1 表示细胞生存。细胞在经过一轮细胞周期会根据下面规则改变其生存状态。</p>
<ul>
<li>如果细胞周围的八个细胞中的生存数量小于2个，则细胞死亡</li>
<li>如果细胞周围的八个细胞中的生存数量有两个或三个，则活细胞仍然生存</li>
<li>如果细胞周围的八个细胞中的生存数量大于3个，则细胞死亡</li>
<li>如果细胞周围的八个细胞中的生存数量刚好是3个，则死亡细胞会复活。</li>
</ul>
<p>给定一组细胞状态，要求在 <code>O(1)</code> 的空间复杂度内求出经过一轮细胞周期后的细胞状态，注意细胞状态变更是同时发生的，不能依赖于上一轮的变更。题目链接：**<a href="https://leetcode.com/problems/game-of-life/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[0,1,0],[0,0,1],[1,1,1],[0,0,0]]</p>
<p>输出：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]</p>
</blockquote>
<blockquote>
<p>输入：[[1,1],[1,0]]</p>
<p>输出：[[1,1],[1,1]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题不难，主要是读懂规则，其实就是周围的活细胞数量是 2 时状态保持不变，周围活细胞数量是 3 时细胞变活，其他情况细胞变死。另外需要注意的是需要 <code>O(1)</code> 的空间复杂度，也就是说不能新建数组，需要在原有的数组基础上进行修改，由于细胞状态的变更是同时发生的，因此不能在循环中直接将 <code>0</code> 变成 <code>1</code>，也不能在循环中将 <code>1</code> 直接变成 <code>0</code>，不然某个位置发生了变更，周围的细胞在进行判断时就会变成依赖变更后的状态了。针对此种情况，可以新增两个状态：活转死、死转活。在进行活细胞的判断时，把 “活转死” 这个状态考虑进去即可。最后再遍历数组把 “活转死”  状态变成 0， 把 “死转活” 状态变成 1。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DIE_TO_LIVE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LIVE_TO_DIE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gameOfLife</span><span class="params">(<span class="type">int</span>[][] board)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> calcLiveNeighbors(board, i, j);</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j] == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        board[i][j] = DIE_TO_LIVE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j] == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        board[i][j] = LIVE_TO_DIE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == DIE_TO_LIVE)</span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == LIVE_TO_DIE)</span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcLiveNeighbors</span><span class="params">(<span class="type">int</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">liveCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isValidCellLive(board, i - <span class="number">1</span>, j))</span><br><span class="line">        &#123;</span><br><span class="line">            liveCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isValidCellLive(board, i - <span class="number">1</span>, j + <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            liveCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isValidCellLive(board, i, j + <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            liveCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isValidCellLive(board, i + <span class="number">1</span>, j + <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            liveCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isValidCellLive(board, i + <span class="number">1</span>, j))</span><br><span class="line">        &#123;</span><br><span class="line">            liveCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isValidCellLive(board, i + <span class="number">1</span>, j - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            liveCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isValidCellLive(board, i, j - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            liveCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isValidCellLive(board, i - <span class="number">1</span>, j - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            liveCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> liveCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidCellLive</span><span class="params">(<span class="type">int</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;=<span class="number">0</span> &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length &amp;&amp; isLive(board[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isLive</span><span class="params">(<span class="type">int</span> cell)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> cell == <span class="number">1</span> || cell == LIVE_TO_DIE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-29:Divide Two Integers</title>
    <url>/leetCode/leetCode-29/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个被除数和除数（都是 <code>int</code>  类型），要求在不使用除法、乘法、求余运算的前提下，算出商。如果得出的结果超过 <code>int</code> 类型，则返回 <code>-2147483648</code> （商小于 -2147483648 时）或 <code>2147483647</code> （商大于 2147483647 时）。题目链接：**<a href="https://leetcode.com/problems/divide-two-integers/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：10   3</p>
<p>输出：3</p>
</blockquote>
<blockquote>
<p>输入：-7    3</p>
<p>输出：-2</p>
</blockquote>
<blockquote>
<p>输入：-2147483648    1</p>
<p>输出：2147483647</p>
<p>解释：在数学上，-2147483648 &#x2F; 1 &#x3D; -2147483648，但是这个结果超过 int 类型的存储范围，所以返回结果是 int 类型的最大值 2147483647</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此问题要求不能使用除法、乘法和求余运算，因此最简单的做法就是暴力相减，从被除数中一直减去除数，直到被除数小于除数，记录相减的次数，即使商。但是，这种做法超时了。</p>
<p>根据题目的提示，可以使用二分查找的思路进行求解。当一个数 <code>A1</code> 除以 2 后，其结果 <code>A2</code> 小于被除数<code>B</code>时，说明 <code>A1</code> 除 <code>B</code> 的商是 1，如果 <code>A2</code> 大于被除数，说明 <code>A1 / B</code> 的商至少是 <code>A2 / B</code> 的商的两倍。顺着这个思路，可以一直将被除数除 2 后与除数进行比较，直到被除数小于除数时，记录相除的次数 n，此时可以根据相除的次数得到最小的商是 <code>2^(n - 1)</code>，同时将最开始的被除数减去 <code>除数 * 2^(n - 1)</code>得到新的被除数，将新的被除数与除数进行新的相除计算得到其结果，最后将这两个结果进行相加得到最终的商。由于整个过程是对 2 进行相除和相乘的操作，可以用相应的位运算进行代替，从而避免使用乘法和除法。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先于 divisor == Integer.MIN_VALUE 的判断</span></span><br><span class="line">        <span class="comment">// 主要是为了避免 divisor 和 divisor 都是 Integer.MIN_VALUE 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == divisor)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先在此处进行判断，主要是为了后续方便对 divisor 转换成整数的操作</span></span><br><span class="line">        <span class="keyword">if</span> (divisor == Integer.MIN_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 确保除数大于 0</span></span><br><span class="line">        <span class="keyword">if</span> (divisor &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sign = -sign;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 确保被除数大于 0</span></span><br><span class="line">        <span class="keyword">if</span> (dividend &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sign = -sign;</span><br><span class="line">            <span class="comment">// 保证将被除数转为正数后不会超出整数的范围</span></span><br><span class="line">            <span class="keyword">if</span> (dividend == Integer.MIN_VALUE)</span><br><span class="line">            &#123;</span><br><span class="line">                dividend += divisor;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 经过上述操作，已经将被除数和除数转成正数，此处进行正数相除操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">quotient</span> <span class="operator">=</span> dividePositiveNum(dividend, divisor);</span><br><span class="line">        <span class="comment">// 确保结果不会超过整数的范围</span></span><br><span class="line">        <span class="keyword">if</span> (quotient &gt; Integer.MAX_VALUE - count)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> sign &gt; <span class="number">0</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count = count + quotient;</span><br><span class="line">        <span class="keyword">return</span> sign &gt; <span class="number">0</span> ? count: -count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dividePositiveNum</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dividend &lt; divisor)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (dividend == divisor)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此处初始化为 -1，避免后续对其进行减一操作</span></span><br><span class="line">        <span class="comment">// 程序运行到此处时， dividend 必然大于 divisor，则 powCount 必然大于等于 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">powCount</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempDividend</span> <span class="operator">=</span> dividend;</span><br><span class="line">        <span class="keyword">while</span> (tempDividend &gt; divisor)</span><br><span class="line">        &#123;</span><br><span class="line">            tempDividend = tempDividend &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            powCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">partQuotient</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; powCount;</span><br><span class="line">        <span class="type">int</span> <span class="variable">partMultiNum</span> <span class="operator">=</span> divisor &lt;&lt; powCount;</span><br><span class="line">        <span class="type">int</span> <span class="variable">remaindDividend</span> <span class="operator">=</span> dividend - partMultiNum;</span><br><span class="line">        <span class="keyword">return</span> partQuotient + dividePositiveNum(remaindDividend, divisor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-292:Nim Game</title>
    <url>/leetCode/leetCode-292/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>有这么一个游戏：两人对玩，有这么一堆石头，每次都从石头中取出 <code>1</code> 或 <code>2</code> 或 <code>3</code> 个石头，最后一个石头是谁拿走则谁胜出。现在给定一个数字表示有 <code>n</code> 个石头，要求游戏中先手是否能获胜。题目链接：<a href="https://leetcode.com/problems/nim-game"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：4</p>
<p>输出：false</p>
<p>解释：假设先手拿了 1 个石头，则后手拿走剩下 3 个石头（包含最后一块石头），先手输</p>
<p>假设先手拿了 2 个石头，则后手拿走剩下 2 个石头（包含最后一块石头），先手输</p>
<p>假设先手拿了 3 个石头，则后手拿走剩下 1 个石头（包含最后一块石头），先手输</p>
</blockquote>
<blockquote>
<p>输入：2</p>
<p>输出：true</p>
<p>解释：先手一次行拿走 2 个石头（包含最后一个石头），先手赢</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>石头在 <code>[1, 3]</code> 范围内，先手都赢，因为可以直接拿走所有的石头（包括最后一个石头），石头数量是 <code>4</code> 的时候，先手都输，因为无论先手拿 <code>[1, 3]</code> 中的任何一个石头，后手都可以直接拿走剩下的全部石头（包括最后一个石头）。如果石头数量是 <code>5</code>，则先手可以拿走 <code>1</code> 个石头，剩下的 <code>4</code> 个石头无论后手如何取都会失败（前面论证过 <code>4</code> 个石头的情况下先拿的人会失败），即先手胜。如果石头数量是 <code>6</code>，则先手可以拿走 <code>2</code> 个石头，剩下 <code>4</code> 个石头无论后手如何选择最终都会输掉游戏，即先手胜利。如果石头数量是 <code>7</code>，则先手可以拿走 <code>3</code>  个石头，剩下 <code>4</code> 个石头无论后手如何选择最终都会输掉游戏，即先手胜利。如果石头数量是 <code>8</code>，则先手无论取走多少个石头，后手都能将剩下的石头数变成 <code>4</code>（如果先手取 <code>1</code>，则后手取 <code>3</code>；如果先手取 <code>2</code>，则后手取 <code>2</code>；如果先手取 <code>3</code>，则后手取 <code>1</code>），此时先手无论如何取石头最终都会输掉游戏（参考前面对石头数量为 <code>4</code> 的分析）。如果石头数量是 <code>9</code>，则先手可以拿走 <code>1</code> 个石头，剩下 <code>8</code> 个石头无论后手如何取都会失败（最终表现为先手胜利），依次类推，可以得知，如果石头数量是 <code>4</code> 的倍数，则先手失败，否则先手胜利。因此，次题解转换为对 <code>n % 4</code> 的判断。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-284:Peeking Iterator</title>
    <url>/leetCode/leetCode-284/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>要求实现一个迭代器，其中有三个方法 ：</p>
<ul>
<li><p><code>peek</code>：返回顶端元素，但是不移动指针（也就是说多次调用获取到的值是相同的）。</p>
</li>
<li><p><code>next</code>：返回顶端元素，移动指针到下个位置（也就是说多次调用获取到的值是不同的）。</p>
</li>
<li><p><code>hasNext</code>：判断是否存在下个元素。</p>
</li>
</ul>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：<br>[“PeekingIterator”, “next”, “peek”, “next”, “next”, “hasNext”]<br>[[[1, 2, 3]], [], [], [], [], []]</p>
<p>输出：[null, 1, 2, 2, 3, false]</p>
<p>解释：<br>PeekingIterator peekingIterator &#x3D; new PeekingIterator([1, 2, 3]); &#x2F;&#x2F; [<u>1</u>,2,3]<br>peekingIterator.next();    &#x2F;&#x2F; return 1, the pointer moves to the next element [1,<u>2</u>,3].<br>peekingIterator.peek();    &#x2F;&#x2F; return 2, the pointer does not move [1,<u>2</u>,3].<br>peekingIterator.next();    &#x2F;&#x2F; return 2, the pointer moves to the next element [1,2,<u>3</u>]<br>peekingIterator.next();    &#x2F;&#x2F; return 3, the pointer moves to the next element [1,2,3]<br>peekingIterator.hasNext(); &#x2F;&#x2F; return False</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题的迭代器跟其他的迭代器差不多，只不过多了个 <code>peek</code> 函数要实现。针对这个函数，可以从 <code>next</code> 函数获取到值并缓存起来，后续调用时先判断是否存在该缓存，存在则返回缓存，否则直接调用 <code>next</code> 获取下个元素的值。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java Iterator interface reference:</span></span><br><span class="line"><span class="comment">// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PeekingIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> Iterator&lt;Integer&gt; it;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> Integer top;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">PeekingIterator</span><span class="params">(Iterator&lt;Integer&gt; iterator)</span> &#123;</span><br><span class="line">            <span class="comment">// initialize any member here.</span></span><br><span class="line">            it = iterator;</span><br><span class="line">            top = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="literal">null</span>) &#123;</span><br><span class="line">                top = it.next();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> top;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hasNext() and next() should behave the same as in the Iterator interface.</span></span><br><span class="line">        <span class="comment">// Override them if needed.</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (top != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">temp</span> <span class="operator">=</span> top;</span><br><span class="line">                top = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> it.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> top != <span class="literal">null</span> || it.hasNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-295:Find Median from Data Stream</title>
    <url>/leetCode/leetCode-295/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>要求实现一个类，类中有两个功能，一个是往类中添加整数，另一个是求已添加的整数列表中的中位数。题目链接：<a href="https://leetcode.com/problems/find-median-from-data-stream/"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<p>[“MedianFinder”, “addNum”, “addNum”, “findMedian”, “addNum”, “findMedian”]<br>[[], [1], [2], [], [3], []]</p>
<p>输出：[null, null, null, 1.5, null, 2.0]</p>
<p>解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MedianFinder medianFinder = new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    // arr = [1]</span><br><span class="line">medianFinder.addNum(2);    // arr = [1, 2]</span><br><span class="line">medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)</span><br><span class="line">medianFinder.addNum(3);    // arr[1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); // return 2.0</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>输入：</p>
<p>[“MedianFinder”, “addNum”, “findMedian”]<br>[[], [1], []]</p>
<p>输出：[null, null, 1.0]</p>
<p>解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MedianFinder medianFinder = new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    // arr = [1]</span><br><span class="line">medianFinder.findMedian(); // return 1.0</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>维护两个优先队列（大小堆），大堆堆顶元素和小堆堆顶元素对应着中位数，大堆的元素始终不大于小堆中的元素。如果数列总数是奇数，则返回大堆的堆顶元素，如果队列总数是偶数，是取大堆和小堆的堆顶元素的平均值。在处理 <code>addNum</code> 时，先判断当前已有的元素个数，如果当前是奇数的，那新增的值会让小堆元素加一，如果此时大堆堆顶元素比当前元素大，则需要从大堆中取出堆顶元素放如小堆中，然后将当前元素放如大堆中，否则，直接将当前元素放如小堆中。反之亦然。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; oddQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; evenQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isOddNow</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        oddQueue.clear();</span><br><span class="line">        evenQueue.clear();</span><br><span class="line">        isOddNow = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">oddNum</span> <span class="operator">=</span> oddQueue.peek();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">evenNum</span> <span class="operator">=</span> evenQueue.peek();</span><br><span class="line">        <span class="keyword">if</span> (isOddNow) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oddNum &gt; num) &#123;</span><br><span class="line">                oddQueue.poll();</span><br><span class="line">                oddQueue.offer(num);</span><br><span class="line">                evenQueue.offer(oddNum);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                evenQueue.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">            isOddNow = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (evenNum != <span class="literal">null</span> &amp;&amp; evenNum &lt; num) &#123;</span><br><span class="line">                evenQueue.poll();</span><br><span class="line">                evenQueue.offer(num);</span><br><span class="line">                oddQueue.offer(evenNum);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                oddQueue.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">            isOddNow = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOddNow) &#123;</span><br><span class="line">            <span class="keyword">return</span> oddQueue.peek();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (oddQueue.peek() + evenQueue.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-297:Serialize and Deserialize Binary Tree</title>
    <url>/leetCode/leetCode-297/</url>
    <content><![CDATA[<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>给定一个二叉树，要求将树进行序列化和反序列化。题目链接：**<a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3]</p>
<p>输出：[1,2,3]</p>
<p>说明：表示树</p>
<p> 1</p>
<p>&#x2F; \ </p>
<p>2 3</p>
</blockquote>
<blockquote>
<p>输入：[]</p>
<p>输出：[]</p>
</blockquote>
<h1 id="问题解法-1"><a href="#问题解法-1" class="headerlink" title="问题解法"></a>问题解法</h1><p>参考 LeetCode 里对二叉树的表现方式，使用广度优先搜索算法对树进行序列化和反序列化。在序列化过程总，遇到节点是叶子节点时，需要将其左右孩子表示为 <code>NULL</code> 进行输出，以方便后续的反序列化操作。</p>
<p>在进行反序列化过程中，每次读取同一层级的节点进行处理 ，这样可以保证让数组的指针依次移动。由于每个节点的左右孩子都是在相邻的，所以在处理节点时可以顺序读取。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="string">&quot;NULL&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SEPARATOR</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">                sb.append(SEPARATOR).append(NULL);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(SEPARATOR).append(node.val);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sb.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            sb = sb.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        String[] strs = data.split(SEPARATOR);</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span> || strs[<span class="number">0</span>].equals(NULL)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(strs[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> count; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (!strs[index].equals(NULL)) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(strs[index]));</span><br><span class="line">                    current.left = left;</span><br><span class="line">                    queue.add(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!strs[index + <span class="number">1</span>].equals(NULL)) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(strs[index + <span class="number">1</span>]));</span><br><span class="line">                    current.right = right;</span><br><span class="line">                    queue.add(right);</span><br><span class="line">                &#125;</span><br><span class="line">                index += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-299:Bulls and Cows</title>
    <url>/leetCode/leetCode-299/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出两个由数字组成的相等长度的字符串，要求找出两个字符串相同位置字符相同的个数，以及第二个字符串中在第一个字符串中出现的字符非相同位置字符的个数。题目链接：**<a href="https://leetcode.com/problems/bulls-and-cows/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：secret &#x3D; “1807”, guess &#x3D; “7810”</p>
<p>输出：”1A3B”</p>
<p>解释：第二个位置相同，数字为 8，其他的数字均在两个字符串中出现，总共 3 个</p>
</blockquote>
<blockquote>
<p>输入：secret &#x3D; “1123”, guess &#x3D; “0111”</p>
<p>输出：”1A1B”</p>
<p>解释：第二个位置相同，数字为 1，剩下 1、3、4位置中，数字为 1 同时存在两个字符串，所以数量为 1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，直接按照题意进行模拟即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHint</span><span class="params">(String secret, String guess)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Set&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; secret.length(); i++) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> secret.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            map.computeIfAbsent(num, key -&gt; <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;()).add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">bullsCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; guess.length(); i++) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> guess.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            Set&lt;Integer&gt; set = map.get(num);</span><br><span class="line">            <span class="keyword">if</span> (set == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (set.contains(i)) &#123;</span><br><span class="line">                bullsCount++;</span><br><span class="line">                set.remove(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[num]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">cowsCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            cowsCount += Math.min(map.getOrDefault(i, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;()).size(), nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bullsCount + <span class="string">&quot;A&quot;</span> + cowsCount + <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-3:Longest Substring Without Repeating Characters</title>
    <url>/leetCode/leetCode-3/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串，找出其中不包含重复字符的连续最长子字符串的长度。题目链接：**<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：”abcabcbb”</p>
<p>输出：3</p>
</blockquote>
<blockquote>
<p>输入：”pwwkew”</p>
<p>输出：3</p>
</blockquote>
<blockquote>
<p>输入：”aaaaa”</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h2><p>定义一个<code>HashSet</code>，用于存放已经遍历过的字符，然后用两层for循环，第一层for循环主要是遍历子字符串开始的位置，第二层for循环主要是遍历字符串结束的位置，在第二层循环中，因此判断结尾的字符是否已经出现过，如果出现过，则记录此时字符串的长度，退出循环，最后取出最长的长度返回。此算法时间复杂度为<code>O(n^2)</code>。代码实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            set.clear();</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(s.charAt(j)))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    set.add(s.charAt(j));</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (count &gt; result)</span><br><span class="line">            &#123;</span><br><span class="line">                result = count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="窗口移动法"><a href="#窗口移动法" class="headerlink" title="窗口移动法"></a>窗口移动法</h2><p>此方法主要参考leetcode上文章的解法，详细参考点**<a href="https://leetcode.com/articles/longest-substring-without-repeating-characters/">这里</a>**。</p>
<p>实现思路是定义一个可变的窗口在字符串上移动，刚开始时<code>startIndex = 0, endIndex = 0</code>，依次遍历字符串，依次增加<code>endIndex</code>的值（改变窗口的大小），在遍历的过程中如果没有遇到重复的字符，则结束返回长度，否则，此时窗口中最长的没有重复字符串的下标位置是<code>[startIndex ~ endIndex)</code>，据此可以计算出长度并与最大长度进行比较，然后改变窗口大小，此时需要改变<code>startIndex</code>的位置。如何确定<code>startIndex</code>的位置呢？取出上一个重复字符的下标位置<code>k</code>，判断这个位置是否在<code>[startIndex ~ endIndex)</code>中，如果在这个区间中，则改变<code>startIndex</code>的值为<code>k + 1</code>，否则不用改变。</p>
<p>至于为什么可以直接跳过那么多的字符到上一次重复字符的下一个位置呢（这里假设<code>startIndex &lt;= k &lt; endIndex</code>，关于<code>startIndex &gt; k</code>的情况上面已经做出解释）？因为在<code>k</code>和<code>endIndex</code>位置的字符是相同的，所以以<code>[startIndex, k]</code>区间中的位置到<code>endIndex</code>的位置组成的字符串必然有重复的字符存在，此时可以转换为求<code>[startIndex, k -1]</code>组成的字符串的最大长度和<code>[k + 1, endIndex]</code>组成的字符串的最大长度，而<code>[startIndex, k -1]</code>组成的字符串的最大长度在前面的循环中已经求出，<code>[k + 1, endIndex]</code>组成的字符串的最大长度在下一次循环中可以求出。因此当有重复字符时，可以直接将窗口开始的位置跳到上一个重复字符出现的位置（先决条件：<code>startIndex &lt;= k</code>）。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 当前字符已经存在时，假设存在的位置为k，则[startIndex, k]中的任何位置到i这个位置</span></span><br><span class="line">			<span class="comment">// 组成的字符串均有重复字符，不用比较，可以直接从k + 1的位置到i的位置组成的字符串进行比较</span></span><br><span class="line">			<span class="comment">// map.get(s.charAt(i)) &gt;= startIndex 条件必须存在，否则字符串是tmmzuxt时</span></span><br><span class="line">			<span class="comment">// 输出是4而不是5，条件map.get(s.charAt(i)) &gt;= startIndex是保证 </span></span><br><span class="line">			<span class="comment">// startIndex &lt;= k &lt;= i的</span></span><br><span class="line">			<span class="keyword">if</span> (map.containsKey(s.charAt(i)) &amp;&amp; map.get(s.charAt(i)) &gt;= startIndex)</span><br><span class="line">			&#123;</span><br><span class="line">				count = i - startIndex;</span><br><span class="line">				startIndex = map.get(s.charAt(i)) + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				count = i - startIndex + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			map.put(s.charAt(i), i);</span><br><span class="line">			<span class="keyword">if</span> (count &gt; result)</span><br><span class="line">			&#123;</span><br><span class="line">				result = count;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-30:Substring with Concatenation of All Words</title>
    <url>/leetCode/leetCode-30/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串和有相同长度的字符串组成的字符串数组（数组元素允许重复），要求找出字符串中所有由该数组的字符串（允许乱序）拼接而成的子字符串的起始下标。题目链接：**<a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：”barfoothefoobarman”    [“foo”,”bar”]</p>
<p>输出：[0, 9]</p>
<p>解释： [“foo”,”bar”] 可以构成两个子字符串，”foobar” 和 “barfoo”，其中 “foobar” 出现在 “barfoothefoobarman” 的 9 ~ 14 （从 0 开始计算），”barfoo” 出现在 “barfoothefoobarman” 的 0 ~ 5 （从 0 开始计算）的位置，因此返回列表 [0, 9]</p>
</blockquote>
<blockquote>
<p>输入：”wordgoodgoodgoodbestword”   [“word”,”good”,”best”,”word”]</p>
<p>输出：[]</p>
<p>解释： [“word”,”good”,”best”,”word”] 构成的所有的字符串均不是 “wordgoodgoodgoodbestword” 的子字符串，所以返回空的列表</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>先用一个 map 将字符串数组中的字符串保存起来，然后遍历原始的字符串，截取固定长度（字符串数组中所有字符串的长度总和）的字符串，再从这个子字符串中依次取出每个 word 串，与 map 中保存的元素进行比较，如果不存在 map 中，说明截取的这个子字符串不满足条件，直接进入下一轮循环。当每个 word 串都存在 map 中并且每个 word 数量刚好与 map 中对应元素的数量相等时，说明截取的子字符串满足题目要求，此时记录截取的字符串的开始位置，继续下一轮循环。待循环结束时，返回每个下标组成的列表即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span> || words == <span class="literal">null</span> || words.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Integer&gt; wordMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> wordMap.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            wordMap.put(word, count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">wordLength</span> <span class="operator">=</span> words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + wordLength * words.length &gt; s.length())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Map&lt;String, Integer&gt; workMapCopy = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(wordMap);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; words.length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> s.substring(i + j * wordLength, i + (j + <span class="number">1</span>) * wordLength);</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> workMapCopy.get(word);</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    workMapCopy.remove(word);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    workMapCopy.put(word, count - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (workMapCopy.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-300:Longest Increasing Subsequence</title>
    <url>/leetCode/leetCode-300/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，要求找出其中最长单调递增的子序列的长度。题目链接：**<a href="https://leetcode.com/problems/longest-increasing-subsequence/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[10,9,2,5,3,7,101,18]</p>
<p>输出：4</p>
<p>解释：最长单调递增子序列为：[2,3,7,101]</p>
</blockquote>
<blockquote>
<p>输入：[1,1]</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><p>使用动态规划，用 <code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾构成的子数组的最长单调递增子序列的长度，则动态转移方程为 <code>dp[i] = if (nums[j] &lt; nums[i]) max(dp[j] + 1), (0 &lt; j &lt; i)</code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i] &amp;&amp; dp[j] &gt;= dp[i]) &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = Math.max(result, dp[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：贪心-二分法"><a href="#解法二：贪心-二分法" class="headerlink" title="解法二：贪心+二分法"></a>解法二：贪心+二分法</h2><p>此解法参考<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/%E3%80%82%E4%B8%BB%E8%A6%81%E5%81%9A%E6%B3%95%E6%98%AF%EF%BC%9A%E7%94%A8">https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/。主要做法是：用</a> <code>dp[i]</code> 表示以 <code>i + 1</code> 个元素构成的单调递增数列的<strong>最后一个元素的最小值</strong>，遍历原数组，如果当前元素比 dp 数组最后一个元素大，则直接加到 dp 数组中，如果比它小，则在 dp 数组中找到第一个比它大的元素，然后将这个 dp 元素替换成当前 nums 数组的元素。由于 dp 数组是一个单调递增的数组，所以在上述的搜索过程中可以使用二分查找进行搜索。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[len - <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">                dp[len] = nums[i];</span><br><span class="line">                len++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">                middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (dp[middle] == nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[middle] &lt; nums[i]) &#123;</span><br><span class="line">                    start = middle + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    end = middle - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dp[middle] &lt; nums[i]) &#123;</span><br><span class="line">                dp[middle + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[middle] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/">https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-301:Remove Invalid Parentheses</title>
    <url>/leetCode/leetCode-301/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个包含 <code>(</code>、<code>)</code> 和字母的字符串，要求去除字符串中的某些字符，使其满足括号匹配。要求找出所有删除字符数最小的字符串。题目链接：**<a href="https://leetcode.com/problems/remove-invalid-parentheses/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：s &#x3D; “(a)())()”</p>
<p>输出：[“(a())()”,”(a)()()”]</p>
</blockquote>
<blockquote>
<p>输入：s &#x3D; “)(“</p>
<p>输出：[“”]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>题目要求找出所有满足要求的字符串，所以只能用遍历搜索的方式，为了提高效率，在搜索过程中需要进行剪枝，比如已经搜索过的字符串就不要再进行搜索，又比如待搜索的字符串长度小于已经找到的满足要求的字符串长度就不用再进行搜索。另一个优化的地方就是判断字符串是否满足括号匹配的规则，不是使用栈，而是直接用数量进行判断。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">removeInvalidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; candidates = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; used = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        search(s, candidates, used);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> candidates.stream().mapToInt(String::length).max().getAsInt();</span><br><span class="line">        <span class="keyword">return</span> candidates.stream().filter(item -&gt; item.length() == maxLength).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(String str, Set&lt;String&gt; candidates, Set&lt;String&gt; used)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.length() &lt; length || used.contains(str)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> isValid(str);</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.length() &gt;= length) &#123;</span><br><span class="line">                candidates.add(str);</span><br><span class="line">                length = str.length();</span><br><span class="line">                used.add(str);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27;(&#x27;</span> || str.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> str.substring(<span class="number">0</span>, i) + str.substring(i + <span class="number">1</span>);</span><br><span class="line">                search(temp, candidates, used);</span><br><span class="line">                used.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                leftCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                leftCount--;</span><br><span class="line">                <span class="keyword">if</span> (leftCount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftCount == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-303:Range Sum Query - Immutable</title>
    <url>/leetCode/leetCode-303/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整形数组，要求多次查询数组中某个区间的元素之和。题目链接：**<a href="https://leetcode.com/problems/range-sum-query-immutable/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<p>[“NumArray”, “sumRange”, “sumRange”, “sumRange”]<br>[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</p>
<p>输出：[null, 1, -1, -3]</p>
<p>解释：</p>
<p>NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);<br>numArray.sumRange(0, 2); &#x2F;&#x2F; return (-2) + 0 + 3 &#x3D; 1<br>numArray.sumRange(2, 5); &#x2F;&#x2F; return 3 + (-5) + 2 + (-1) &#x3D; -1<br>numArray.sumRange(0, 5); &#x2F;&#x2F; return (-2) + 0 + 3 + (-5) + 2 + (-1) &#x3D; -3</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>最直接的方式就是按照输入的下标，使用循环进行累加，这对一次查询是有效的，不过在多次查询的情况下，如果每次都使用循环进行累加，时间复杂度比较高。优化点的做法是使用数组保存当前元素之前所有元素的和（包括当前元素），然后在输入下标计算区间和的时候使用 <code>dp[right] - dp[left - 1]</code> 即可获得答案。这样多次查询的情况下也只有一次循环，时间复杂度为 <code>O(n)</code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] prefixSum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        prefixSum = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        prefixSum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            prefixSum[i] = prefixSum[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> prefixSum[right];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prefixSum[right] - prefixSum[left - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(left,right);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-304:Range Sum Query 2D - Immutable</title>
    <url>/leetCode/leetCode-304/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二维整形数组，要求多次查询某个子矩阵的和。题目链接：**<a href="https://leetcode.com/problems/range-sum-query-2d-immutable/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<p>[“NumMatrix”, “sumRegion”, “sumRegion”, “sumRegion”]<br>[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]</p>
<p>输出：</p>
<p>[null, 8, 11, 12]</p>
<p>解释：</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/sum-grid.jpg" alt="sample-picture"></p>
<p>NumMatrix numMatrix &#x3D; new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);<br>numMatrix.sumRegion(2, 1, 4, 3); &#x2F;&#x2F; return 8 (i.e sum of the red rectangle)<br>numMatrix.sumRegion(1, 1, 2, 2); &#x2F;&#x2F; return 11 (i.e sum of the green rectangle)<br>numMatrix.sumRegion(1, 2, 2, 4); &#x2F;&#x2F; return 12 (i.e sum of the blue rectangle)</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题最直接的做法就是每次查询都遍历子矩阵的值进行累加，不过这对单次查询是有效的，但是对于多次查询这效率就有点低，所以高效一点的做法是使用前缀和的思路，先对矩阵进行求和。用 <code>dp[i][j]</code> 表示从矩阵的左顶点到 <code>(i, j)</code> 节点的子矩阵的元素和。则 <code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j -1] + matrix[i][j]</code>。对于求解 <code>(row1, col1)</code> 到 <code>(row2, col2)</code> 的子矩阵的元素之和，其结果可以用 <code>dp[row2][col2] - dp[row2][col1 - 1] - dp[row1 - 1][col2] + dp[row1 - 1][col1 - 1]</code> 来表示。这样，多次查询的时间复杂度就控制在 <code>O(1)</code> 内，只需要在开始的地方用 <code>O(n * n)</code> 的时间复杂度构造 <code>dp</code> 数组即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] matrixSum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        matrixSum = <span class="keyword">new</span> <span class="title class_">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                matrixSum[i][j] = matrix[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    matrixSum[i][j] += matrixSum[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    matrixSum[i][j] += matrixSum[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    matrixSum[i][j] -= matrixSum[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> matrixSum[row2][col2];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (row1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result -= matrixSum[row1 - <span class="number">1</span>][col2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (col1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result -= matrixSum[row2][col1 - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (row1 &gt; <span class="number">0</span> &amp;&amp; col1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result += matrixSum[row1 - <span class="number">1</span>][col1 - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-306:Additive Number</title>
    <url>/leetCode/leetCode-306/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整形数字的字符串，要求判断该字符串数字是否是叠加数（叠加数指可以将字符串数字拆分成多个数字，这几个数字构成一个斐波那契数列，注意：拆分出来数不能包含前置 0）。题目链接：**<a href="https://leetcode.com/problems/additive-number/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：112358</p>
<p>输出：true</p>
<p>解释：可以将数字拆分成：1、1、2、3、5、8</p>
<p>1 + 1 &#x3D; 2</p>
<p>1 + 2 &#x3D; 3</p>
<p>2 + 3 &#x3D; 5</p>
<p>3 + 5 &#x3D; 8</p>
</blockquote>
<blockquote>
<p>输入：199100199</p>
<p>输出：true</p>
<p>解释：可以将数字拆分成：1、99、100、199</p>
<p>1 + 99 &#x3D; 100</p>
<p>99 + 100 &#x3D; 199</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用暴力查找的方式，依次将字符串数拆分成多个数字的数列，然后判断是否满足前两个数的和等于第三个数。需要注意的时，拆分出来的数可能比较大，需要进行大数相加。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAdditiveNumber</span><span class="params">(String num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> search(num, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String num, <span class="type">int</span> firstStart)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">firstEnd</span> <span class="operator">=</span> firstStart; firstEnd &lt; num.length(); firstEnd++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstEnd - firstStart + <span class="number">1</span> &gt; num.length() - firstEnd - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">secondStart</span> <span class="operator">=</span> firstEnd + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">secondEnd</span> <span class="operator">=</span> secondStart; secondEnd &lt; num.length(); secondEnd++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (secondEnd - secondStart + <span class="number">1</span> &gt; num.length() - secondEnd - <span class="number">1</span> || firstEnd - firstStart + <span class="number">1</span> &gt; num.length() - secondEnd - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (num.charAt(secondStart) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; secondEnd &gt; secondStart) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">thirdStart</span> <span class="operator">=</span> secondEnd + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">thirdEnd</span> <span class="operator">=</span> thirdStart; thirdEnd &lt; num.length(); thirdEnd++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num.charAt(thirdStart) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; thirdEnd &gt; thirdStart) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> compare(num, firstStart, firstEnd, secondStart, secondEnd, thirdStart, thirdEnd);</span><br><span class="line">                    <span class="keyword">if</span> (temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (thirdEnd == num.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (search(num, secondStart)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String num, <span class="type">int</span> firstStart, <span class="type">int</span> firstEnd, <span class="type">int</span> secondStart, <span class="type">int</span> secondEnd, <span class="type">int</span> thirdStart, <span class="type">int</span> thirdEnd)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> add(num, firstStart, firstEnd, secondStart, secondEnd);</span><br><span class="line">        <span class="keyword">return</span> compare(str, num, thirdStart, thirdEnd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String str, String num, <span class="type">int</span> thirdStart, <span class="type">int</span> thirdEnd)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">thirdLength</span> <span class="operator">=</span> thirdEnd - thirdStart + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (str.length() &lt; thirdLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (str.length() &gt; thirdLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; thirdLength; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == num.charAt(thirdStart + i)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> str.charAt(i) - num.charAt(thirdStart + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">add</span><span class="params">(String num, <span class="type">int</span> firstStart, <span class="type">int</span> firstEnd, <span class="type">int</span> secondStart, <span class="type">int</span> secondEnd)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstEnd;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> secondEnd;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= firstStart &amp;&amp; j &gt;= secondStart) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> carry + num.charAt(i) - <span class="string">&#x27;0&#x27;</span> + num.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            sb.append(temp % <span class="number">10</span>);</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &gt;= firstStart; k--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> carry + num.charAt(k) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            sb.append(temp % <span class="number">10</span>);</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j; k &gt;= secondStart; k--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> carry + num.charAt(k) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            sb.append(temp % <span class="number">10</span>);</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(carry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-307:Range Sum Query - Mutable</title>
    <url>/leetCode/leetCode-307/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，数组中元素可以发生改变，要求多次查询数组中的区间和。题目链接：**<a href="https://leetcode.com/problems/range-sum-query-mutable">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<p>[“NumArray”, “sumRange”, “update”, “sumRange”]<br>[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]</p>
<p>输出：[null, 9, null, 8]</p>
<p>解释：</p>
<p>NumArray numArray &#x3D; new NumArray([1, 3, 5]);<br>numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 + 3 + 5 &#x3D; 9<br>numArray.update(1, 2);   &#x2F;&#x2F; nums &#x3D; [1, 2, 5]<br>numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 + 2 + 5 &#x3D; 8</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题最简单的做法是每次根据查询的区间进行求和，但是这样时间复杂度过高。优化的方式是使用<a href="https://guozhchun.github.io/binary-indexed-tree/">树状数组</a>，将原始数组元素转成树状数组，每次更新原始元素的值时同时更新树状数组受影响的元素。这样每次查询时可以使用 <code>log(k)</code> 的时间复杂度，比刚开始直接区间遍历要快得多。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] sums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            update(i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">increaseNum</span> <span class="operator">=</span> val - nums[index];</span><br><span class="line">        nums[index] = val;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index + <span class="number">1</span>; i &lt; sums.length; i += lowBit(i)) &#123;</span><br><span class="line">            sums[i] += increaseNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> querySum(right + <span class="number">1</span>) - querySum(left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">querySum</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &gt; <span class="number">0</span>; i -= lowBit(i)) &#123;</span><br><span class="line">            sum += sums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowBit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj.update(index,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.sumRange(left,right);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-31:Next Permutation</title>
    <url>/leetCode/leetCode-31/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出一个数组，要求找出比这个数组组成的数字大的最小的那个数字组合，如果没有找到，则输出这个数组组成的数字的最小值的组合。题目链接：**<a href="https://leetcode.com/problems/next-permutation/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><p>由于函数没有返回值，是直接更改的输入的数组，因此此处的输出指更改后的数组的值</p>
<blockquote>
<p>输入：[1,1,2]</p>
<p>输出：[1,2,1]</p>
</blockquote>
<blockquote>
<p>输入：[3,2,1]</p>
<p>输出：[1,2,3]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此解法主要参考leetcode上文章的解法，详细参考点击**<a href="https://leetcode.com/articles/next-permutation/">这里</a>**</p>
<p>主要过程如下：</p>
<ul>
<li>先从数组右边向左边查找，找到右边数字比左边数字大的值，记录此时较小的值，如果没找到，则逆序整个数组，结束。</li>
<li>从数组右边向左边查找，找出第一个比上一步中找到的值大的值，交换这两个值。此时第一步中记录的值后面的值呈降序排列的状态（后面证明）。</li>
<li>将第一步找到的值后面的降序排列的值逆序，使其呈升序排列，此时得到结果。</li>
</ul>
<p>其过程大致如下图所示：</p>
<p><img src="/images/31_Next_Permutation.gif" alt="31_Next_Permutation.gif"></p>
<blockquote>
<p>说明：此图片来自<a href="https://leetcode.com/articles/next-permutation/">https://leetcode.com/articles/next-permutation</a></p>
</blockquote>
<p>现在证明在交换两个数之后，后面的数字是降序排列的。由于交换前，后面片段的是降序排列的，所以只需要证明交换后前后三个数是降序的即可。假设要将 <code>a[i]</code> 和 <code>a[j]</code> 进行交换，则必有以下不等式成立</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[j + 1] &lt; a[i] &lt; a[j]                 </span><br><span class="line">a[j + 1] &lt; a[j] &lt; a[j - 1]         </span><br></pre></td></tr></table></figure>

<p>现在要证明交换后 <code>a[j + 1] &lt;= a[i] &lt;= a[j - 1]</code>。用反证法进行证明。</p>
<p>先证明 <code>a[j + 1] &lt;= a[i]</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设 a[j + 1] &gt; a[i]</span><br><span class="line">与已知 a[j + 1] &lt; a[i] 矛盾</span><br><span class="line">故 a[j + 1] &lt;= a[i] 成立</span><br></pre></td></tr></table></figure>

<p>现在证明<code>a[i] &lt;= a[j - 1]</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设 a[i] &gt; a[j - 1]</span><br><span class="line">由于 a[j + 1] &lt; a[j] &lt; a[j - 1]</span><br><span class="line">所以 a[i] &gt; a[j - 1] &gt; a[j]，与已知 a[i] &lt; a[j]矛盾</span><br><span class="line">故 a[i] &lt;= a[j - 1] 成立</span><br></pre></td></tr></table></figure>

<p>综上所述，在交换值后，后面的值仍然维持者降序的顺序。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 找到值比右边数字小的下标，找不到返回-1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findLessIndex</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到要交换的下标：要求值比nums[index]大，找不到返回-1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findSwapIndex</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[index])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换数组下标i和j的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对数组[startIndex,endIndex]范围内的数字进行逆序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endRange</span> <span class="operator">=</span> (endIndex - startIndex + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; endRange; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums, startIndex + i, endIndex - i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lessIndex</span> <span class="operator">=</span> findLessIndex(nums);</span><br><span class="line">        <span class="comment">// 该数字是最大的数，直接逆序后返回</span></span><br><span class="line">        <span class="keyword">if</span> (lessIndex == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">swapIndex</span> <span class="operator">=</span> findSwapIndex(nums, lessIndex);</span><br><span class="line">        <span class="comment">// 没找到要交换的数字，说明lessIndex位置后面的数字都比这个数大，直接逆序后面的数字</span></span><br><span class="line">        <span class="keyword">if</span> (swapIndex == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reverse(nums, lessIndex + <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找打要交换的数字，则交换，此时lessIndex后面的数字是倒序排序的，需要将其升序排序得到最小值</span></span><br><span class="line">        swap(nums, lessIndex, swapIndex);</span><br><span class="line">        reverse(nums, lessIndex + <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h1><p><a href="https://leetcode.com/articles/next-permutation/">https://leetcode.com/articles/next-permutation/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-310:Minimum Height Trees</title>
    <url>/leetCode/leetCode-310/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个正整数 <code>n</code> 和长度为 <code>n - 1</code> 的二维数组，表示一个图中的 <code>n</code> 个节点和节点之间边的连线，边不重复。这个图可以表示成树的形状，要求找出拥有最小高度的树，返回满足要求的根节点列表。题目链接：<a href="https://leetcode.com/problems/minimum-height-trees"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：n &#x3D; 4, edges &#x3D; [[1,0],[1,2],[1,3]]</p>
<p>输出：[1]</p>
<p>解释：构成的树形状如下，根节点为 1 的树高度最小</p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/01/e1.jpg"></p>
</blockquote>
<blockquote>
<p>输入：n &#x3D; 1, edges &#x3D; []</p>
<p>输出：[0]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题最简单的做法是以每个节点为根节点，分别算出其树的高度，然后取最小高度的树的根节点返回。但是这样做会超时。</p>
<p>其实，观察题目意思，可以知道，要想找到最小高度树，可以找到图中的最长路径，然后取这个最长路径上的中间节点作为树的根节点，即是求解的答案。可以使用类似拓扑排序的做法，从边缘节点（度为1的节点）不停地向中间靠拢（<em>两端烧香做法</em>），最后达到的节点就是求解的根节点（因为以此为节点，到两边的路径都是最短的）。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findMinHeightTrees</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            result.add(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] degrees = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            degrees[edge[<span class="number">0</span>]]++;</span><br><span class="line">            degrees[edge[<span class="number">1</span>]]++;</span><br><span class="line">            List&lt;Integer&gt; nodes = map.getOrDefault(edge[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            nodes.add(edge[<span class="number">1</span>]);</span><br><span class="line">            map.put(edge[<span class="number">0</span>], nodes);</span><br><span class="line"></span><br><span class="line">            nodes = map.getOrDefault(edge[<span class="number">1</span>], <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            nodes.add(edge[<span class="number">0</span>]);</span><br><span class="line">            map.put(edge[<span class="number">1</span>], nodes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (degrees[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            result.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                result.add(current);</span><br><span class="line">                List&lt;Integer&gt; nodes = map.get(current);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> node : nodes) &#123;</span><br><span class="line">                    degrees[node]--;</span><br><span class="line">                    <span class="keyword">if</span> (degrees[node] == <span class="number">1</span>) &#123;</span><br><span class="line">                        queue.offer(node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/minimum-height-trees/solution/zui-xiao-gao-du-shu-by-leetcode-solution-6v6f">https://leetcode.cn/problems/minimum-height-trees/solution/zui-xiao-gao-du-shu-by-leetcode-solution-6v6f</a></p>
<p><a href="https://leetcode.cn/problems/minimum-height-trees/solution/by-a-fei-8-hm2n">https://leetcode.cn/problems/minimum-height-trees/solution/by-a-fei-8-hm2n</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-312:Burst Balloons</title>
    <url>/leetCode/leetCode-312/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数组，表示气球的数字，当戳破一个编号为 <code>i</code> 的气球时，可以获得金币 <code>nums[i - 1] * nums[i] * nums[i + 1]</code> （如果 <code>nums[i - 1]</code> 或 <code>nums[i + 1]</code> 不存在，则值为 <code>1</code>），要求找出戳破气球所能获得的最大金币数量。题目链接：<a href="https://leetcode.com/problems/burst-balloons"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [3,1,5,8]</p>
<p>输出：167</p>
<p>解释：nums &#x3D; [3,1,5,8] –&gt; [3,5,8] –&gt; [3,8] –&gt; [8] –&gt; []、coins &#x3D;  3<em>1</em>5    +   3<em>5</em>8   +  1<em>3</em>8  + 1<em>8</em>1 &#x3D; 167</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [1,5]</p>
<p>输出：10</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题如果使用暴力手法列出所有可能的情况，则会存在超时。需要用动态规划的解法进行求解。用 <code>dp[i][j]</code> 表示 <code>i</code> 到 <code>j</code> 中戳破气球所能获得的金币最大数（不包括边界 <code>i</code> 和 <code>j</code>），用 <code>k</code> 表示 <code>i~j</code> 中最后一个戳破的气球，则存在动态转移方程：<code>dp[i][j] = dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]</code>。注意 <code>dp[i][j]</code> 中是不包含边界 <code>i</code>、<code>j</code> 气球的。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxCoins</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">2</span>][nums.length + <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span>[] values = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            values[i + <span class="number">1</span>] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        values[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        values[nums.length + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> values.length - <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">2</span>; j &lt; values.length; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], values[i] * values[k] * values[j] + dp[i][k] + dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][values.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/burst-balloons/solution/zhe-ge-cai-pu-zi-ji-zai-jia-ye-neng-zuo-guan-jian-/">https://leetcode.cn/problems/burst-balloons/solution/zhe-ge-cai-pu-zi-ji-zai-jia-ye-neng-zuo-guan-jian-/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-313:Super Ugly Number</title>
    <url>/leetCode/leetCode-313/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个正整数 <code>n</code> 和一个素数数组，定义“超级丑数”为因子只能是素数数组中的数（<code>1</code> 是“超级丑数”）。要求找出第 <code>n</code> 个“超级丑数”。题目链接：**<a href="https://leetcode.com/problems/super-ugly-number/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：n &#x3D; 12, primes &#x3D; [2,7,13,19]</p>
<p>输出：32</p>
<p>解释：超级丑数列表为：[1,2,4,7,8,13,14,16,19,26,28,32]</p>
</blockquote>
<blockquote>
<p>输入：n &#x3D; 1, primes &#x3D; [2]</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题与 <a href="https://guozhchun.github.io/leetCode/leetCode-264/">LeetCode-264</a> 类似，解法也类似，只不过把原先固定的 <code>[2, 3, 5]</code> 数组换成输入的素数数组即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthSuperUglyNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] primes)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] points = <span class="keyword">new</span> <span class="title class_">int</span>[primes.length];</span><br><span class="line">        <span class="type">int</span>[] currents = <span class="keyword">new</span> <span class="title class_">int</span>[primes.length];</span><br><span class="line">        <span class="type">int</span>[] results = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        results[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minNum</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; primes.length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                currents[j] = primes[j] * results[points[j]];</span><br><span class="line">                minNum = Math.min(minNum, currents[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; primes.length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (currents[j] == minNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    points[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            results[i - <span class="number">1</span>] = minNum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-315:Count of Smaller Numbers After Self</title>
    <url>/leetCode/leetCode-315/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，要求输出一个数组，结果数组中的每个元素表示原始数组该位置后续元素比该位置元素小的元素数量。题目链接：<a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [5,2,6,1]</p>
<p>输出：[2,1,1,0]</p>
<p>解释：原始数组中第一个元素 5，后续元素比他小的有两个：2 和 1，所以结果数组中第一个元素是 2</p>
<p>原始数组中第二个元素 2，后续元素比他小的有一个： 1，所以结果数组中第二个元素是 1</p>
<p>原始数组中第三个元素 6，后续元素比他小的有一个： 1，所以结果数组中第三个元素是 1</p>
<p>原始数组中第四个元素 1，没有后续元素，所以结果数组中第四个元素是 0</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [-1]</p>
<p>输出：[0]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>按照题目意思，此题最简单的做法是两层循环分别计算结果，但是这样明显会超时，所以需要寻求更优的解法。</p>
<p>首先，先对数组进行排序去重，然后从后往前遍历数组，每次计算更新当前元素值的数量，同时计算获取小于当前元素值的数量。举例如下，假设数组 <code>nums = [7, 5, 6, 5, 2, 6, 5, 1] </code>，则其计算步骤如下：</p>
<p>首先对数组排序去重，得到数组 <code>[1, 2, 5, 6, 7]</code>，然后从后往前遍历原始数组，分别计算数组元素出现的个数，同时计算小于该元素的元素数量。</p>
<p>当 <code>i = 7</code> 时（原始数组最后一个元素），此时元素为 <code>1</code> ，更新数组如下，比 1 小的元素个数和为 0（表中没有比 1 小的元素），此时 <code>counts[7] = 0</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>个数 c[j]</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>当 <code>i = 6</code> 时，此时元素为 <code>5</code>，更新数组如下，比 <code>5</code> 小的元素有 <code>1</code> 和 <code>2</code>，其个数分别为 <code>1</code> 和 <code>0</code>，相加得到值 <code>1</code>，<code>counts[6] = 1</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>个数 c[j]</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>当 <code>i = 5</code> 时，此时元素为 <code>6</code>，更新数组如下，比 <code>6</code> 小的元素有 <code>1</code> 、 <code>2</code>、<code>5</code>，其个数分别为 <code>1</code> 、 <code>0</code>、<code>1</code>，相加得到值 <code>1</code>，<code>counts[5] = 2</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>个数 c[j]</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>当 <code>i = 4</code> 时，此时元素为 <code>2</code>，更新数组如下，比 <code>2</code> 小的元素有 <code>1</code>，其个数为 <code>1</code>，<code>counts[4] = 1</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>个数 c[j]</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>当 <code>i = 3</code> 时，此时元素为 <code>5</code>，更新数组如下，比 <code>5</code> 小的元素有 <code>1</code> 和 <code>2</code>，其个数分别为 <code>1</code> 和 <code>1</code>，相加得到值 <code>2</code>，<code>counts[4] = 2</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>个数 c[j]</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>当 <code>i = 2</code> 时，此时元素为 <code>6</code>，更新数组如下，比 <code>6</code> 小的元素有 <code>1</code> 、 <code>2</code>、<code>5</code>，其个数分别为 <code>1</code> 、 <code>1</code>、<code>2</code>，相加得到值 <code>4</code>，<code>counts[3] = 4</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>个数 c[j]</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>0</td>
</tr>
</tbody></table>
<p>当 <code>i = 1</code> 时，此时元素为 <code>5</code>，更新数组如下，比 <code>5</code> 小的元素有 <code>1</code> 和 <code>2</code>，其个数分别为 <code>1</code> 和 <code>1</code>，相加得到值 <code>2</code>，<code>counts[1] = 2</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>个数 c[j]</td>
<td>1</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>0</td>
</tr>
</tbody></table>
<p>当 <code>i = 0</code> 时，此时元素为 <code>7</code>，更新数组如下，比 <code>7</code> 小的元素有 <code>1</code> 、 <code>2</code>、<code>5</code>、<code>6</code>，其个数分别为 <code>1</code> 、 <code>1</code>、<code>3</code>、<code>2</code>，相加得到值 <code>7</code>，<code>counts[0] = 7</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>个数 c[j]</td>
<td>1</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p>最终得到的结果数组为 <code>[7, 2, 4, 2, 1, 2, 1, 0]</code></p>
<p>上述方法虽然可以得到结果，但是仍然效率低下。仔细观察可以发现，每次在计算个数时，都对元素之前的个数进行了汇总，这就是求前缀和或区间和，可以用树状数组来优化。此做法参考：<a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solutions/325800/shu-zhuang-shu-zu-de-xiang-xi-fen-xi-by-yangbingji">https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solutions/325800/shu-zhuang-shu-zu-de-xiang-xi-fen-xi-by-yangbingji</a></p>
<p>还是上面的例子，用树状数组计算的过程如下</p>
<p>当 <code>i = 7</code> 时（原始数组最后一个元素），此时元素为 <code>1</code> ，对应树状数组下标为 <code>1</code>，更新树状数组<code>C[1]</code>、<code>C[2]</code>、<code>C[4]</code>，计算前缀和 <code>sum[j - 1] = sum[0] = 0</code>， <code>counts[7] = 0</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>树状数组C[j]</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>树状数组下标</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody></table>
<p>当 <code>i = 6</code> 时，此时元素为 <code>5</code>，对应树状数组下标为 <code>3</code>，更新树状数组 <code>C[3]</code>、<code>C[4]</code>，计算前缀和 <code>sum[j - 1] = sum[2] = C[2] = 1</code>，<code>counts[6] = 1</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>树状数组C[j]</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>树状数组下标</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody></table>
<p>当 <code>i = 5</code> 时，此时元素为 <code>6</code>，对应树状数组下标为 <code>4</code>，更新树状数组 <code>C[4]</code>，计算前缀和 <code>sum[j - 1] = sum[3] = C[3] + C[2] = 2</code>，<code>counts[5] = 2</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>树状数组C[j]</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>3</td>
<td>0</td>
</tr>
<tr>
<td>树状数组下标</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody></table>
<p>当 <code>i = 4</code> 时，此时元素为 <code>2</code>，对应树状数组下标为 <code>2</code>，更新树状数组 <code>C[2]</code>、<code>C[4]</code>，计算前缀和 <code>sum[j - 1] = sum[1] = C[1] = 1</code>，<code>counts[4] = 1</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>树状数组C[j]</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>树状数组下标</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody></table>
<p>当 <code>i = 3</code> 时，此时元素为 <code>5</code>，对应树状数组下标为 <code>3</code>，更新树状数组 <code>C[3]</code>、<code>C[4]</code>，计算前缀和 <code>sum[j - 1] = sum[2] = C[2] = 2</code>，<code>counts[4] = 2</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>树状数组C[j]</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>5</td>
<td>0</td>
</tr>
<tr>
<td>树状数组下标</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody></table>
<p>当 <code>i = 2</code> 时，此时元素为 <code>6</code>，对应树状数组下标为 <code>4</code>，更新树状数组 <code>C[4]</code>，计算前缀和 <code>sum[j - 1] = sum[3] = C[3] + C[2] = 4</code>，<code>counts[3] = 4</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>树状数组C[j]</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>6</td>
<td>0</td>
</tr>
<tr>
<td>树状数组下标</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody></table>
<p>当 <code>i = 1</code> 时，此时元素为 <code>5</code>，对应树状数组下标为 <code>3</code>，更新树状数组 <code>C[3]</code>、<code>C[4]</code>，计算前缀和 <code>sum[j - 1] = sum[2] = C[2] = 2</code>，<code>counts[1] = 2</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>树状数组C[j]</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>7</td>
<td>0</td>
</tr>
<tr>
<td>树状数组下标</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody></table>
<p>当 <code>i = 0</code> 时，此时元素为 <code>7</code>，对应树状数组下标为 <code>5</code>，更新树状数组<code>C[5]</code>，计算前缀和 <code>sum[j - 1] = sum[4] = C[4] = 7</code>，<code>counts[0] = 7</code></p>
<table>
<thead>
<tr>
<th>数组 n[j]</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>树状数组C[j]</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>7</td>
<td>1</td>
</tr>
<tr>
<td>树状数组下标</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody></table>
<p>最终得到的结果数组为 <code>[7, 2, 4, 2, 1, 2, 1, 0]</code></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">countSmaller</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numList = Arrays.stream(nums).distinct().sorted().boxed().collect(Collectors.toList());</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numList.size(); i++) &#123;</span><br><span class="line">            map.put(numList.get(i), i + <span class="number">1</span>);    <span class="comment">// 错位，留出下标为 0 的位置，方便后续树状数组计算更新</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] sums = <span class="keyword">new</span> <span class="title class_">int</span>[numList.size() + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(nums[i]);</span><br><span class="line">            update(sums, index);</span><br><span class="line">            counts[i] = querySum(sums, index - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(counts).boxed().collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowBit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span>[] sums, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; sums.length; j += lowBit(j)) &#123;</span><br><span class="line">            sums[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">querySum</span><span class="params">(<span class="type">int</span>[] sums, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result += sums[i];</span><br><span class="line">            i -= lowBit(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solutions/325800/shu-zhuang-shu-zu-de-xiang-xi-fen-xi-by-yangbingji/">https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solutions/325800/shu-zhuang-shu-zu-de-xiang-xi-fen-xi-by-yangbingji/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-316:Remove Duplicate Letters</title>
    <url>/leetCode/leetCode-316/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个只包含小写字母的字符串，要求去除其中重复的字母，返回保留原先字母顺序的最小字典序的字符串。题目链接：**<a href="https://leetcode.com/problems/remove-duplicate-letters/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：”bcabc”</p>
<p>输出：”abc”</p>
</blockquote>
<blockquote>
<p>输入：”cbacdcbc”</p>
<p>输出：”acdb”</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用栈，遍历字符串，对每个字符进行以下判断：如果栈中元素包含了当前元素，则跳过当前元素继续下一个字符的判断；如果栈不为空，则取出栈顶的元素与当前字符进行判断，如果比当前字符大并且在当前字符后面还存在栈顶的字符，则将栈顶的字符弹出，直到栈顶字符比当前字符小或栈为空时停止，然后将当前元素入栈。最后栈中的元素序列就是求解的值。此解法参考：<a href="https://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode/">https://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] charCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s.toCharArray())</span><br><span class="line">        &#123;</span><br><span class="line">            charCounts[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s.toCharArray())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            charCounts[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (stack.contains(ch))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &gt; ch &amp;&amp; charCounts[stack.peek() - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stack.push(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode/">https://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-318:Maximum Product of Word Lengths</title>
    <url>/leetCode/leetCode-318/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串（由小写字母组成）列表，要求找出两个不包含相同字母的字符串的最大长度乘积。题目链接：**<a href="https://leetcode.com/problems/maximum-product-of-word-lengths/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[“abcw”,”baz”,”foo”,”bar”,”xtfn”,”abcdef”]</p>
<p>输出：16</p>
<p>解释：两个字符串为 abcw 和 xtfn，长度分别是 4 和 4，结果是 4 * 4 &#x3D; 16</p>
</blockquote>
<blockquote>
<p>输入：[“a”,”ab”,”abc”,”d”,”cd”,”bcd”,”abcd”]</p>
<p>输出：4</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题主要难点在判断两个字符串是否包含相同的字母，最简单的做法是对字符串的每个字母进行比较，但这样会超时，稍微优化点的做法是用 set 来存储字母，将某个字符串加到另外的字符串 set 里，根据 set 的长度变化来判断是否有相同字符，但是这样也会超时，再优化的做法是把字符串字符按位或运算得到一个数字，然后依次对每个字符串或运算的数字进行与运算，如果结果为 0， 说明两个字符串不包含相同的字母，否则说明两个字符串包含相同的字母。对上述满足要求的字符串的长度进行两两相乘，可以找到最大的结果。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] chs = <span class="keyword">new</span> <span class="title class_">int</span>[words.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> ch : words[i].toCharArray()) &#123;</span><br><span class="line">                num |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            chs[i] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; chs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((chs[i] &amp; chs[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    result = Math.max(result, words[i].length() * words[j].length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/maximum-product-of-word-lengths/solution/gong-shui-san-xie-jian-dan-wei-yun-suan-cqtxq/">https://leetcode.cn/problems/maximum-product-of-word-lengths/solution/gong-shui-san-xie-jian-dan-wei-yun-suan-cqtxq/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-319:Bulb Switcher</title>
    <url>/leetCode/leetCode-319/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>假设有 n 个灯泡，编号从 1 到 n，初始状态是关的，现在执行以下动作：第一次，全部打开，第二次把能被 2 整除的灯泡改变下状态（从开变成关，从关变成开），第三次把能被 3 整除的灯泡改变下状态（从开变成关，从关变成开），第 i 此把能被 i 整除的灯泡改变下状态（从开变成关，从关变成开），以此类推，直到第 n 次结束。要求统计最后灯泡亮着的数量。题目链接：**<a href="https://leetcode.com/problems/bulb-switcher/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：3</p>
<p>输出：1</p>
<p>解释：初始状态灯泡状态为：关、关、关</p>
<p>第一次遍历后灯泡状态为：开、开、开</p>
<p>第二次遍历后灯泡状态为：开、关、开</p>
<p>第三次遍历后灯泡状态为：开、关、关</p>
<p>最后灯泡开着的数量为 1</p>
</blockquote>
<blockquote>
<p>输入：1</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>首先，分析每个灯泡，在第一轮过后，灯泡都是亮着的，此后的每一轮，如果灯泡编号能被 <code>i</code> 整除，则会改变状态，如果 <code>i</code> 不是灯泡编号的平方根，那么在 <code>[1, 灯泡编号]</code> 这个区间内肯定存在另一个数 <code>k</code> 使得 <code>i * k = 灯泡变化</code>，也就是说灯泡的状态会在第 <code>i</code> 次遍历时改变状态，但是在第 <code>k</code> 次遍历时又把状态还原回去。所以，要想灯泡亮着，灯泡的编号必须是一个完全平方数（否则，合数个数是偶数，负负得正，相当于没变）。此题也就转换为求 <code>[1, n]</code> 范围内完全平方数的个数，更进一步，也就是求 <code>n</code> 的平方根向下取整的值。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bulbSwitch</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) Math.sqrt(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://leetcode-cn.com/problems/bulb-switcher/solution/gong-shui-san-xie-jing-dian-shu-lun-tui-upnnb/">https://leetcode-cn.com/problems/bulb-switcher/solution/gong-shui-san-xie-jing-dian-shu-lun-tui-upnnb/</a></li>
<li><a href="https://segmentfault.com/q/1010000025176236">https://segmentfault.com/q/1010000025176236</a></li>
</ol>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-321:Create Maximum Number</title>
    <url>/leetCode/leetCode-321/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个整数数组和一个数字 <code>k</code>，要求在两个数组中找出 <code>k</code> 个数字组成新的数组，数组元素的顺序跟原有数组的顺序保持不变。题目链接：**<a href="https://leetcode.com/problems/create-maximum-number/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums1 &#x3D; [3, 4, 6, 5]      nums2 &#x3D; [9, 1, 2, 5, 8, 3]      k &#x3D; 5</p>
<p>输出：[9, 8, 6, 5, 3]</p>
</blockquote>
<blockquote>
<p>输入：nums1 &#x3D; [6, 7]        nums2 &#x3D; [6, 0, 4]     k &#x3D; 5</p>
<p>输出：[6, 7, 6, 0, 4]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>从第一个数组中挑出 <code>m</code> 个顺序跟原数组保持一致的最大数字的元素组成一个新的数组，从第二个数组中挑出 <code>k - m</code> 个顺序跟原数组保持一致的最大数字的元素组成一个新的数组，将这两个数组合并成一个数量为 <code>k</code> 的数组，保存在一个变量中，每次循环获得的数组都跟这个变量数组进行比较，并将大的数组更新到变量中。循环结束后，变量保持的数组就是求解的结果。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxNumber(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span>[] temp = merge(maxNumber(nums1, i), maxNumber(nums2, k - i));</span><br><span class="line">            result = getMaxIntArray(result, temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] getMaxIntArray(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.length &lt; nums2.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &lt; nums2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt; nums2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] merge(List&lt;Integer&gt; nums1, List&lt;Integer&gt; nums2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.size() + nums2.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.size() &amp;&amp; j &lt; nums2.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1.get(i) &gt; nums2.get(j))</span><br><span class="line">            &#123;</span><br><span class="line">                result[index] = nums1.get(i);</span><br><span class="line">                index++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1.get(i) &lt; nums2.get(j))</span><br><span class="line">            &#123;</span><br><span class="line">                result[index] = nums2.get(j);</span><br><span class="line">                index++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ii</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">jj</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">while</span> (ii &lt; nums1.size() &amp;&amp; jj &lt; nums2.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums1.get(ii) &gt; nums2.get(jj))</span><br><span class="line">                    &#123;</span><br><span class="line">                        result[index] = nums1.get(i);</span><br><span class="line">                        index++;</span><br><span class="line">                        i++;</span><br><span class="line">                        isFind = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nums1.get(ii) &lt; nums2.get(jj))</span><br><span class="line">                    &#123;</span><br><span class="line">                        result[index] = nums2.get(j);</span><br><span class="line">                        index++;</span><br><span class="line">                        j++;</span><br><span class="line">                        isFind = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        ii++;</span><br><span class="line">                        jj++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!isFind)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ii == nums1.size())</span><br><span class="line">                    &#123;</span><br><span class="line">                        result[index] = nums2.get(j);</span><br><span class="line">                        index++;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        result[index] = nums1.get(i);</span><br><span class="line">                        index++;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.size())</span><br><span class="line">        &#123;</span><br><span class="line">            result[index] = nums1.get(i);</span><br><span class="line">            index++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt; nums2.size())</span><br><span class="line">        &#123;</span><br><span class="line">            result[index] = nums2.get(j);</span><br><span class="line">            index++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">maxNumber</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.empty() &amp;&amp; stack.peek() &lt; nums[i] &amp;&amp; stack.size() + nums.length - i &gt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stack.size() &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://leetcode.flowerplayer.com/2019/04/04/leetcode-321-create-maximum-number%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/">http://leetcode.flowerplayer.com/2019/04/04/leetcode-321-create-maximum-number%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-32:Longest Valid Parentheses</title>
    <url>/leetCode/leetCode-32/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出一个只包含左右小括号的字符串，要求找出其中最长的合法的括号对的子字符串，返回其长度。题目链接：**<a href="https://leetcode.com/problems/longest-valid-parentheses/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：”)()())”</p>
<p>输出：4</p>
</blockquote>
<blockquote>
<p>输入：”()(()”</p>
<p>输出：2</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此解法主要参考 leetcode 上文章的解法三（用 stack 进行求解），详细参考点击**<a href="https://leetcode.com/articles/longest-valid-parentheses/">这里</a>**</p>
<p>主要过程如下：</p>
<ul>
<li>定义一个栈，用来存储字符串的下标。初始化压入数值 -1</li>
<li>遍历字符串，对每个字符执行以下操作<ul>
<li>如果当前字符是<code>(</code>，则直接将当前下标压入栈中</li>
<li>如果当前字符是<code>)</code>，则将栈顶元素出栈，然后判断栈是否为空，如果为空，则将当前下标压入栈中，否则用当前下标减去栈顶值，得到当前匹配到的括号的长度，将此值与保存的最大长度进行比较，取其最大值更新最大长度变量的值</li>
</ul>
</li>
</ul>
<p>现在证明此方法的可行性：</p>
<p>首先，从算法流程中，可以很容易得出以下结论：</p>
<ul>
<li>当栈顶元素对应的字符是<code>)</code>时，栈中必然只有一个元素。因为<code>)</code>只有在栈中元素为空时才会将下标入栈。</li>
<li>当栈顶元素对应的字符是<code>(</code>时，栈中元素必然大于一个。原因同上。</li>
<li>当栈顶元素对应的字符是<code>)</code>时，以当前字符为截止字符构成的子字符串一定不能组成一个合法的括号对，即<code>)</code>数量多于<code>(</code>数量。因为每次遇到<code>(</code>都会将其下标入栈，而遇到<code>)</code>都会弹出一个元素，如果<code>(</code>与<code>)</code>数量相等，则栈顶元素为 -1，如果<code>(</code>数量比<code>)</code>多，则栈顶对应字符是<code>(</code>。</li>
<li>当栈顶元素多于一个时，次栈顶元素在原字符串对应的元素必然是栈顶元素在原字符串中对应的元素的的前一个元素（*-1 当作是第 0 个元素的前一个元素*）。因为当栈中元素多于一个时，如果次栈顶是 -1，则栈顶一定 0（因为所有<code>(</code>都会压入栈中，如果第0个元素是<code>)</code>,则会将 -1 出栈），如果次栈顶对应的元素是<code>(</code>，则次栈顶和栈顶对应的元素必然是相邻的（因为所有<code>(</code>都会压入栈中），如果次栈顶对应元素是<code>)</code>，由于连续多个<code>)</code>字符时，栈中也只会保留最后一个<code>)</code>的下标，所以次栈顶和栈顶对应的元素也是相邻的。</li>
</ul>
<p>其次，证明循环中遇到<code>)</code>，其计算结果的准确性：</p>
<ul>
<li>如果栈中只有一个元素，即栈顶元素对应字符是<code>)</code>，说明当前字符前面组成的字符不能全部构成合法括号对字符串，因此，截止到当前字符构成的子字符串也无法构成一个合法的括号对字符串，故不用更新最大合法括号对字符串长度变量的值。</li>
<li>如果栈中多于一个元素，即栈顶元素对应字符是<code>(</code>，说明从当前栈顶元素对应的字符到当前元素构成的子字符串是一个合法的括号对字符串（<em>由于这个子字符串中间已经经过了上述的判断，如果中间某个元素 k 与栈顶元素构成的字符串不是一个合法的括号对字符串，则栈顶元素是 k 而不是现在这个，因此可以保证栈顶元素到当前元素构成的子字符串是一个合法的括号对字符串</em>），所以只需要算出当前子字符串的长度跟最大合法括号对字符串长度进行比较即可。由于次栈顶元素必然是栈顶元素的前一个元素，所以用当前元素下标减去栈顶元素可以算出当前子字符串的长度。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    num = i - stack.peek();</span><br><span class="line">                    <span class="keyword">if</span> (num &gt; maxNum)</span><br><span class="line">                    &#123;</span><br><span class="line">                        maxNum = num;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h1><p><a href="https://leetcode.com/articles/longest-valid-parentheses/">https://leetcode.com/articles/longest-valid-parentheses/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-322:Coin Change</title>
    <url>/leetCode/leetCode-322/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数组，表示硬币的面额，每种硬币数量不限，给定另一个目标数字，要求使用最小数量的硬币，将其组合起来值等于目标值。找到则返回最小的硬币数量，找不到则返回 -1。题目链接：**<a href="https://leetcode.com/problems/coin-change/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：coins &#x3D; [1,2,5], amount &#x3D; 11</p>
<p>输出：3</p>
<p>解释：硬币组合为 5 + 5 +1</p>
</blockquote>
<blockquote>
<p>输入：coins &#x3D; [2], amount &#x3D; 3</p>
<p>输出：-1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>刚开始想用贪心的算法，按从大到小的排序对每种硬币计算其所需要的数量，但是发现一个问题，贪心找出来的第一个答案可能不是最小硬币的数量，如 coins &#x3D; [7, 6, 2], amount &#x3D; 18，用上述贪心算法找到的答案是 7 + 7 + 2 + 2，总共 4 个，但是事实存在更小的硬币组合：6 + 6 + 6，总共 3 个。所以单纯用贪心算法是不能正确求解的。查看题目提示，是用动态规划进行求解。假设 <code>dp[i]</code> 表示用硬币组合 <code>i</code>  金额所需要的最小数量，则 <code>dp[i] = min(dp[i], dp[i - coins[j]] + 1)</code> ，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; coins.length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == coins[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i - coins[j] &gt; <span class="number">0</span> &amp;&amp; dp[i - coins[j]] != -<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i] == -<span class="number">1</span> || dp[i] &gt; dp[i - coins[j]] + <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i] = dp[i - coins[j]] + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-328:Odd Even Linked List</title>
    <url>/leetCode/leetCode-328/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表，要求将原先链表的奇数节点连接在一起，再顺序连接原有链表的偶数节点。要求求解的时间复杂度为 <code>O(1)</code>， 空间复杂度为 <code>O(n)</code>。 题目链接：**<a href="https://leetcode.com/problems/odd-even-linked-list/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1, 2, 3, 4, 5, 6]</p>
<p>输出：[1, 3, 5, 2, 4, 6]</p>
</blockquote>
<blockquote>
<p>输入：[1, 2, 3]</p>
<p>输出：[1, 3, 2]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题主要是链表的应用，直接按题目要求进行求解即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> p.next;</span><br><span class="line">            p.next = next.next;</span><br><span class="line">            <span class="keyword">if</span> (p.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next.next = p.next.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p.next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-329:Longest Increasing Path in a Matrix</title>
    <url>/leetCode/leetCode-329/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个只包含整数的矩阵，要求找出矩阵中单调递增路径（某个节点与该节点上下左右节点可以构成一个路径）的最大长度。题目链接：**<a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：matrix &#x3D; [[9,9,4],[6,6,8],[2,1,1]]</p>
<p>输出：4</p>
<p>解释：路径为：1 -&gt; 2 -&gt; 6 -&gt; 9</p>
</blockquote>
<blockquote>
<p>输入：matrix &#x3D; [[1]]</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用记忆化搜索的方式进行求解，分别对矩阵中每个节点作为起始节点进行递归搜索，在搜索过程中使用数组记录已经搜索过的路径的节点的最大长度，以免重复搜索。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestIncreasingPath</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] counts = <span class="keyword">new</span> <span class="title class_">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                search(matrix, counts, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                result = Math.max(result, counts[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span>[][] counts, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (counts[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> counts[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isMove(matrix, num, i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">            left = search(matrix, counts, i, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isMove(matrix, num, i, j + <span class="number">1</span>)) &#123;</span><br><span class="line">            right = search(matrix, counts, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isMove(matrix, num, i - <span class="number">1</span>, j)) &#123;</span><br><span class="line">            top = search(matrix, counts, i - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">down</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isMove(matrix, num, i + <span class="number">1</span>, j)) &#123;</span><br><span class="line">            down = search(matrix, counts, i + <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        counts[i][j] = Math.max(Math.max(Math.max(left, right), Math.max(top, down)) + <span class="number">1</span>, counts[i][j]);</span><br><span class="line">        <span class="keyword">return</span> counts[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isMove</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> num, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;=<span class="number">0</span> &amp;&amp; i &lt; matrix.length &amp;&amp; j &gt;=<span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length &amp;&amp; num &lt; matrix[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-33:Search in Rotated Sorted Array</title>
    <url>/leetCode/leetCode-33/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个无重复整数的升序的循环数组（例如：[1,2,3,4,5] 或 [4,5,6,1,2,3]），要求以O(log n)的时间复杂度查找一个数字是否在这个数组中，如果存在，则返回该数字的下标，否则返回-1。题目链接：**<a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</p>
<p>输出：4</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [1,2,3,4,5], target &#x3D; 0</p>
<p>输出：-1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题要求以O(log n)的时间复杂度进行求解，只有二分查找才能满足要求。但是二分查找要求的前提条件是数组有序，而此题数组的“有序”是可循环的，即数组从某个位置开始向右遍历回到此位置，这之间经过的数字是有序的。因此，只需要求出数组最小值的位置，记录此偏移量，然后在二分查找的比较中，用计算得到的中间下标位置加上偏移量得到真正的数组的中间下标位置，然后跟目标值进行比较，其他步骤跟二分查找一样，即可得到问题的答案。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取逆序位置的偏移量，当a[i] &gt; a[i + 1]时，返回 i+1，否则返回0</span></span><br><span class="line"><span class="comment">     * 使用二分查找，时间复杂度为O(log n)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 逆序位置的偏移量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getOffsetNum</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; nums[(middle + <span class="number">1</span>) % length])</span><br><span class="line">            &#123;</span><br><span class="line">                result = middle + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; nums[length - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                i = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                j = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offsetNum</span> <span class="operator">=</span> getOffsetNum(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 在循环的数组中，middle对应的真正下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">realMiddleIndex</span> <span class="operator">=</span> (middle + offsetNum) % nums.length;</span><br><span class="line">            <span class="keyword">if</span> (nums[realMiddleIndex] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                result = realMiddleIndex;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[realMiddleIndex] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                i = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                j = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-330:Patching Array</title>
    <url>/leetCode/leetCode-330/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个升序的整数数组和一个整数 <code>n</code>，要求往数组中添加元素，使得 <code>1~n</code> 中的数字都能由数组中的一个或多个元素的总和构成，要求输出添加元素的最小个数。题目链接：<a href="https://leetcode.com/problems/patching-array"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [1,3], n &#x3D; 6</p>
<p>输出：1</p>
<p>解释：添加2，数组构成：[1,2,3]。数字 1 由 [1] 构成，数字 2 由 [2] 构成，数字 3 由 [1,2] 构成，数字 4 由 [1,3] 构成，数字 5 由 [2,3] 构成，数字 6 由 [1,2,3] 构成</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [1,5,10], n &#x3D; 20</p>
<p>输出：2</p>
<p>解释：添加 2，4</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题解法参考：<a href="https://leetcode.cn/problems/patching-array/solution/an-yao-qiu-bu-qi-shu-zu-by-leetcode-solu-klp1%E3%80%82%E4%B8%BB%E8%A6%81%E5%81%9A%E6%B3%95%E6%98%AF%EF%BC%9A%E7%94%B1">https://leetcode.cn/problems/patching-array/solution/an-yao-qiu-bu-qi-shu-zu-by-leetcode-solu-klp1。主要做法是：由</a> <code>1</code> 开始构造连续区间直到 <code>n</code>，构造过程中如果区间已经包含了数组的元素，则将数组下标往后移动，如果没有包含，则将区间扩大一倍。其依赖的原理如下：如果 <code>1~m</code> 是一个连续的区间，那由其中的数字进行组合可以得到 <code>1~2m-1</code> 的连续区间。因为在 <code>1~m-1</code>的数字分别加上 <code>m</code> 就能得到 <code>m+1~2m-1</code>的区间，结合前面的 <code>1~m</code> 就是 <code>1~2m-1</code>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPatches</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (current &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.length &amp;&amp; nums[i] &lt;= current) &#123;</span><br><span class="line">                current += nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current *= <span class="number">2</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/patching-array/solution/an-yao-qiu-bu-qi-shu-zu-by-leetcode-solu-klp1">https://leetcode.cn/problems/patching-array/solution/an-yao-qiu-bu-qi-shu-zu-by-leetcode-solu-klp1</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-334:Increasing Triplet Subsequence</title>
    <url>/leetCode/leetCode-334/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，要求在 <code>O(1)</code> 的空间复杂度内，<code>O(n)</code> 的时间复杂度内判断是否存在三个下标 <code>i</code>、<code>j</code>、<code>k</code>，使得 <code>i &lt; j &lt; k</code> 并且 <code>nums[i] &lt; nums[j] &lt; nums[k]</code>，存在返回 true，不存在返回 false。题目链接：**<a href="https://leetcode.com/problems/increasing-triplet-subsequence/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[2,1,5,0,4,6]</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：[5,4,3,2,1]</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>从后往前遍历，用变量 <code>curMax</code> 存储三个数中右边最大的数，用 <code>second</code> 存储三个数中中间的数，用 <code>tempMax</code> 存储遍历过程中比 <code>curMax</code> 大的数。在遍历过程中，如果值比 <code>second</code> 小，说明找到了题目要求的三个数，返回 true，如果值比 <code>tempMax</code> 大，则更新 <code>tempMax</code> 的值，如果介于 <code>curMax</code> 和 <code>tempMax</code> 中间，则说明 <code>curMax</code> 和 <code>tempMax</code> 构成了新的三元组中的后两个，如果值介于 <code>second</code> 和 <code>curMax</code> 之间，则更新 <code>second</code> 的值，这样才能尽可能不漏地最快地找到满足要求的三元组。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">increasingTriplet</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">curMax</span> <span class="operator">=</span> nums[nums.length - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; curMax) &#123;</span><br><span class="line">                second = nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curMax = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">tempMax</span> <span class="operator">=</span> curMax;</span><br><span class="line">        <span class="keyword">for</span> (i--; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; second) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= tempMax) &#123;</span><br><span class="line">                tempMax = nums[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= curMax) &#123;</span><br><span class="line">                curMax = tempMax;</span><br><span class="line">                second = nums[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            second = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-332:Reconstruct Itinerary</title>
    <url>/leetCode/leetCode-332/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [fromi, toi]</code> 表示飞机出发和降落的机场地点。要求对该行程进行重新规划排序（一笔画的做法）。该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：tickets &#x3D; [[“MUC”,”LHR”],[“JFK”,”MUC”],[“SFO”,”SJC”],[“LHR”,”SFO”]]</p>
<p>输出：[“JFK”,”MUC”,”LHR”,”SFO”,”SJC”]</p>
<p>解释：tickets代表的图如下</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg"></p>
</blockquote>
<blockquote>
<p>输入：tickets &#x3D; [[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]</p>
<p>输出：[“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”]</p>
<p>解释：tickets代表的图如下</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg"></p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题是需要将行程按一笔画的方式重新给出每个节点的顺序，使用 <code>Hierholzer </code> 算法进行求解即可，参考：<a href="https://leetcode.cn/problems/reconstruct-itinerary/solutions/389885/zhong-xin-an-pai-xing-cheng-by-leetcode-solution%E3%80%82%60Hierholzer">https://leetcode.cn/problems/reconstruct-itinerary/solutions/389885/zhong-xin-an-pai-xing-cheng-by-leetcode-solution。`Hierholzer</a> &#96; 算法流程如下</p>
<blockquote>
<p>从起点出发，进行深度优先搜索。</p>
<p>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</p>
<p>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</p>
<p>如果要顺序输出路径，则需要将栈中存储的节点进行逆序排序后输出</p>
</blockquote>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line">        Map&lt;String, Queue&lt;String&gt;&gt; map = buildMap(tickets);</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        search(map, result, <span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(Map&lt;String, Queue&lt;String&gt;&gt; map, List&lt;String&gt; result, String current)</span> &#123;</span><br><span class="line">        Queue&lt;String&gt; queue = map.get(current);</span><br><span class="line">        <span class="keyword">if</span> (queue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                search(map, result, queue.poll());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.add(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Queue&lt;String&gt;&gt; <span class="title function_">buildMap</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line">        Map&lt;String, Queue&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; ticket : tickets) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">from</span> <span class="operator">=</span> ticket.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">to</span> <span class="operator">=</span> ticket.get(<span class="number">1</span>);</span><br><span class="line">            map.putIfAbsent(from, <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;());</span><br><span class="line">            map.get(from).add(to);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/reconstruct-itinerary/solutions/389885/zhong-xin-an-pai-xing-cheng-by-leetcode-solution">https://leetcode.cn/problems/reconstruct-itinerary/solutions/389885/zhong-xin-an-pai-xing-cheng-by-leetcode-solution</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-335:Design Twitter</title>
    <url>/leetCode/leetCode-335/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>要求实现一个简单版的 <code>Twitter</code>。题目链接：**<a href="https://leetcode.com/problems/design-twitter/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<p>[“Twitter”, “postTweet”, “getNewsFeed”, “follow”, “postTweet”, “getNewsFeed”, “unfollow”, “getNewsFeed”]<br>[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]</p>
<p>输出：</p>
<p>[null, null, [5], null, null, [6, 5], null, [5]]</p>
<p>解释：</p>
<p>Twitter twitter &#x3D; new Twitter();<br>twitter.postTweet(1, 5); &#x2F;&#x2F; User 1 posts a new tweet (id &#x3D; 5).<br>twitter.getNewsFeed(1);  &#x2F;&#x2F; User 1’s news feed should return a list with 1 tweet id -&gt; [5]. return [5]<br>twitter.follow(1, 2);    &#x2F;&#x2F; User 1 follows user 2.<br>twitter.postTweet(2, 6); &#x2F;&#x2F; User 2 posts a new tweet (id &#x3D; 6).<br>twitter.getNewsFeed(1);  &#x2F;&#x2F; User 1’s news feed should return a list with 2 tweet ids -&gt; [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.<br>twitter.unfollow(1, 2);  &#x2F;&#x2F; User 1 unfollows user 2.<br>twitter.getNewsFeed(1);  &#x2F;&#x2F; User 1’s news feed should return a list with 1 tweet id -&gt; [5], since user 1 is no longer following user 2.</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题是设计类型的题目，只要按要求实现即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Twitter</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> tweetId;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> userId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Tweet</span><span class="params">(<span class="type">int</span> tweetId, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.tweetId = tweetId;</span><br><span class="line">            <span class="built_in">this</span>.userId = userId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTweetId</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> tweetId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserId</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> userId;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Tweet&gt; tweets = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Set&lt;Integer&gt;&gt; followMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Twitter</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> &#123;</span><br><span class="line">        tweets.add(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">Tweet</span>(tweetId, userId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; followSet = followMap.getOrDefault(userId, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Tweet tweet : tweets) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tweetUserId</span> <span class="operator">=</span> tweet.getUserId();</span><br><span class="line">            <span class="keyword">if</span> (tweetUserId == userId || followSet.contains(tweetUserId)) &#123;</span><br><span class="line">                result.add(tweet.getTweetId());</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">10</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; followSet = followMap.getOrDefault(followerId, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">        followSet.add(followeeId);</span><br><span class="line">        followMap.put(followerId, followSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; followSet = followMap.getOrDefault(followerId, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">        followSet.remove(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Twitter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Twitter obj = new Twitter();</span></span><br><span class="line"><span class="comment"> * obj.postTweet(userId,tweetId);</span></span><br><span class="line"><span class="comment"> * List&lt;Integer&gt; param_2 = obj.getNewsFeed(userId);</span></span><br><span class="line"><span class="comment"> * obj.follow(followerId,followeeId);</span></span><br><span class="line"><span class="comment"> * obj.unfollow(followerId,followeeId);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-34:Find First and Last Position of Element in Sorted Array</title>
    <url>/leetCode/leetCode-34/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个升序数组和一个目标数字，要求找出目标数字在数组中的最先出现的位置和最后出现的位置。找不到则输出 [-1, -1]。要求时间复杂度近似于 <code>Olog(n)</code>。 题目链接：**<a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [5,7,7,8,8,10]，target &#x3D; 8</p>
<p>输出：[3,4]</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [5,7,7,8,8,10]，target &#x3D; 6</p>
<p>输出：[-1,-1]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>在一个有序数组中寻找一个数出现的起始位置和结束位置，最简单的做法就是循环遍历数组，记录最先出现的问题和最后出现的位置，但是这种做法时间复杂度为 <code>O(n)</code>，不满足题目的 <code>Olog(n)</code> 的要求，既然时间复杂度是 <code>Olog(n)</code>，那很容易想到用二分法来解决，再加上数组是升序排序的，因此，可以用类似二分搜索的方式来解决。</p>
<p>主要思路为：先用二分查找，找到目标数，然后在左侧数组范围内，继续用二分查找找到最先出现的目标数的下标，同样在右侧数组范围内使用二分查找找到最后出现的目标数的下标，这两个下标就是目标数在数组中出现的开始位置和结束位置。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 寻找升序数组中 nums[end] 元素最先出现的位置，返回其下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findLeftIndex</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[start] == nums[end])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> nums[end];</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> findLeftIndex(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> findLeftIndex(nums, start, mid);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找升序数组中 nums[start] 元素最后出现的位置，返回其下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findRightIndex</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[start] == nums[end])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> nums[start];</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> findRightIndex(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> findRightIndex(nums, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] result = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span> || nums[<span class="number">0</span>] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (mid &gt;= i &amp;&amp; mid &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">                mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">                mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                result[<span class="number">0</span>] = findLeftIndex(nums, i, mid);</span><br><span class="line">                result[<span class="number">1</span>] = findRightIndex(nums, mid, j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-341:Flatten Nested List Iterator</title>
    <url>/leetCode/leetCode-341/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个包含整数或整数列表的列表，要求使用迭代器将列表中的数字进行平铺。题目链接：**<a href="https://leetcode.com/problems/flatten-nested-list-iterator">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nestedList &#x3D; [[1,1],2,[1,1]]</p>
<p>输出：[1,1,2,1,1]</p>
</blockquote>
<blockquote>
<p>输入：nestedList &#x3D; [1,[4,[6]]]</p>
<p>输出：[1,4,6]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题由于有嵌套列表的存在，所以考虑用栈来保存嵌套的列表，由于遍历列表中需要用到下标，所以将 <code>NestedInteger</code> 和遍历的下标封装成对象。由于 <code>[[]]</code> 的存在，所以部分取数放数的逻辑放在 <code>hasNext</code> 下。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * public interface NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     public boolean isInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // Return null if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     public Integer getInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // Return empty list if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     public List&lt;NestedInteger&gt; getList();</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NestedIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        NestedInteger nestedInteger;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(NestedInteger nestedInteger, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.nestedInteger = nestedInteger;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;NestedInteger&gt; nestedList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Node&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nestedList = nestedList;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> stack.pop().nestedInteger.getInteger();</span><br><span class="line">        stack.peek().index++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (current.nestedInteger == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current.index == nestedList.size()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pushNode(nestedList.get(current.index));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current.index == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;NestedInteger&gt; list = current.nestedInteger.getList();</span><br><span class="line">            <span class="keyword">if</span> (current.index &lt; list.size()) &#123;</span><br><span class="line">                <span class="type">NestedInteger</span> <span class="variable">temp</span> <span class="operator">=</span> list.get(current.index);</span><br><span class="line">                pushNode(temp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                stack.peek().index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushNode</span><span class="params">(NestedInteger nestedInteger)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nestedInteger.isInteger()) &#123;</span><br><span class="line">            index = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">Node</span>(nestedInteger, index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i = new NestedIterator(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) v[f()] = i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-343:Integer Break</title>
    <url>/leetCode/leetCode-343/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个<code>2~58</code>的整数，这个整数表示成多个数的和，要求求出拆分的这些子数的积的最大值。题目链接如下：**<a href="https://leetcode.com/problems/integer-break/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：2</p>
<p>输出：1</p>
<p>解释：2 &#x3D; 1 + 1，积为 1 * 1 &#x3D; 1</p>
</blockquote>
<blockquote>
<p>输入：10</p>
<p>输出：36</p>
<p>解释：10 &#x3D; 3 + 3 + 4，积为：3 * 3 * 4 &#x3D; 36，其他组合的值都比36 小</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用动态规划，用 <code>dp[i]</code> 表示整数 <code>i</code> 拆分的子树乘积最大值，则动态转移方程为：<code>dp[i] = max(dp[i], max(dp[j], j) * max(dp[i - j], i - j))</code>，其中 <code>j &lt;= i / 2</code>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * <span class="number">2</span> &lt;= i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(dp[j], j) * Math.max(dp[i - j], i - j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-347:Top K Frequent Elements</title>
    <url>/leetCode/leetCode-347/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出一个数组和一个数字k，要求找出数组中数字出现频率最高的k个数字。如果按照出现频率从高到低取数字时，发现在某个频率有 m 个相同的数字，在该频率前面共有 n 个数字，且 n + m &gt; k，则从m个数字中任意取 k - n个数字，这 k - n个数字无顺序要求，也无特定数字要求。</p>
<p>此题要求时间复杂度小于O(nlog n)，其中 n 是数组的长度</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [][1,1,1,2,2,3] [1,1,1,2,2,3] , k &#x3D; 2</p>
<p>输出：[1,2]</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [1,1,1,3,3,3,2,2,2] , k &#x3D; 2</p>
<p>输出：[1,2]或者[1,3]或者[2,3]。不能输出[1,2,3]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此解法主要参考**<a href="https://leetcode.com/problems/top-k-frequent-elements/discuss/81635/3-Java-Solution-using-Array-MaxHeap-TreeMap">https://leetcode.com/problems/top-k-frequent-elements/discuss/81635/3-Java-Solution-using-Array-MaxHeap-TreeMap</a>**</p>
<p>主要过程如下</p>
<ul>
<li>先遍历数组，找出每个数字出现的次数，存放在map中</li>
<li>遍历map，用一个List数组来存放map中的数组，其中数组的下标是map的value值，表示数字出现的次数，数组下标对应的元素是一个List列表，存放数组中数字出现次数是这个下标值的数字。假设输入数组是[3,4,2,7,7,7,1,1,1,5,5,5,8,8,8,9,9,9,9,9]，则构造的数组如下图所示，数组下标5的位置存放数字9，说明9出现的次数是5次，数组下标位置3存放的数字列表是[7,1,5,8]，说明数字7、1、5、8出现的次数是3，数组下标位置1存放的数字列表是[3,4,2]，说明数字3、4、2出现的次数是1，数组下标位置4、6没有存放数字，说明没有数字出现的次数是4次或6次。</li>
</ul>
<p><img src="/images/leetCode347.png" alt="leetCodde-347 bucket说明图"></p>
<ul>
<li>对第二步骤构造的数组，从后向前遍历，依次取出k个数字作为结果返回。例如以上图为例，假设k &#x3D; 2，则返回[9,7]（数字9出现5次，数字7出现3此，当然也可以返回[9,1]或其他等价的结果），假设k &#x3D; 1，则返回[9]，假设k &#x3D; 5，则返回[9,7,1,5,8]（当然，也可以返回[9,7,5,1,8]或其他等价的结果）</li>
</ul>
<p>整个过程时间复杂度为O(n)，低于题目的要求O(nlog n)</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">topKFrequent</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 步骤1：计算数字出现的次数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; numsMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numCount</span> <span class="operator">=</span> numsMap.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            numsMap.put(nums[i], numCount);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 步骤2：构造 “数字出现次数-数字列表集合” 的List数组</span></span><br><span class="line">        <span class="comment">// numCountsBucket下标位置表示数字出现的个数</span></span><br><span class="line">        <span class="comment">// 下标位置对应的元素表示出现该次数的数字集合列表，列表为空时表示没有出现该数字</span></span><br><span class="line">        <span class="comment">// 由于数字出现次数最多为nums.length，所以构造的数组长度为nums.length + 1</span></span><br><span class="line">        <span class="comment">// 因此没有数字会出现 0 次，数组的 0 下标是预留的</span></span><br><span class="line">        <span class="comment">// 当然也可以构造nums.length长度的数组，只是后面取值时需要减一避免数组越界</span></span><br><span class="line">        List&lt;Integer&gt;[] numCountsBucket = <span class="keyword">new</span> <span class="title class_">List</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;Integer, Integer&gt; entry : numsMap.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            List&lt;Integer&gt; numList = numCountsBucket[count];</span><br><span class="line">            <span class="keyword">if</span> (numList == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                numList.add(num);</span><br><span class="line">                numCountsBucket[count] = numList;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                numList.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 步骤3：从后往前遍历数组，依次取出k个数字作为结果集返回</span></span><br><span class="line">        <span class="comment">// 从出现次数最多的元素依次往下取，列表为空时，表示该没有数字出现该次数</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> numCountsBucket.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Integer&gt; numList = numCountsBucket[i];</span><br><span class="line">            <span class="keyword">if</span> (numList != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result.addAll(numList);</span><br><span class="line">                k -= numList.size();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 由于可能m（m &gt; k）个数字出现次数一样，此时取前k个即可，后续的数字不用返回</span></span><br><span class="line">            <span class="comment">// 例如输入数组[1,1,1,2,2,2,3,3,3]，k = 2，此时返回[1,2]或[1,3]或[2,3]</span></span><br><span class="line">            <span class="comment">// 而不应该返回[1,2,3]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.remove(result.size() - <span class="number">1</span>);</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.com/problems/top-k-frequent-elements/discuss/81635/3-Java-Solution-using-Array-MaxHeap-TreeMap">https://leetcode.com/problems/top-k-frequent-elements/discuss/81635/3-Java-Solution-using-Array-MaxHeap-TreeMap</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-352:Data Stream as Disjoint Intervals</title>
    <url>/leetCode/leetCode-352/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>要求实现一个类，类的功能是将输入的数字转成合并后的区间。题目链接：**<a href="https://leetcode.cn/problems/data-stream-as-disjoint-intervals/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<p>[“SummaryRanges”, “addNum”, “getIntervals”, “addNum”, “getIntervals”, “addNum”, “getIntervals”, “addNum”, “getIntervals”, “addNum”, “getIntervals”]<br>[[], [1], [], [3], [], [7], [], [2], [], [6], []]</p>
<p>输出：</p>
<p>[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]</p>
<p>解释：</p>
<p>SummaryRanges summaryRanges &#x3D; new SummaryRanges();<br>summaryRanges.addNum(1);      &#x2F;&#x2F; arr &#x3D; [1]<br>summaryRanges.getIntervals(); &#x2F;&#x2F; 返回 [[1, 1]]<br>summaryRanges.addNum(3);      &#x2F;&#x2F; arr &#x3D; [1, 3]<br>summaryRanges.getIntervals(); &#x2F;&#x2F; 返回 [[1, 1], [3, 3]]<br>summaryRanges.addNum(7);      &#x2F;&#x2F; arr &#x3D; [1, 3, 7]<br>summaryRanges.getIntervals(); &#x2F;&#x2F; 返回 [[1, 1], [3, 3], [7, 7]]<br>summaryRanges.addNum(2);      &#x2F;&#x2F; arr &#x3D; [1, 2, 3, 7]<br>summaryRanges.getIntervals(); &#x2F;&#x2F; 返回 [[1, 3], [7, 7]]<br>summaryRanges.addNum(6);      &#x2F;&#x2F; arr &#x3D; [1, 2, 3, 6, 7]<br>summaryRanges.getIntervals(); &#x2F;&#x2F; 返回 [[1, 3], [6, 7]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用一个 <code>List</code> 保存合并后的区间，每次放入数字时就对 <code>List</code> 中的数组进行计算更新。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SummaryRanges</span> &#123;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; intervals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SummaryRanges</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;value, value&#125;;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] interval = intervals.get(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// solution for duplicate number</span></span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &lt;= value &amp;&amp; value &lt;= interval[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; value - <span class="number">1</span>) &#123;</span><br><span class="line">                temp.add(interval);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] == value + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[<span class="number">1</span>] = interval[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">1</span>] == value - <span class="number">1</span>) &#123;</span><br><span class="line">                nums[<span class="number">0</span>] = interval[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            temp.add(nums);</span><br><span class="line">            nums = interval;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.add(nums);</span><br><span class="line">        intervals = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] getIntervals() &#123;</span><br><span class="line">        <span class="keyword">return</span> intervals.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[intervals.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SummaryRanges object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SummaryRanges obj = new SummaryRanges();</span></span><br><span class="line"><span class="comment"> * obj.addNum(value);</span></span><br><span class="line"><span class="comment"> * int[][] param_2 = obj.getIntervals();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-35:Search Insert Position</title>
    <url>/leetCode/leetCode-35/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个排好序的升序整形数组和一个目标数字，要求找出这个数字在数组中的位置。如果数字没有出现在数组中，则返回数字应该插入数组的位置。题目链接：**<a href="https://leetcode.com/problems/search-insert-position">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,3,5,6]   5</p>
<p>输出：2</p>
</blockquote>
<blockquote>
<p>输入：[1,3,5,6]   2</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>题目简单，直接遍历判断即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-357:Count Numbers with Unique Digits</title>
    <url>/leetCode/leetCode-357/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数 <code>n, 0 &lt;= n &lt;= 8</code>，要求找出 <code>0 &lt;= x &lt;= 10 ^ n</code> 范围内各个位上数字不同的数的总数。题目链接：<a href="https://leetcode.com/problems/count-numbers-with-unique-digits/description/"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：2</p>
<p>输出：91</p>
</blockquote>
<blockquote>
<p>输入：0</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>这算是一道数学题，当 <code>n</code> 为 <code>1</code>，时，数字位数只有一位，总共有 <code>0 ~ 9</code> 10 个数字，当 <code>n &gt; 1</code> 时，数位有多个，按从左到右算，第一位有 <code>1 ~ 9</code> 9个数字可以选择，第二位有 <code>0 ~ 9</code> 且除去第一位已经选择的数字，共有 9 个数字可以选，第三位有 <code>0 ~ 9</code> 且除去前两位已经选择的数字，共有 8 个数字可以选，第四位有 <code>0 ~ 9</code> 且除去前三位已经选择的数字，共有 7 个数字可以选，以此类推，可以算出当前位数的数字总数，然后把前面位数的数字总数相加，就能得到最终答案。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNumbersWithUniqueDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            current = current * (<span class="number">9</span> - i);</span><br><span class="line">            result += current;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-36:Valid Sudoku</title>
    <url>/leetCode/leetCode-36/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个 9 * 9 的数独棋盘（二维数组），其中只有数字 1~9 或字符 <code>.</code>，用字符 <code>.</code> 代表棋盘位置没有填充数字，要求判断给出的部分填充数字的数独棋盘是否是合法的。其合法性只针对填充的数字而言，未填充的区域不用判断，其要求同时满足以下几个条件：</p>
<ul>
<li>每一行、每一列的数字没有重复</li>
<li>从左到右、从上到下，依次每个 3 * 3 的小矩阵内数字没有重复</li>
</ul>
<p>题目链接：**<a href="https://leetcode.com/problems/valid-sudoku/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，直接按题目要求依次进行判断即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resetArray</span><span class="params">(<span class="type">boolean</span>[] isUsed)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> isUsed.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            isUsed[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">boolean</span>[] isUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 校验每一行每一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 校验每一行</span></span><br><span class="line">            resetArray(isUsed);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> board[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (isUsed[num - <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    isUsed[num - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 校验每一列</span></span><br><span class="line">            resetArray(isUsed);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[j][i] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> board[j][i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (isUsed[num - <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    isUsed[num - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 校验每个 3 * 3 的小矩阵</span></span><br><span class="line">        <span class="comment">// row、col 表示横纵小矩阵的下标</span></span><br><span class="line">        <span class="comment">// i、j 表示小矩阵中元素的横纵下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; <span class="number">3</span>; row++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; <span class="number">3</span>; col++)</span><br><span class="line">            &#123;</span><br><span class="line">                resetArray(isUsed);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i + row * <span class="number">3</span>][j + col * <span class="number">3</span>] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> board[i + row * <span class="number">3</span>][j + col * <span class="number">3</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                            <span class="keyword">if</span> (isUsed[num - <span class="number">1</span>])</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            isUsed[num - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-368:Largest Divisible Subset</title>
    <url>/leetCode/leetCode-368/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个只包含正整数的不存在重复元素的数组，要求找出包含最大长度的子集合（存在多个时返回任意一个即可），该子集合中的元素满足任意两个元素都能整除。题目链接：<a href="https://leetcode.com/problems/largest-divisible-subset"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [1,2,3]</p>
<p>输出：[1, 2]  或 [1, 3]</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [1,2,4,8]</p>
<p>输出：[1, 2, 4, 8]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题就是查找数组中的最大互为公约数子序列。可以使用动态规划求解，先对数组进行排序，然后用 <code>dp[i]</code> 表示以 <code>i</code> 位置元素为递增乘数队列的最后一个元素，则可遍历 <code>[0, i - 1]</code> 中的元素，如果当中某个元素时 <code>i</code> 元素的公约数，则可表示将 <code>i</code> 元素加入到 <code>k</code> 元素的列表中。动态转移方程为 <code>dp[i] = max(dp[k]) + 1</code>，最后，取 <code>dp</code> 数组中元素最大值就是目标数组的元素个数。以此为结果可以倒推结果数组中的每个元素。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestDivisibleSubset</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span>[] dpIndex = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span>[] dpCount = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dpIndex, -<span class="number">1</span>);</span><br><span class="line">        Arrays.fill(dpCount, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] % nums[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dpCount[j] + <span class="number">1</span> &gt; dpCount[i]) &#123;</span><br><span class="line">                        dpCount[i] = dpCount[j] + <span class="number">1</span>;</span><br><span class="line">                        dpIndex[i] = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dpCount[i] &gt; maxCount) &#123;</span><br><span class="line">                maxCount = dpCount[i];</span><br><span class="line">                lastIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (lastIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">            result.add(nums[lastIndex]);</span><br><span class="line">            lastIndex = dpIndex[lastIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-37:Sudoku Solver</title>
    <url>/leetCode/leetCode-37/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个 9 * 9 的数独棋盘（二维数组），其中只有数字 1~9 或字符 <code>.</code>，用字符 <code>.</code> 代表棋盘位置没有填充数字，要求找出数独的解（题目保证每个输入只有唯一的解）。题目链接：**<a href="https://leetcode.com/problems/sudoku-solver/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<p>5 3 . . 7 . . . .<br>6 . . 1 9 5 . . .<br>. 9 8 . . . . 6 .<br>8 . . . 6 . . . 3<br>4 . . 8 . 3 . . 1<br>7 . . . 2 . . . 6<br>. 6 . . . . 2 8 .<br>. . . 4 1 9 . . 5<br>. . . . 8 . . 7 9</p>
<p>输出：</p>
<p>5 3 4 6 7 8 9 1 2<br>6 7 2 1 9 5 3 4 8<br>1 9 8 3 4 2 5 6 7<br>8 5 9 7 6 1 4 2 3<br>4 2 6 8 5 3 7 9 1<br>7 1 3 9 2 4 8 5 6<br>9 6 1 5 3 7 2 8 4<br>2 8 7 4 1 9 6 3 5<br>3 4 5 2 8 6 1 7 9 </p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>直接用递归回溯的方法进行求解，在递归过程中，每次填充数字前先判断要填充的数字是否合法，可以根据此进行剪枝，从而减少不必要的递归。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BOARD_SIZE</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSudokuValid</span><span class="params">(<span class="type">char</span>[][] board)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 校验横、纵列数字是否合法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; BOARD_SIZE; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">boolean</span>[] isRowCellUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[BOARD_SIZE];</span><br><span class="line">            <span class="type">boolean</span>[] isColCellUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[BOARD_SIZE];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; BOARD_SIZE; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRowCellUsed[board[i][j] - <span class="string">&#x27;1&#x27;</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    isRowCellUsed[board[i][j] - <span class="string">&#x27;1&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (isColCellUsed[board[j][i] - <span class="string">&#x27;1&#x27;</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    isColCellUsed[board[j][i] - <span class="string">&#x27;1&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 校验 3 * 3 矩阵内数字是否合法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">blockSize</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; blockSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; blockSize; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">boolean</span>[] isBlockCellUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[BOARD_SIZE];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; blockSize; row++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; blockSize; col++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">cellNum</span> <span class="operator">=</span> board[i * blockSize + row][j * blockSize + col] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                        <span class="keyword">if</span> (isBlockCellUsed[cellNum])</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            isBlockCellUsed[cellNum] = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isCellNumValid</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> rowIndex, <span class="type">int</span> colIndex, <span class="type">int</span> num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">numChar</span> <span class="operator">=</span> (<span class="type">char</span>) (num + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; BOARD_SIZE; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 横列中数字是否有重复</span></span><br><span class="line">            <span class="keyword">if</span> (board[rowIndex][i] == numChar)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 纵列数字是否有重复</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][colIndex] == numChar)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 * 3 矩阵内数字是否重复</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rowBlockIndex</span> <span class="operator">=</span> rowIndex / <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">colBlockIndex</span> <span class="operator">=</span> colIndex / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[rowBlockIndex * <span class="number">3</span> + i][colBlockIndex * <span class="number">3</span> + j] == numChar)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">findSolveSudoku</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> leftCell)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftCell == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> isSudokuValid(board);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; BOARD_SIZE; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; BOARD_SIZE; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= <span class="number">9</span>; k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (isCellNumValid(board, i, j, k))</span><br><span class="line">                        &#123;</span><br><span class="line">                            board[i][j] = (<span class="type">char</span>) (k + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> findSolveSudoku(board, leftCell - <span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">if</span> (isFind)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 9 个数字都无法匹配时，说明此种情况下无解，不用再向后续进行匹配</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftCell</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; BOARD_SIZE; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; BOARD_SIZE; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    leftCell++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        findSolveSudoku(board, leftCell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-371:Sum of Two Integers</title>
    <url>/leetCode/leetCode-371/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个整数，要求在不使用加减法的情况求两数之和。题目链接：**<a href="https://leetcode.com/problems/sum-of-two-integers/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：a &#x3D; 1, b &#x3D; 2;</p>
<p>输出：3</p>
</blockquote>
<blockquote>
<p>输入：a &#x3D; 3, b &#x3D; 4</p>
<p>输出：7</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题要求不能使用加减法，那就意味着需要使用位运算，使用半加器的思路，用与运算求出当前位的进位，用异或运算求出当前位相加后的值，由于进位需要向前移动一位和前一位的值进行运算，因此可以使用 <code>(a &amp; b) &lt;&lt; 1</code> 的值参与前一位的运算。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = a ^ b;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/sum-of-two-integers/solution/liang-zheng-shu-zhi-he-by-leetcode-solut-c1s3/">https://leetcode.cn/problems/sum-of-two-integers/solution/liang-zheng-shu-zhi-he-by-leetcode-solut-c1s3/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-374:Guess Number Higher or Lower</title>
    <url>/leetCode/leetCode-374/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个正整数 <code>n</code>，要求在 <code>1~n</code> 范围内找到预设的数字。猜测数字规则如下：每次调用 <code>int guess(int num) </code> 获取猜测的值与预设的值比较结果，如果相同则返回 <code>0</code>，如果猜测的值比预设的值大，则返回 <code>-1</code>，如果猜测的值比预设的值小，则返回 <code>1</code>。题目链接：<a href="https://leetcode.com/problems/guess-number-higher-or-lower"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：n &#x3D; 10, pick &#x3D; 6</p>
<p>输出：6</p>
</blockquote>
<blockquote>
<p>输入：n &#x3D; 1, pick &#x3D; 1</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用二分查找进行求解，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Forward declaration of guess API.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  num   your guess</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 	     -1 if num is higher than the picked number</span></span><br><span class="line"><span class="comment"> *			      1 if num is lower than the picked number</span></span><br><span class="line"><span class="comment"> *               otherwise return 0</span></span><br><span class="line"><span class="comment"> * int guess(int num);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">GuessGame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">guessNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> guess(middle);</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                start = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-375:Guess Number Higher or Lower II</title>
    <url>/leetCode/leetCode-375/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个正整数 <code>n</code>， 要求在范围 <code>1~n</code> 内找到预设的数字。每次猜测时都会得到比较结果，告知是猜中了还是比预设的数字大或小，如果猜中则赢得游戏，否则扣除猜测数字相同的金币数量，游戏过程中如果金币数量小于等于0，则输掉游戏。要求找到最小的金币数量，使得一定可以赢得游戏。题目链接：<a href="https://leetcode.com/problems/guess-number-higher-or-lower-ii"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：n &#x3D; 10<br>输出：16<br>解释：制胜策略如下：</p>
<ul>
<li>数字范围是 [1,10] 。你先猜测数字为 7 。<br>- 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。<br>     - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。<br>              - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。<br>                  - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 &#x3D; $16 。<br>                       我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 &#x3D; $16 。<br>                           - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。<br>                                - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。<br>                                         - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。<br>                                                 - 如果这是我选中的数字，你的总费用为 $7 + $3 &#x3D; $10 。否则，你需要支付 $5 。<br>                                                      更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 &#x3D; $15 。<br>                                                                  - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 &#x3D; $15 。<br>                                                                       更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。<br>                                                                                   - 如果这是我选中的数字，你的总费用为 $7 + $3 &#x3D; $10 。否则，你需要支付 $1 。<br>                                                                                        更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 &#x3D; $11 。<br>                                                                                        在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2020/09/10/graph.png"></p>
</blockquote>
<blockquote>
<p>输入：n &#x3D; 1</p>
<p>输出：0</p>
<p>解释：只有一个数字，一猜即中</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>采用记忆化搜索进行求解，用 <code>dp[i][j]</code> 表示 <code>i ~ j</code> 区间要赢得游戏所需的最小金币数量，则动态转移方程为 <code>dp[i][j] = k + max(dp[i][k - 1], dp[k + 1][j])</code>，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoneyAmount</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> == j) &#123;</span><br><span class="line">                    dp[i][j] = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> search(dp, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[][] dp, <span class="type">int</span> from, <span class="type">int</span> to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[from][to] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[from][to];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> from + <span class="number">1</span>; k &lt; to; k++) &#123;</span><br><span class="line">            temp = Math.min(temp, k + Math.max(search(dp, from, k - <span class="number">1</span>), search(dp, k + <span class="number">1</span>, to)));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[from][to] = temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[from][to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-38:Count and Say</title>
    <url>/leetCode/leetCode-38/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数字 <code>n (1 &lt;= n &lt;= 30)</code>，要求找出 <code>count-and-say</code> 序列中第 <code>n</code> 个位置的字符串。<code>count-and-say</code> 序列就是用一个数字字符串描述上一个数字字符串。比如：第一个字符串是 <code>1</code>，第二个字符串是 <code>11</code>，表示上一个字符串有 1 个 1，第三个字符串是 <code>21</code>，表示上一个字符串 <code>11</code> 有 2 个 1，第四个字符串是 <code>1211</code>，表示上一个字符串 <code>21</code> 有 1 个 2 和 1 个 1，第五个字符串是 <code>111221</code>，表示上一个字符串 <code>1211</code> 有 1 个1、1 个 2、2 个 1。题目链接：**<a href="https://leetcode.com/problems/count-and-say/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：1</p>
<p>输出：1</p>
</blockquote>
<blockquote>
<p>输入：10</p>
<p>输出：13211311123113112211</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>直接按照题目描述的构造序列的方法从 1 构造到第 n 个序列即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">countAndSay</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// dummy char, the flag which represents the char array is finish</span></span><br><span class="line">            <span class="comment">// and it is never equal to any actual useful char in array</span></span><br><span class="line">            sb.append(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">            <span class="type">char</span>[] prevChars = sb.toString().toCharArray();</span><br><span class="line">            sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; prevChars.length - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (prevChars[j] == prevChars[j + <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    sb.append(count).append(prevChars[j]);</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-386:Lexicographical Numbers</title>
    <url>/leetCode/leetCode-386/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数 n，要求按字典序对 1 到 n 进行排序。题目链接：**<a href="https://leetcode.com/problems/lexicographical-numbers">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：13</p>
<p>输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]</p>
</blockquote>
<blockquote>
<p>输入：4</p>
<p>输出：[1,2,3,4]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>对数字依次乘10，如果不超过范围，则将数字放入结果中。否则先加一，如果达到边界（超过范围，或者结尾有0），则先除10，再继续往下排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">lexicalOrder</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        result.add(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num * <span class="number">10</span> &lt;= n) &#123;</span><br><span class="line">                num *= <span class="number">10</span>;</span><br><span class="line">                result.add(num);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">while</span> (num % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                num /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (num &gt; n) &#123;</span><br><span class="line">                num = num / <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (num % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                num /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            result.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-39:Combination Sum</title>
    <url>/leetCode/leetCode-39/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个不包含重复数字的正整数的数组和一个目标数字，要求找出所有由数组中元素构成的集合的和等于目标数字的列表，数组中的元素可以重复出现在同一个集合中，但是结果列表中不能包含重复的集合。题目链接：**<a href="https://leetcode.com/problems/combination-sum/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[2,3,6,7]     7</p>
<p>输出：[[2,2,3], [7]]</p>
</blockquote>
<blockquote>
<p>输入：[1,2,3]       7</p>
<p>输出：[[1,1,1,1,1,1,1],[1,1,1,1,1,2],[1,1,1,1,3],[1,1,1,2,2],[1,1,2,3],[1,2,2,2],[1,3,3],[2,2,3]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单明了，直接采用回溯算法进行求解即可。为了保证结果中不出现重复的集合，在递归搜索过程中，需要将数组元素依次向后搜索，而不能每次都从头开始搜。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findSum</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, <span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex, List&lt;Integer&gt; nums, <span class="type">int</span> sum)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nums);</span><br><span class="line">                temp.add(candidates[i]);</span><br><span class="line">                result.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum + candidates[i] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                nums.add(candidates[i]);</span><br><span class="line">                findSum(result, candidates, target, i, nums, sum + candidates[i]);</span><br><span class="line">                nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        findSum(result, candidates, target, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-390:Elimination Game</title>
    <url>/leetCode/leetCode-390/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个正整数 <code>n</code>，表示存在 <code>[1, n]</code> 的整数数组，要求对数组进行以下操作：</p>
<ul>
<li>从左到右，间隔删除元素</li>
<li>从右到左，间隔删除元素</li>
<li>重复以上操作直到数组剩下最后一个元素</li>
</ul>
<p>返回数组剩下的最后元素。题目链接：<a href="https://leetcode.com/problems/elimination-game"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：9</p>
<p>输出：6</p>
<p>解释：原始数组：[1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
<p>第一次从左向右间隔删除元素 1、3、5、7、9，数组变为 [2, 4, 6, 8]</p>
<p>第二次从右向左间隔删除元素 8、4，数组变为 [2, 6]</p>
<p>第三次从左向右间隔删除元素 2，数组变为 [6]</p>
<p>此时数组仅剩下最后一个元素，故返回数字 6</p>
</blockquote>
<blockquote>
<p>输入：1</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>如果直接构造数组然后遍历一个一个删除，肯定会超时。需要找到更优化的做法，此做法参考：<a href="https://leetcode.com/problems/elimination-game/solutions/87119/JAVA:-Easiest-solution-O(logN)-with-explanation/">https://leetcode.com/problems/elimination-game/solutions/87119/JAVA:-Easiest-solution-O(logN)-with-explanation/</a>。主要思想是记录每次数组首元素、数组剩余长度、数组时从左向右删除还是从右向左删除。当数组剩下最后一个元素时，将首元素返回。</p>
<p>当删除元素是从左向右删除时，数组首元素会删除（发生变化），数组首元素 <code>head = head + step</code>，<code>step</code> 表示元素之间的间隔（每次数组都是一个等差数列，相邻两个元素之间的间隔时一样的），数组剩余元素个数变为一半。</p>
<p>当删除元素时从右向左删除时，如果数组元素个数是奇数（比如：[2, 4, 6]），那么首元素会发生变化，如果是偶数（比如：[2, 4, 6, 8]），首元素不变。同样，删除后，数组剩余个数变为一半。</p>
<p>举例说明如下：假设 <code>n = 24 </code>，则初始数组为 <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]</code>。此时 <code>head = 1</code>, <code>step = 1</code>，<code>count = 24</code>。</p>
<ul>
<li>第一次，数组从左向右删除，数组首元素被删除，发生变化，变为 <code>head = head + step = 1 + 1 = 2</code>，数组剩余个数 <code>count = count / 2 = 12</code>，<code>step = step * 2 = 1 * 2 = 2</code> （为什么是乘 2，因为数组每次都是等差数列，每次间隔删除元素，删除后相邻元素的差值就是上次相邻元素差值的 2 倍），此时数组变为 <code>[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24]</code></li>
<li>第二次，数组从右向左删除，因为元素个数是 <code>12</code>，偶数，数组首元素不变，仍然为 <code>2</code>，<code>step = step * 2 = 2 * 2 = 4</code>，数组剩余元素 <code>count = count / 2 = 12 / 2 = 6</code>，此时数组变为 <code>[2, 6, 10, 14, 18, 22]</code></li>
<li>第三次，数组从左向右删除，数组首元素被删除，发生变化，变为 <code>head = head + step = 2 + 4 = 6</code>，数组剩余个数 <code>count = count / 2 = 6 / 2 = 3</code>, <code>step = step * 2 = 4 * 2 = 8</code>，此时数组变为 <code>[6, 14, 22]</code></li>
<li>第四次，数组从右向左删除，因为元素个数是 <code>3</code>，奇数，数组元素发生变化，变为 <code>head = head + step = 6 + 8 = 14</code>，数组剩余个数 <code>count = count / 2 = 3 / 2 = 1</code>，<code>step = step * 2 = 8 * 2 = 16</code>，此时数组变为 <code>[14]</code>。由于此时数组剩余元素为 <code>1</code> 个，因此返回数组首元素 <code>14</code></li>
</ul>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFromLeft</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFromLeft) &#123;</span><br><span class="line">                head = head + step;</span><br><span class="line">                isFromLeft = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    head = head + step;</span><br><span class="line">                &#125;</span><br><span class="line">                isFromLeft = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            step = step * <span class="number">2</span>;</span><br><span class="line">            n = n / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.com/problems/elimination-game/solutions/87119/JAVA:-Easiest-solution-O(logN)-with-explanation/">https://leetcode.com/problems/elimination-game/solutions/87119/JAVA:-Easiest-solution-O(logN)-with-explanation/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-393:UTF-8 Validation</title>
    <url>/leetCode/leetCode-393/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，要求判断这个是不是utf-8字符。题目链接：**<a href="https://leetcode.com/problems/utf-8-validation">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[197,130,1]</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：[235,140,4]</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题直接按照题意描述的规则进行判断即可，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ONE_BYTE_START</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ONE_BYTE_END</span> <span class="operator">=</span> <span class="number">0b01111111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TWO_BYTE_START</span> <span class="operator">=</span> <span class="number">0b11000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TWO_BYTE_END</span> <span class="operator">=</span> <span class="number">0b11011111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREE_BYTE_START</span> <span class="operator">=</span> <span class="number">0b11100000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREE_BYTE_END</span> <span class="operator">=</span> <span class="number">0b11101111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FOUR_BYTE_START</span> <span class="operator">=</span> <span class="number">0b11110000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FOUR_BYTE_END</span> <span class="operator">=</span> <span class="number">0b11110111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FOLLOW_BYTE_START</span> <span class="operator">=</span> <span class="number">0b10000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FOLLOW_BYTE_END</span> <span class="operator">=</span> <span class="number">0b10111111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validUtf8</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; data.length) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> data[i];</span><br><span class="line">            <span class="keyword">if</span> (isFourByte(num)) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> isFollowByte(data, i + <span class="number">1</span>) &amp;&amp; isFollowByte(data, i + <span class="number">2</span>) &amp;&amp; isFollowByte(data, i + <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i += <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isThreeByte(num)) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> isFollowByte(data, i + <span class="number">1</span>) &amp;&amp; isFollowByte(data, i + <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i += <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isTwoByte(num)) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> isFollowByte(data, i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isOneByte(num)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isOneByte</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt;= ONE_BYTE_START &amp;&amp; num &lt;= ONE_BYTE_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isTwoByte</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt;= TWO_BYTE_START &amp;&amp; num &lt;= TWO_BYTE_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isThreeByte</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt;= THREE_BYTE_START &amp;&amp; num &lt;= THREE_BYTE_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFourByte</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt;= FOUR_BYTE_START &amp;&amp; num &lt;= FOUR_BYTE_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFollowByte</span><span class="params">(<span class="type">int</span>[] data, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; data.length &amp;&amp; data[i] &gt;= FOLLOW_BYTE_START &amp;&amp; data[i] &lt;= FOLLOW_BYTE_END;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-394:Decode String</title>
    <url>/leetCode/leetCode-394/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个编码的字符串，格式为 <code>k[encoded_string]</code>，表示方括号内字符串重复 <code>k</code> 次。字符串可能存在嵌套编码，即 <code>3[ab2[c]]</code>，表示字符串 <code>abccabccabcc</code>。要求将编码的字符串进行解码还原。题目链接：**<a href="https://leetcode.com/problems/decode-string">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：3[a]2[bc]</p>
<p>输出：aaabcbc</p>
</blockquote>
<blockquote>
<p>输入：3[a2[c]]</p>
<p>输出：accaccacc</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>由于是用中括号来表示重复的字符串，且可能存在嵌套循环。考虑到括号匹配是用栈来判断的，所以此处仍然用栈来求解。为了便于表示并还原字符串，栈中存储的是左括号的下标，当遇到右括号的下标时，取出栈中元素可以匹配一个完整的循环字符串，而左括号之前去除数字部分即本轮还原后字符串前缀，右括号后面字符串即本轮还原后字符串后缀。这三者相加即本轮还原的字符串。字符串遍历结束即代表还原完成。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> s;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; result.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> result.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">String</span> <span class="variable">loopTimeStr</span> <span class="operator">=</span> getLoopTimeStr(result, leftIndex - <span class="number">1</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> result.substring(<span class="number">0</span>, leftIndex - loopTimeStr.length());</span><br><span class="line">                <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> result.substring(i + <span class="number">1</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">loopStr</span> <span class="operator">=</span> result.substring(leftIndex + <span class="number">1</span>, i);</span><br><span class="line">                result = prefix + copyString(loopStr, Integer.parseInt(loopTimeStr)) + suffix;</span><br><span class="line"></span><br><span class="line">                i = result.length() - suffix.length() - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">copyString</span><span class="params">(String str, <span class="type">int</span> count)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getLoopTimeStr</span><span class="params">(String str, <span class="type">int</span> endIndex)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> endIndex; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.append(str.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-395:Longest Substring with At Least K Repeating Characters</title>
    <url>/leetCode/leetCode-395/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出一个只包含小写字母的字符串和一个整数 k，要求找出字符串中的一个最长子字符串T，其中要求T中的每个字符出现的次数都必须大于等于 k。题目链接：**<a href="https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：s &#x3D; “aaabb”, k &#x3D; 3</p>
<p>输出：3</p>
<p>解释：返回的是<code>aaa</code>字符串的长度</p>
</blockquote>
<blockquote>
<p>输入：s &#x3D; “ababbc”, k &#x3D; 2</p>
<p>输出：5</p>
<p>解释：返回的是<code>ababb</code>字符串的长度</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="暴力查询-1（超时）"><a href="#暴力查询-1（超时）" class="headerlink" title="暴力查询-1（超时）"></a>暴力查询-1（超时）</h2><p>采用暴力的做法，需要将字符串的所有子字符串找出，这个过程需要<code>O(n^2)</code>时间复杂度，然后对每个字符串判断是否满足要求，这个过程需要<code>O(n)</code>，由于判断子字符串是否满足要求这个过程在查找全部子字符串的过程中，因此整个过程需要<code>O(n^3)</code>时间复杂度。这虽然简单，但是超时了。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isCharsNoLessThanK</span><span class="params">(String s, <span class="type">int</span> k, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] charNums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= endIndex; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            charNums[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= endIndex; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (charNums[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubstring</span><span class="params">(String s, <span class="type">int</span> k)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || k &gt; s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (isCharsNoLessThanK(s, k, i, j))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; maxLength)</span><br><span class="line">                    &#123;</span><br><span class="line">                        maxLength = j - i + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="暴力查询-2（超时）"><a href="#暴力查询-2（超时）" class="headerlink" title="暴力查询-2（超时）"></a>暴力查询-2（超时）</h2><p>上一种暴力查询的方法，由于把判断子字符串是否满足要求的循环放在了查找子字符串的循环中，导致多了一层循环，如果先找出所有的子字符串，再依次判断子字符串是否满足要求并找出满足要求的最长的子字符串的长度。这样可以将时间复杂度降为<code>O(n^2)</code>，可惜这样还是超时了。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isCharsNoLessThanK</span><span class="params">(String s, <span class="type">int</span> k)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] charNums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            charNums[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (charNums[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubstring</span><span class="params">(String s, <span class="type">int</span> k)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || k &gt; s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        List&lt;String&gt; subStrings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                subStrings.add(s.substring(i, j + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String subString : subStrings)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCharsNoLessThanK(subString, k) &amp;&amp; maxLength &lt; subString.length())</span><br><span class="line">            &#123;</span><br><span class="line">                maxLength = subString.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分治算法（4ms通过）"><a href="#分治算法（4ms通过）" class="headerlink" title="分治算法（4ms通过）"></a>分治算法（4ms通过）</h2><p>对于某个不满足要求的字符，暴力查询并不会对其进行过滤，仍然会产生许多包含此字符的子字符串并进行判断。这就导致了时间的耗费。而采用分治算法时，当发现某个字符不满足要求，则以此字符为分割点，对左边的字符串进行类似的递归查找，对右边的字符串也进行类似的递归查找。然后将这两个结果进行比较，将最大结果返回即可。此解法的时间复杂度为<code>O(nlogn)</code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">longestSubstringLength</span><span class="params">(String string, <span class="type">int</span> k, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 由于此函数参数 k &gt;= 2，因此当startIndex == endIndex时，也是不满足要求的</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= endIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找出范围内的字母的数量</span></span><br><span class="line">        <span class="comment">// 如果取出全是小写字母的限制，此处可以改为Map</span></span><br><span class="line">        <span class="type">int</span>[] charNums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= endIndex; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">charIndex</span> <span class="operator">=</span> string.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            charNums[charIndex] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到满足要求的起始下标</span></span><br><span class="line">        <span class="keyword">while</span> (startIndex &lt;= endIndex &amp;&amp; charNums[string.charAt(startIndex) - <span class="string">&#x27;a&#x27;</span>] &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            startIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到满足要求的结束下标</span></span><br><span class="line">        <span class="keyword">while</span> (startIndex &lt;= endIndex &amp;&amp; charNums[string.charAt(endIndex) - <span class="string">&#x27;a&#x27;</span>] &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            endIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在起始下标和结束下标的范围内没有满足要求的字符串</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= endIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找在起始下标和结束下标的范围内是否有不满足要求的字符</span></span><br><span class="line">        <span class="comment">// 有则以此为界限，分别对左边的字符串和右边的字符串查找满足要求的子字符的长度</span></span><br><span class="line">        <span class="comment">// 然后比较获取最大的长度值作为返回结果</span></span><br><span class="line">        <span class="comment">// 没有则说明在起始下标和结束下标的范围内的字符都满足要求，直接返回结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> endIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; index &gt;= startIndex; index--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (charNums[string.charAt(index) - <span class="string">&#x27;a&#x27;</span>] &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在起始下标和结束下标之间的字符都满足要求，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (index == startIndex - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> endIndex - startIndex + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在起始下标和结束下标之间startIndex位置的字符不满足要求</span></span><br><span class="line">        <span class="comment">// 则从这里划分，分别找出左边子字符串和右边子字符串的满足要求的最长字符串的长度</span></span><br><span class="line">        <span class="comment">// 然后进行比较得到最终结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftResult</span> <span class="operator">=</span> longestSubstringLength(string, k, startIndex, index - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightResult</span> <span class="operator">=</span> longestSubstringLength(string, k, index + <span class="number">1</span>, endIndex);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (leftResult &gt; rightResult)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> leftResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubstring</span><span class="params">(String s, <span class="type">int</span> k)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || k &gt; s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longestSubstringLength(s, k, <span class="number">0</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-396:Rotate Function</title>
    <url>/leetCode/leetCode-396/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数组，定义它的旋转数组为 <code>f(k) = k * a[0] + (k + 1) * a[1] + (k + 2) * a[2] + ... + (n - 1) * a[n - k - 1] + 0 * a[n - k] + 1 * a[n - k + 1] + ... </code>，比如对于数组 <code>[4,3,2,6]</code>，其旋转数组为：<code>f(0) = 0 * 4 + 1 * 3 + 2 * 2 + 3 * 6 = 25</code>，<code>f(1) = 1 * 4 + 2 * 3 + 3 * 2 + 0 * 6 = 16</code>，<code>f(2) = 2 * 4 + 3 * 3 + 0 * 2 + 1 * 6 = 23</code>，<code>f(3) = 3 * 4 + 0 * 3 + 1 * 2 + 2 * 6 = 26</code> 要求找出最大的旋转数组的值。题目链接：**<a href="https://leetcode.com/problems/rotate-function/description">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [4,3,2,6]</p>
<p>输出：26</p>
<p>解释：f(0) &#x3D; 0 * 4 + 1 * 3 + 2 * 2 + 3 * 6 &#x3D; 25</p>
<p>f(1) &#x3D; 1 * 4 + 2 * 3 + 3 * 2 + 0 * 6 &#x3D; 16</p>
<p>f(2) &#x3D; 2 * 4 + 3 * 3 + 0 * 2 + 1 * 6 &#x3D; 23</p>
<p>f(3) &#x3D; 3 * 4 + 0 * 3 + 1 * 2 + 2 * 6 &#x3D; 26</p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [100]</p>
<p>输出：0</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此问题最直接的解法是按照题意循环算出每个旋转函数的值，但是这样太耗时了，优化点的做法是使用动态规划，动态转移方程为 <code>f(k) = f(k - 1) + sumArray - n * nums[n - k]</code>。此方法主要参考：<a href="https://leetcode.cn/problems/rotate-function/solution/xuan-zhuan-shu-zu-by-leetcode-solution-s0wd/%E3%80%82%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B">https://leetcode.cn/problems/rotate-function/solution/xuan-zhuan-shu-zu-by-leetcode-solution-s0wd/。代码如下</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxRotateFunction</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            first = first + i * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> first + sum - nums.length * nums[nums.length - i];</span><br><span class="line">            result = Math.max(result, current);</span><br><span class="line">            first = current;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/rotate-function/solution/xuan-zhuan-shu-zu-by-leetcode-solution-s0wd/">https://leetcode.cn/problems/rotate-function/solution/xuan-zhuan-shu-zu-by-leetcode-solution-s0wd/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-397:Integer Replacement</title>
    <url>/leetCode/leetCode-397/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数，要求算出该整数经过多少次最小变化可以到达1，变化的规则：如果是奇数，可以加一或减一，如果是偶数，直接除2。题目链接：**<a href="https://leetcode.com/problems/integer-replacement/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：8</p>
<p>输出：3</p>
<p>解释：变化路径：8 -&gt; 4 -&gt; 2 -&gt; 1</p>
</blockquote>
<blockquote>
<p>输入：7</p>
<p>输出：4</p>
<p>解释：变化路径：7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1 或 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>直接使用深度搜索算法进行搜索，在搜索过程中对已经搜索过的结果进行存储，以免后续进行重复搜索。由于可能存在 <code>2 ^ 31 -1</code>，如果对其进行加一，可能会超过边界，所以使用 <code>n / 2 + 1</code> 和 <code>n / 2</code> 来替换 <code>n + 1</code> 和 <code>n - 1</code> 的操作，在获得结果后加二即可得到相同的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerReplacement</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> search(n, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> n, Map&lt;Integer, Integer&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(n)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            result = search(n / <span class="number">2</span>, map) + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> search(n / <span class="number">2</span> + <span class="number">1</span>, map);</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> search(n / <span class="number">2</span>, map);</span><br><span class="line">            result = Math.min(temp1, temp2) + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.put(n, Math.min(result, map.getOrDefault(n, Integer.MAX_VALUE)));</span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-398:Random Pick Index</title>
    <url>/leetCode/leetCode-398/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数组，要求随机输出给定的目标数字 <code>target</code> 的索引。题目链接：<a href="https://leetcode.com/problems/random-pick-index"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：</p>
<p>[“Solution”, “pick”, “pick”, “pick”]<br>[[[1, 2, 3, 3, 3]], [3], [1], [3]]</p>
<p>输出：<br>[null, 4, 0, 2]</p>
<p>解释：</p>
<p>Solution solution &#x3D; new Solution([1, 2, 3, 3, 3]);<br>solution.pick(3); &#x2F;&#x2F; It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.<br>solution.pick(1); &#x2F;&#x2F; It should return 0. Since in the array only nums[0] is equal to 1.<br>solution.pick(3); &#x2F;&#x2F; It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.</p>
</blockquote>
<blockquote>
<p>输入：</p>
<p>[“Solution”, “pick”]</p>
<p>[[[1, 2, 3]], [1]]</p>
<p>输出：</p>
<p>[null, 0]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>初始化时先遍历数组，将相同数字的下标存在 <code>map</code> 中，后续取数字时取出对应数字的下标列表，从中随机取出下标返回。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = map.getOrDefault(nums[i], <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            temp.add(i);</span><br><span class="line">            map.put(nums[i], temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pick</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numList = map.get(target);</span><br><span class="line">        <span class="keyword">return</span> numList.get(random.nextInt(numList.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-399:Evaluate Division</title>
    <url>/leetCode/leetCode-399/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个列表和一个数组，列表中都是只包含两个元素的列表，表示两个元素相除的方程式，其结果是数组中对应的下标元素的值。再给出另一个列表用于查询方程式相除的结果，如果某个方程式没查询到结果，则返回 -1.0。题目链接：**<a href="https://leetcode.com/problems/evaluate-division/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：equations &#x3D; [[“a”,”b”],[“b”,”c”]], values &#x3D; [2.0,3.0], queries &#x3D; [[“a”,”c”],[“b”,”a”],[“a”,”e”],[“a”,”a”],[“x”,”x”]]</p>
<p>输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]</p>
</blockquote>
<blockquote>
<p>输入：equations &#x3D; [[“a”,”b”],[“b”,”c”],[“bc”,”cd”]], values &#x3D; [1.5,2.5,5.0], queries &#x3D; [[“a”,”c”],[“c”,”b”],[“bc”,”cd”],[“cd”,”bc”]]</p>
<p>输出：[3.75000,0.40000,5.00000,0.20000]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用带权并查集进行求解，在每次查找根节点的过程中，进行路径压缩的同时更新边的权值（此处值两数相除的结果），在合并根节点的同时，也进行边权值的更新，此处的更新考虑 <code>四边形</code> 的情况，其更新表达式为 <code>value[firstParent] = currentEdgeValue * value[second] / value[first]</code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries)</span><br><span class="line">    &#123;</span><br><span class="line">        Set&lt;String&gt; nodeSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String, String&gt; parentMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String, Double&gt; valueMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        build(nodeSet, parentMap, valueMap, equations, values);</span><br><span class="line">        <span class="keyword">return</span> query(nodeSet, parentMap, valueMap, queries);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span>[] query(Set&lt;String&gt; nodeSet, Map&lt;String, String&gt; parentMap, Map&lt;String, Double&gt; valueMap, List&lt;List&lt;String&gt;&gt; queries)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span>[] result = <span class="keyword">new</span> <span class="title class_">double</span>[queries.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queries.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> queries.get(i).get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!nodeSet.contains(first) || !nodeSet.contains(second))</span><br><span class="line">            &#123;</span><br><span class="line">                result[i] = -<span class="number">1.0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">firstParent</span> <span class="operator">=</span> getParent(first, parentMap, valueMap);</span><br><span class="line">            <span class="type">String</span> <span class="variable">secondParent</span> <span class="operator">=</span> getParent(second, parentMap, valueMap);</span><br><span class="line">            <span class="keyword">if</span> (!firstParent.equals(secondParent))</span><br><span class="line">            &#123;</span><br><span class="line">                result[i] = -<span class="number">1.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result[i] = valueMap.get(first) / valueMap.get(second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(Set&lt;String&gt; nodeSet, Map&lt;String, String&gt; parentMap, Map&lt;String, Double&gt; valueMap, List&lt;List&lt;String&gt;&gt; equations, <span class="type">double</span>[] values)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; equations.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;String&gt; equation = equations.get(i);</span><br><span class="line">            <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> equation.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> equation.get(<span class="number">1</span>);</span><br><span class="line">            nodeSet.add(first);</span><br><span class="line">            nodeSet.add(second);</span><br><span class="line">            <span class="type">String</span> <span class="variable">firstParent</span> <span class="operator">=</span> getParent(first, parentMap, valueMap);</span><br><span class="line">            <span class="type">String</span> <span class="variable">secondParent</span> <span class="operator">=</span> getParent(second, parentMap, valueMap);</span><br><span class="line">            <span class="keyword">if</span> (!firstParent.equals(secondParent))</span><br><span class="line">            &#123;</span><br><span class="line">                parentMap.put(firstParent, secondParent);</span><br><span class="line">                valueMap.put(firstParent, values[i] * valueMap.get(second) / valueMap.get(first));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getParent</span><span class="params">(String str, Map&lt;String, String&gt; parentMap, Map&lt;String, Double&gt; valueMap)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentMap.get(str) == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            valueMap.put(str, <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">root</span> <span class="operator">=</span> getParent(parentMap.get(str), parentMap, valueMap);</span><br><span class="line">        valueMap.put(str, valueMap.get(str) * valueMap.get(parentMap.get(str)));</span><br><span class="line">        parentMap.put(str, root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-4:Median of Two Sorted Arrays</title>
    <url>/leetCode/leetCode-4/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个有序的数组，要求找出合并后的数组的中位数，要求时间复杂度为 <code>O(log (m + n))</code>。题目链接：**<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1, 3], [2]</p>
<p>输出：2.0</p>
</blockquote>
<blockquote>
<p>输入：[1, 2], [3, 4]</p>
<p>输出：2.5</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>刚开始看这题目时，很容易想到的是用归并的思想，分别从头遍历两个数组直到第 k 个元素，但是这样的时间复杂度是 <code>O(k)</code> ，这跟先使用归并算法再直接查找元素的时间复杂度 <code>O(m + n)</code> 查不多，但是都不满足题目的要求。题目要求的时间复杂度为 <code>O(log (m + n))</code>，这很容易想到二分查找，而此题也正是用二分查找来解决。</p>
<p>首先，将查找中位数的问题转换为查找两个有序数组中第 k 个元素的问题，接着，在每个数组中，分别查找第 k&#x2F;2 个元素，将这两个元素进行比较，对于比较小的那个元素，其所在数组中的前面和自己这总共 k &#x2F; 2 个元素必然包含在两个数组合并后的前 k 个元素之中，因此，在一轮进行查找时就可以跳过这部分元素，在剩下的元素中查找第 k&#x2F;2 个元素，以此递归下去，直到最后一个元素为止。</p>
<p>此过程时间复杂度为 <code>O(log k)</code> 由于 k &lt; m + n，所以满足题目的 <code>O(log (m + n))</code> 的要求。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找两个给定的有序数组合并后第 k 个元素，k 从 1 开始计数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a      第一个数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aStart 第一个数组开始元素下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b      第二个数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bStart 第二个数组开始元素下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k      查找第 k 个元素，从 1 开始计数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>       给定数组合并后的第 k 个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findKthNum</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> aStart, <span class="type">int</span>[] b, <span class="type">int</span> bStart, <span class="type">int</span> k)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (aStart &gt;= a.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> b[bStart + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bStart &gt;= b.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a[aStart + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(a[aStart], b[bStart]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分别获取两个数组中第 k/2 元素所在的下标，如果超过数组长度，则为该数组最后元素的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">aKIndex</span> <span class="operator">=</span> Math.min(aStart + k / <span class="number">2</span>  - <span class="number">1</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">bKIndex</span> <span class="operator">=</span> Math.min(bStart + k - k / <span class="number">2</span> - <span class="number">1</span>, b.length - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一个数组的第 k/2 个元素小于或等于第二个数组时，</span></span><br><span class="line">        <span class="comment">// 说明第一个数组的前 k/2 个元素必然包含在合并后的前 k 个元素之中，</span></span><br><span class="line">        <span class="comment">// 此时可以去除第一个数组的前 k/2 个元素，在剩下的元素中查找第 k/2 个元素。</span></span><br><span class="line">        <span class="comment">// 相反，如果第一个数组的第 k/2 个元素大于第二个数组时</span></span><br><span class="line">        <span class="comment">// 说明第二个数组的前 k/2 个元素必然包含在合并后的前 k 个元素之中，</span></span><br><span class="line">        <span class="comment">// 此时可以去除第二个数组的前 k/2 个元素，在剩下的元素中查找第 k/2 个元素。</span></span><br><span class="line">        <span class="keyword">if</span> (a[aKIndex] &lt;= b[bKIndex])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> findKthNum(a, aKIndex + <span class="number">1</span>, b, bStart, k - (aKIndex - aStart + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> findKthNum(a, aStart, b, bKIndex + <span class="number">1</span>, k - (bKIndex - bStart + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nums1.length + nums2.length) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">firstNum</span> <span class="operator">=</span> findKthNum(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, (nums1.length + nums2.length) / <span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">secondNum</span> <span class="operator">=</span> findKthNum(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) (firstNum + secondNum) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) findKthNum(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>一个程序渣渣的小后院. 每天一道LeetCode—–两个有序数组合并后的第K个数[J&#x2F;OL].<a href="https://blog.csdn.net/sinat_35261315/article/details/78249251">https://blog.csdn.net/sinat_35261315/article/details/78249251</a>, 2017-10-16</li>
</ol>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-40:Combination Sum II</title>
    <url>/leetCode/leetCode-40/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个包含重复数字的正整数的数组和一个目标数字，要求找出所有由数组中元素构成的集合的和等于目标数字的列表，数组中的每个元素在同一个集合中最多只能出现一次，在结果列表中不能包含重复的集合。题目链接：**<a href="https://leetcode.com/problems/combination-sum-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,1,1,2,2,3,3,3,4,4,4]   7</p>
<p>输出：[[1,1,1,2,2],[1,1,1,4],[1,1,2,3],[1,2,4],[1,3,3],[2,2,3],[3,4]]</p>
</blockquote>
<blockquote>
<p>输入：[10,1,2,7,6,1,5]             8</p>
<p>输出：[[1,1,6],[1,2,5],[1,7],[2,6]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题跟<a href="https://guozhchun.github.io/2018/12/09/leetCode/leetCode-39/">leetcode-39:Combination Sum</a>类似，不同的是原先数组中有重复元素，且数组中的元素在同一个构成集合中只能出现一次。此题仍然可以用<a href="https://guozhchun.github.io/2018/12/09/leetCode/leetCode-39/">leetcode-39:Combination Sum</a>中的算法来求解。只是需要剔除重复的结果集。最简单直接的方法就是暴力搜索出所有的结果，然后去重，但是这样耗时太长。可以使用剪枝的做法：在每次递归中循环遍历数组元素时，如果当前数组元素跟前一个数组元素相同，则不用再进行遍历查找，因为前一个数组元素已经将所有情况都遍历过了。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findSum</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, <span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex, List&lt;Integer&gt; nums, <span class="type">int</span> sum)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nums);</span><br><span class="line">                temp.add(candidates[i]);</span><br><span class="line">                result.add(temp);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            nums.add(candidates[i]);</span><br><span class="line">            findSum(result, candidates, target, i + <span class="number">1</span>, nums, sum + candidates[i]);</span><br><span class="line">            nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        findSum(result, candidates, target, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-41:First Missing Positive</title>
    <url>/leetCode/leetCode-41/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整形数组，要求用<code>O(n)</code>的时间复杂度和<code>O(1)</code>的空间复杂度，找出这些数字中缺少的第一个正整数。题目链接：**<a href="https://leetcode.com/problems/first-missing-positive">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1, 3, 2, 5]</p>
<p>输出：4</p>
</blockquote>
<blockquote>
<p>输入：[-1, 3, 2, 7, 3]</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>刚开始拿到这道题目，第一反映是对数组进行排序，然后遍历数组找出缺少的正整数。但是这样时间复杂度是<code>O(nlogn)</code>，并不满足题目要求。顺着这个思路，想到了计数排序的方法，可以把时间复杂度控制在<code>O(n)</code>，但是这样空间复杂度也需要<code>O(n)</code>，还是不满足要求。还是顺着计数排序的思路，只不过这次不新用数组存储，而是直接在原数组上进行操作。</p>
<p>首先遍历数组，对每个元素进行如下判断：按照计数排序的方法，此位置的元素是否准确，如果不准确，则将这个位置的元素与对应下标的元素交换，然后重复上述判断，直到遇到条件不满足（要交换的元素与当前元素值相同，当前元素值不在数组下标范围内）时结束。当循环结束时，判断当前位置的元素是否是下标值加一，如果不是，说明当前位置值不对，将其值设置为 0。待上述循环结束后，此时数组元素只有两种情况，位置正确的正整数和缺少对应正整数的 0。此时再用一个循环遍历，找到第一个 0 的位置，就是缺失的第一个正整数。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= length &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 交换 i 和 nums[i] - 1 两个下标对应的元素</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                nums[t - <span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-412:Remove K Digits</title>
    <url>/leetCode/leetCode-412/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个包含非负整数的字符串 <code>num</code> （<code>num</code> 中没有前置 <code>0</code>）和一个数字 <code>k</code>，要求在 <code>num</code> 中剔除 <code>k</code> 个字符，使得剩下的字符串代表的数字最小。题目链接：**<a href="https://leetcode.com/problems/remove-k-digits/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：num &#x3D; “1432219”, k &#x3D; 3</p>
<p>输出：”1219”</p>
</blockquote>
<blockquote>
<p>输入：num &#x3D; “10200”, k &#x3D; 1</p>
<p>输出：”200”</p>
<p>解释：删除第一个 1，剩下 0200，去除前置 0，返回 200</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用一个字符串来存储剔除后剩下的字符，遍历原有字符串，对当前字符进行判断，如果当前字符是 0，则判断存储的结果字符串中的第一个和最后一个字符串，哪个大则剔除哪个，如果当前字符比存储结果字符串的最后一位小，则剔除存储结果字符串的最后一位，直到当前字符比存储结果的最后一位大时为止，然后将当前字符加入到结果字符串中。当然，为了不多删字符，每次剔除字符时需要计数并与 <code>k</code> 进行比较，只有剔除的数量小于 <code>k</code> 才能剔除。最后，当遍历完字符串后，如果剔除的字符数量还是小于 <code>k</code> ，则从结果字符串中末尾剔除直到剔除数量等于 <code>k</code> 为止。然后再剔除结果字符串的前置 0，最后判断是否是空字符串，如果是则返回 “0”，否则返回当前的结果字符串。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeKdigits</span><span class="params">(String num, <span class="type">int</span> k)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> num.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (result.length() &gt; <span class="number">0</span> &amp;&amp; count &lt; k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 比较结果字符串中第一个和最后一个的字符，哪个大则删除哪个</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (result.charAt(<span class="number">0</span>) &lt; result.charAt(result.length() - <span class="number">1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        index = result.length() - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 0 只会出现在最前面，此时剔除 0 不用计数</span></span><br><span class="line">                    <span class="keyword">if</span> (result.charAt(index) != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result.deleteCharAt(index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (result.length() &gt; <span class="number">0</span> &amp;&amp; result.charAt(result.length() - <span class="number">1</span>) &gt; ch &amp;&amp; count &lt; k)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.deleteCharAt(result.length() - <span class="number">1</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.append(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里是，结果字符串中已经是递增的序列了，如果还有需要剔除的，只删除末尾部分即可</span></span><br><span class="line">        <span class="keyword">while</span> (count &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            result.deleteCharAt(result.length() - <span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剔除前置 0</span></span><br><span class="line">        <span class="keyword">while</span> (result.length() &gt; <span class="number">0</span> &amp;&amp; result.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-413:Arithmetic Slices</title>
    <url>/leetCode/leetCode-413/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数组，要求找出其中等差数列的子数组（连续元素构成的子数组）的个数。题目链接：**<a href="https://leetcode.com/problems/arithmetic-slices/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3,4]</p>
<p>输出：3</p>
<p>解释：子数组为：[1,2,3]、[2,3,4]、[1,2,3,4]</p>
</blockquote>
<blockquote>
<p>输入：[1]</p>
<p>输出：0</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用二维数组 <code>dp[i][j]</code> 表示由 <code>i</code> 到 <code>j</code> 构成的子数组是否是等差数列，如果是设置值为 <code>true</code>，否则设置为 <code>false</code>，最后遍历数组统计 <code>true</code> 的数量即为答案。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfArithmeticSlices</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length][nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] - nums[i - <span class="number">2</span>] == nums[i] - nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i - <span class="number">2</span>][i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j][i - <span class="number">1</span>] &amp;&amp; nums[i] - nums[i - <span class="number">1</span>] == nums[i - <span class="number">1</span>] - nums[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                    dp[j][i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j]) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-416:Partition Equal Subset Sum</title>
    <url>/leetCode/leetCode-416/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，<code>1 &lt;= nums.length &lt;= 200</code>，<code>1 &lt;= nums[i] &lt;= 100</code>，要求判断是否可以将数组分割成两个子数组，并且这两个子数组的元素和相同。题目链接：<a href="https://leetcode.com/problems/partition-equal-subset-sum"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,5,11,5]</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：[1,2,3,5]</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题用暴力求解会超时，需要使用动态规划进行求解，可以将此题转换为从数组中挑选出 <code>k</code> 个元素，使这些元素和等于目标数。此题类似背包问题，用 <code>dp[i][j]</code> 表示前 <code>i</code> 个元素中是否存在某些元素和等于 <code>j</code>，针对每个新元素都存在选与不选的情况，动态转移方程为：<code>dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]] </code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length][total + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i][nums[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] || (j &gt;= nums[i] &amp;&amp; dp[i - <span class="number">1</span>][j - nums[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>][total / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-42:Trapping Rain Water</title>
    <url>/leetCode/leetCode-42/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个非负整数的数组，每个数字代表柱子的长度，要求计算出这些柱子组成的容器可以存储的雨水量。题目链接：**<a href="https://leetcode.com/problems/trapping-rain-water/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[0,1,0,2,1,0,1,3,2,1,2,1]</p>
<p>输出：6</p>
</blockquote>
<blockquote>
<p>输入：[5,4,3,2,1,0,1,2,3,4,5]</p>
<p>输出：25</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>循环遍历数组，分别计算每个位置能够存储的雨水量，将其相加得到最终答案。为了能得到每个位置能够存储的雨水量，可以用双指针的方式逐渐缩小范围。</p>
<ul>
<li><p>开始时，两个指针分别在数组首尾处。</p>
</li>
<li><p>如果左边的柱子小于右边的柱子，则用另一个指针在两根柱子之间从左到右进行移动，如果当前位置柱子长度小于左边的柱子，则计算当前位置能够存储的雨水量，将其加入总的蓄水量中，否则将左边柱子的位置移动到当前位置。</p>
</li>
<li><p>如果左边的柱子大于右边的柱子，则用另一个指针在两根柱子之间从右到左进行移动，如果当前位置柱子长度小于右边的柱子，则计算当前位置能够存储的雨水量，将其加入总的蓄水量中，否则将右边柱子的位置移动到当前位置。</p>
</li>
<li><p>重复上述过程直到左右两个柱子相邻，此时的蓄水总量就是要求的答案。</p>
</li>
</ul>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="literal">null</span> || height.length &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (height[left] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (height[right] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (height[index] &lt; height[left])</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += height[left] - height[index];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                left = index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> right - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (height[index] &lt; height[right])</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += height[right] - height[index];</span><br><span class="line">                    index--;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                right = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-427:Construct Quad Tree</title>
    <url>/leetCode/leetCode-427/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个 <code>n * n</code> 的二维数组（n &#x3D; 1,2,4,6,8,16,32,64)，数组元素为 0 或 1。要求将数组构造成一个四叉树。构造树的规则如下，如果一个正方形内元素都是 0 或 1，那么由该正方形构成一个叶子节点，节点元素值为 true (正方形元素都是 1)或 false (正方形元素都是0)，如果一个正方形内的元素不同，则该正方形代表一个非叶子节点，且则将正方形均分成四个小正方形，作为该非叶子节点的子节点。题目链接：<a href="https://leetcode.com/problems/construct-quad-tree"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：grid &#x3D; [[0,1],[1,0]]</p>
<p>输出：[[0,1],[1,0],[1,1],[1,1],[1,0]]</p>
<p>解释：其输出的树如下</p>
<p><img src="https://assets.leetcode.com/uploads/2020/02/12/e1tree.png"></p>
</blockquote>
<blockquote>
<p>输入：grid &#x3D; [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]</p>
<p>输出：[[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]</p>
<p>解释：其输出的树如下</p>
<p><img src="https://assets.leetcode.com/uploads/2020/02/12/e2tree.png"></p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题关键在于读懂题目，读懂题目后，就是常规的递归构造树的方式。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a QuadTree node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public boolean val;</span></span><br><span class="line"><span class="comment">    public boolean isLeaf;</span></span><br><span class="line"><span class="comment">    public Node topLeft;</span></span><br><span class="line"><span class="comment">    public Node topRight;</span></span><br><span class="line"><span class="comment">    public Node bottomLeft;</span></span><br><span class="line"><span class="comment">    public Node bottomRight;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node() &#123;</span></span><br><span class="line"><span class="comment">        this.val = false;</span></span><br><span class="line"><span class="comment">        this.isLeaf = false;</span></span><br><span class="line"><span class="comment">        this.topLeft = null;</span></span><br><span class="line"><span class="comment">        this.topRight = null;</span></span><br><span class="line"><span class="comment">        this.bottomLeft = null;</span></span><br><span class="line"><span class="comment">        this.bottomRight = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(boolean val, boolean isLeaf) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.isLeaf = isLeaf;</span></span><br><span class="line"><span class="comment">        this.topLeft = null;</span></span><br><span class="line"><span class="comment">        this.topRight = null;</span></span><br><span class="line"><span class="comment">        this.bottomLeft = null;</span></span><br><span class="line"><span class="comment">        this.bottomRight = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(boolean val, boolean isLeaf, Node topLeft, Node topRight, Node bottomLeft, Node bottomRight) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.isLeaf = isLeaf;</span></span><br><span class="line"><span class="comment">        this.topLeft = topLeft;</span></span><br><span class="line"><span class="comment">        this.topRight = topRight;</span></span><br><span class="line"><span class="comment">        this.bottomLeft = bottomLeft;</span></span><br><span class="line"><span class="comment">        this.bottomRight = bottomRight;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(grid, <span class="number">0</span>, grid.length - <span class="number">1</span>, <span class="number">0</span>, grid[<span class="number">0</span>].length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">build</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> iStart, <span class="type">int</span> iEnd, <span class="type">int</span> jStart, <span class="type">int</span> jEnd)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSame(grid, iStart, iEnd, jStart, jEnd)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(grid[iStart][jStart] == <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">topLeft</span> <span class="operator">=</span> build(grid, iStart, (iStart + iEnd) / <span class="number">2</span>, jStart, (jStart + jEnd) / <span class="number">2</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">topRight</span> <span class="operator">=</span> build(grid, iStart, (iStart + iEnd) / <span class="number">2</span>, (jStart + jEnd) / <span class="number">2</span> + <span class="number">1</span>, jEnd);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">bottomLeft</span> <span class="operator">=</span> build(grid, (iStart + iEnd) / <span class="number">2</span> + <span class="number">1</span>, iEnd, jStart, (jStart + jEnd) / <span class="number">2</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">bottomRight</span> <span class="operator">=</span> build(grid, (iStart + iEnd) / <span class="number">2</span> + <span class="number">1</span>, iEnd, (jStart + jEnd) / <span class="number">2</span> + <span class="number">1</span>, jEnd);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">false</span>, <span class="literal">false</span>, topLeft, topRight, bottomLeft, bottomRight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSame</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> iStart, <span class="type">int</span> iEnd, <span class="type">int</span> jStart, <span class="type">int</span> jEnd)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> grid[iStart][jStart];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> iStart; i &lt;= iEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> jStart; j &lt;= jEnd; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != first) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-429:N-ary Tree Level Order Traversal</title>
    <url>/leetCode/leetCode-429/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个 n 叉树，要求输出其每一层的节点。题目链接：<a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：root &#x3D; [1,null,3,2,4,null,5,6]</p>
<p>输出：[[1],[3,2,4],[5,6]]</p>
<p>解释：树的形状如下</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png"></p>
</blockquote>
<blockquote>
<p>输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</p>
<p>输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</p>
<p>解释：树的形状如下</p>
<p><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png"></p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题简单，就是单纯的广度优先搜索，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                nums.add(node.val);</span><br><span class="line">                queue.addAll(node.children);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(nums);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-43:Multiply Strings</title>
    <url>/leetCode/leetCode-43/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个字符串数字（长度小于110），要求计算两个字符串数字相乘的结果。题目链接：**<a href="https://leetcode.com/problems/multiply-strings">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：num1 &#x3D; “123”     num2 &#x3D; “456”</p>
<p>输出：”56088”</p>
</blockquote>
<blockquote>
<p>输入：num1 &#x3D; “9999999999”  num2 &#x3D; “9999999999”</p>
<p>输出：”99999999980000000001”</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>大数相乘的做法，直接模拟两个数字相乘即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] sums = <span class="keyword">new</span> <span class="title class_">int</span>[num1.length() + num2.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> num2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> (num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>) * (num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> sums[i + j + <span class="number">1</span>] + product;</span><br><span class="line">                sums[i + j + <span class="number">1</span>] = temp % <span class="number">10</span>;</span><br><span class="line">                sums[i + j] = sums[i + j] + temp / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isStart</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sums[i] == <span class="number">0</span> &amp;&amp; !isStart)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            isStart = <span class="literal">true</span>;</span><br><span class="line">            result.append(sums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (result.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-430:Flatten a Multilevel Doubly Linked List</title>
    <url>/leetCode/leetCode-430/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表，链表可能存在多层，要求将链表偏平化。题目链接：<a href="https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/description"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：head &#x3D; [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</p>
<p>输出：[1,2,3,7,8,11,12,9,10,4,5,6]</p>
<p>解释：输入的链表如下</p>
<p><img src="https://assets.leetcode.com/uploads/2021/11/09/flatten11.jpg"></p>
<p>输出的链表如下</p>
<p><img src="https://assets.leetcode.com/uploads/2021/11/09/flatten12.jpg"></p>
</blockquote>
<blockquote>
<p>输入：head &#x3D; []</p>
<p>输出：[]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用递归将子链表偏平化后再进行连接，为了避免重复遍历节点，可以在扁平化的过程中将子链表最后节点直接对接到父链表的下个节点上。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node prev;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">flatten</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        flatten(head, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(Node head, Node next)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current.next != <span class="literal">null</span> &amp;&amp; current.child == <span class="literal">null</span>) &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (current.child == <span class="literal">null</span>) &#123;</span><br><span class="line">            current.next = next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">                next.prev = current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">nextStep</span> <span class="operator">=</span> current.next;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">childNode</span> <span class="operator">=</span> current.child;</span><br><span class="line">            flatten(childNode, nextStep == <span class="literal">null</span> ? next : nextStep);</span><br><span class="line">            current.next = childNode;</span><br><span class="line">            childNode.prev = current;</span><br><span class="line">            current.child = <span class="literal">null</span>;</span><br><span class="line">            flatten(nextStep, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-435:Non-overlapping Intervals</title>
    <url>/leetCode/leetCode-435/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个表示区间集合的二维数组，要求移除某些区间，使各个区间之间没有重叠，将最小的移除区间数返回。题目链接：**<a href="https://leetcode.com/problems/non-overlapping-intervals/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[1,2],[2,3],[3,4],[1,3]]</p>
<p>输出：1</p>
<p>解释：移除区间 [1, 3]，剩下的区间 [1, 2], [2, 3], [3, 4] 不会重叠</p>
</blockquote>
<blockquote>
<p>输入：[[1,2],[2,3],[3,4]]</p>
<p>输出：0</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>先将区间进行排序，然后依次遍历，判断当前区间是否要移除，判断的条件为：</p>
<ul>
<li>如果当前区间与上一个保留的区间重叠，则判断当前区间是否包含在上个保留区间中，如果被包含，则移除上个保留区间，通过将当前区间设置为上个保留区间</li>
<li>如果当前区间没有与上个保留区间重叠，则更新当前区间为上个保留区间</li>
</ul>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] &lt; b[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= intervals[lastIndex][<span class="number">0</span>] &amp;&amp; intervals[i][<span class="number">0</span>] &lt; intervals[lastIndex][<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 考虑：[[1, 5], [2, 3], [3, 4], [4, 5]] 的情况</span></span><br><span class="line">                <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &lt;= intervals[lastIndex][<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    lastIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                lastIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-436:Find Right Interval</title>
    <url>/leetCode/leetCode-436/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二维数组，表示区间的集合。定义区间右侧区间为：区间 <code>i</code> 的右侧区间可以记作区间 <code>j</code> ，并满足 <code>startj`` &gt;= endi</code> ，且 <code>startj</code> 最小化 。注意 <code>i</code> 可能等于 <code>j</code> 。 题目链接：<a href="https://leetcode.cn/problems/find-right-interval"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：intervals &#x3D; [[3,4],[2,3],[1,2]]</p>
<p>输出：[-1,0,1]</p>
<p>解释：对于 [3,4] ，没有满足条件的“右侧”区间。<br>对于 [2,3] ，区间[3,4]具有最小的“右”起点;<br>对于 [1,2] ，区间[2,3]具有最小的“右”起点。</p>
</blockquote>
<blockquote>
<p>输入：intervals &#x3D; [[1,4],[2,3],[3,4]]</p>
<p>输出：[-1,2,-1]</p>
<p>解释：对于区间 [1,4] 和 [3,4] ，没有满足条件的“右侧”区间。<br>对于 [2,3] ，区间 [3,4] 有最小的“右”起点。</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用 <code>TreeMap</code> 保存区间左值和区间下标，然后遍历区间，每次取区间右值从 <code>TreeMap</code> 中取出大于等于区间右值的最小 <code>entry</code>，此时其 <code>value</code> 就是当前区间的右区间。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRightInterval(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            map.put(intervals[i][<span class="number">0</span>], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[intervals.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, Integer&gt; entry = map.ceilingEntry(intervals[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">                result[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[i] = entry.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-44:Wildcard Matching</title>
    <url>/leetCode/leetCode-44/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个只保护小写字母的字符串和一个只包含小写字母和 <code>?</code>、<code>*</code> 的模式匹配串，要求判断该模式匹配串是否能匹配给出的字符串。题目链接：**<a href="https://leetcode.com/problems/wildcard-matching">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：s &#x3D; “aabbccdd”  p &#x3D; “a*d”</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：s &#x3D; “acdcb” p &#x3D; “a*c?b”</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解法一：递归（超时）"><a href="#解法一：递归（超时）" class="headerlink" title="解法一：递归（超时）"></a>解法一：递归（超时）</h2><p>直接模拟匹配，暴力搜索，不过搜索过程中有大量重复计算的，导致超时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">char</span>[] s, <span class="type">char</span>[] p, <span class="type">int</span> sIndex, <span class="type">int</span> pIndex)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sIndex == s.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pIndex == p.length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> pIndex; i &lt; p.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[i] != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sIndex &gt; s.length || pIndex &gt;= p.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Character.isLowerCase(p[pIndex]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[sIndex] != p[pIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> isMatch(s, p, sIndex + <span class="number">1</span>, pIndex + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p[pIndex] == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s, p, sIndex + <span class="number">1</span>, pIndex + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// p[pIndex] == &#x27;*&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> (pIndex &lt; p.length &amp;&amp; p[pIndex] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pIndex == p.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sIndex; i &lt; s.length; i++)</span><br><span class="line">        &#123;     </span><br><span class="line">            <span class="keyword">if</span> (isMatch(s, p, i, pIndex))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> isMatch(s.toCharArray(), p.toCharArray(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h2><p>由于递归存在大量重复计算超时了，所以考虑用动态规划实现。用 <code>dp[i][j]</code> 表示 <code>s</code> 串的前 <code>i</code> 个字符和 <code>p</code> 串的前 <code>j</code> 个字符是否匹配，匹配保存 <code>true</code>，不匹配保存 <code>false</code>。此时，<code>dp[i][j]</code> 可以从<code>dp[i - 1][j]</code>、<code>dp[i][j - 1]</code>、<code>dp[i - 1][j - 1]</code> 三个地方演变而来。如果从 <code>dp[i - 1][j]</code> 演变而来，则 <code>p</code> 串当前字符是 <code>*</code>，如果从 <code>dp[i][j - 1]</code> 演变而来，则 <code>p</code> 串当前字符是 <code>*</code>（ 也可以是 <code>p</code> 的前一个字符是 <code>*</code> 当前字符是任意字符，不过这种情况可以归到 <code>dp[i - 1][j - 1]</code> 演变而来的情况，此处就不做复杂化），如果是从 <code>dp[i - 1][j - 1]</code> 演变而来，则 <code>p</code> 的当前字符串是 <code>?</code> 或 <code>*</code>  或与 <code>s</code> 的当前字符相等。</p>
<p>动态规划方程为：<code>dp[i][j] = (((dp[i - 1][j] == true || dp[i][j - 1] == true) &amp;&amp; p[j - 1] == &#39;*&#39;) || (dp[i - 1][j - 1] == true &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &#39;?&#39; || p[j - 1] == &#39;*&#39;)))</code></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sLength</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pLength</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[sLength + <span class="number">1</span>][pLength + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= pLength; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[<span class="number">0</span>][j - <span class="number">1</span>] &amp;&amp; p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= sLength; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= pLength; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">pChar</span> <span class="operator">=</span> p.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> ((dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j]) &amp;&amp; pChar == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (pChar == <span class="string">&#x27;*&#x27;</span> || pChar == <span class="string">&#x27;?&#x27;</span> || pChar == s.charAt(i - <span class="number">1</span>)))</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[sLength][pLength];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法三：双指针"><a href="#解法三：双指针" class="headerlink" title="解法三：双指针"></a>解法三：双指针</h2><p>此解法参考 <a href="https://www.iteye.com/blog/shmilyaw-hotmail-com-2154716">https://www.iteye.com/blog/shmilyaw-hotmail-com-2154716</a> 。主要是用两个指针分别指向两个字符串。遍历 <code>s</code> 字符串，遍历过程中与 <code>p</code> 字符串进行比较，如果遇到相同的字符串或者 <code>?</code> ，则分别将指针向后移动一位，如果遇到 <code>*</code>，则记录当前 <code>*</code> 的位置和当前匹配到 <code>s</code> 的位置（方便后续匹配失败可以从当前位置下一个位置继续开始匹配查找），继续向后匹配。如果发生不匹配的情况，则看之前是否存在 <code>*</code> ，如果存在，则从上一个记录的位置的下一个位置开始重新匹配，否则匹配失败。</p>
<p>代码如下 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">match</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (sIndex &lt; s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pIndex &lt; p.length() &amp;&amp; (p.charAt(pIndex) == <span class="string">&#x27;?&#x27;</span> || p.charAt(pIndex) == s.charAt(sIndex)))</span><br><span class="line">            &#123;</span><br><span class="line">                sIndex++;</span><br><span class="line">                pIndex++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (pIndex &lt; p.length() &amp;&amp; p.charAt(pIndex) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                startIndex = pIndex;</span><br><span class="line">                match = sIndex;</span><br><span class="line">                pIndex = startIndex + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (startIndex != -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sIndex = match + <span class="number">1</span>;</span><br><span class="line">                match++;</span><br><span class="line">                pIndex = startIndex + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pIndex &lt; p.length() &amp;&amp; p.charAt(pIndex) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pIndex == p.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] frank-liu.leetcode: Wildcard Matching [J&#x2F;OJ].<a href="https://www.iteye.com/blog/shmilyaw-hotmail-com-2154716">https://www.iteye.com/blog/shmilyaw-hotmail-com-2154716</a> ,2014-11-12</p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-442:Find All Duplicates in an Array</title>
    <url>/leetCode/leetCode-442/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个长度为 <code>n</code> 的整数数组，数组元素的范围 <code>1 ~ n</code>，数组元素出现的次数为 1 次或 2 次，要求找出出现 2 此的元素。题目链接：**<a href="https://leetcode.com/problems/find-all-duplicates-in-an-array">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[4,3,2,7,8,2,3,1]</p>
<p>输出：[2,3]</p>
</blockquote>
<blockquote>
<p>输入：[1,1,2]</p>
<p>输出：[1]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此解法参考：<a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/solution/shu-zu-zhong-zhong-fu-de-shu-ju-by-leetc-782l%E3%80%82%E4%B8%BB%E8%A6%81%E6%98%AF%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0">https://leetcode.cn/problems/find-all-duplicates-in-an-array/solution/shu-zu-zhong-zhong-fu-de-shu-ju-by-leetc-782l。主要是判断元素</a> <code>i</code> 位置的元素是否是 <code>i + 1</code>，如果不是则将 <code>i</code> 位置与 <code>nums[i] - 1</code> 位置的元素互换，直到相等。此时有两种情况，要么 <code>i</code> 位置的元素刚好是 <code>i + 1</code>，要么 <code>i</code> 位置的元素与 <code>nums[i] - 1</code> 的位置元素是相同的（即重复）。最后变量数组，将 <code>i</code> 位置元素不等于 <code>i + 1</code> 的元素找出来组成列表，就是求解的答案。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[temp - <span class="number">1</span>];</span><br><span class="line">                nums[temp - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - <span class="number">1</span> != i) &#123;</span><br><span class="line">                result.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/solution/shu-zu-zhong-zhong-fu-de-shu-ju-by-leetc-782l/">https://leetcode.cn/problems/find-all-duplicates-in-an-array/solution/shu-zu-zhong-zhong-fu-de-shu-ju-by-leetc-782l/</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-443:String Compression</title>
    <url>/leetCode/leetCode-443/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符数组，里面包含一些重复的字符，要求将数组进行压缩（重复的字符用数字表示），比如 <code>aabbbcdd</code> 压缩成 <code>a2b3cd2</code>。题目链接：**<a href="https://leetcode.com/problems/string-compression/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[“a”,”a”,”b”,”b”,”c”,”c”,”c”]</p>
<p>输出：[“a”,”2”,”b”,”2”,”c”,”3”]</p>
</blockquote>
<blockquote>
<p>输入：[“a”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”]</p>
<p>输出：[“a”,”b”,”1”,”2”]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>按题意模拟压缩，遍历数组，对每个字符与前个字符进行判断，如果相等，则计算加一，否则获取相等字符的个数，然后将其转成对应的字符。在这里，为了避免进行字符翻转操作，先计算出数字的位数，然后从后往前放数字字符。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compress</span><span class="params">(<span class="type">char</span>[] chars)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; chars.length &amp;&amp; chars[i] == chars[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            chars[index] = chars[i - <span class="number">1</span>];</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 算出数字的位数（由多少个数字组成）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> count;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                temp /= <span class="number">10</span>;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为了避免翻转动作，从后往前放数字字符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tempIndex</span> <span class="operator">=</span> index + num - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                chars[tempIndex] = (<span class="type">char</span>) (count % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                count /= <span class="number">10</span>;</span><br><span class="line">                tempIndex--;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-45:Jump Game II</title>
    <url>/leetCode/leetCode-45/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个包含非负整数的数组，每个元素代表当前位置向右移动的最大距离，要求找出从第一个元素到最后一个元素之间最少需要经过几步跳转（题目保证数组中必然存在从第一个元素到最后一个元素的跳转路径）。题目链接：**<a href="https://leetcode.com/problems/jump-game-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[2,3,1,1,4]</p>
<p>输出：2</p>
</blockquote>
<blockquote>
<p>输入：[2,4,1,1,2,0,5,1]</p>
<p>输出：4</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="递归（Memory-Limit-Exceeded）"><a href="#递归（Memory-Limit-Exceeded）" class="headerlink" title="递归（Memory Limit Exceeded）"></a>递归（Memory Limit Exceeded）</h2><p>此题是要找出 <code>nums[0]</code> 到 <code>nums[length - 1]</code> 之间的最小跳转次数，可以转换成 <code>nums[0]</code> 到 <code>nums[k]</code> 的最小跳转次数加上 <code>nums[k]</code> 到 <code>nums[length - 1]</code> 之间的最小跳转次数 <code>step</code>，其中 k 取值范围是 <code>[0, length - 1]</code>，比较每次算出来的最小跳转次数 <code>step</code>，取其最小值就是 <code>nums[0]</code> 到 <code>nums[length - 1]</code> 之间的最小跳转次数。为了避免一些重复计算，用一个二维数组存储从起始位置到结束位置之间需要经过的最小跳转次数。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// steps 存储从起始位置到结束位置之间需要经过的最小跳转次数</span></span><br><span class="line">        <span class="comment">// steps[i][j] 表示从 i 到 j 需要经过的最小跳转次数，-1 表示不可达</span></span><br><span class="line">        <span class="type">int</span>[][] steps = <span class="keyword">new</span> <span class="title class_">int</span>[length][length];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i + j &lt; length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                steps[i][i + j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        jumpHelper(steps, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> steps[<span class="number">0</span>][length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算从 from 到 to 之间需要经过的最小跳转次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> steps 存储从起始位置到结束位置之间需要经过的最小跳转次数</span></span><br><span class="line"><span class="comment">     *        steps[i][j] 表示从 i 到 j 需要经过的最小跳转次数，-1 表示不可达</span></span><br><span class="line"><span class="comment">     *        此数组的值会在本函数中发生改变</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from 起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to 结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 从 from 到 to 之间需要经过的最小跳转次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">jumpHelper</span><span class="params">(<span class="type">int</span>[][] steps, <span class="type">int</span> from, <span class="type">int</span> to)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (from == to)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (steps[from][to] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> steps[from][to];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> from + <span class="number">1</span>; i &lt; to; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> jumpHelper(steps, from, i);</span><br><span class="line">            <span class="keyword">if</span> (left == -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> jumpHelper(steps, i, to);</span><br><span class="line">            <span class="keyword">if</span> (right == -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (step == -<span class="number">1</span> || step &gt; left + right)</span><br><span class="line">            &#123;</span><br><span class="line">                step = left + right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        steps[from][to] = step;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法虽然可以得到正确答案，但是在输入数组长度较长时，会发生 <code>Memory Limit Exceeded</code></p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>由于二维数组空间复杂度超了，所以尝试用一维数组来存储变量值。此时想到了动态规划。用 <code>steps[i]</code> 表示从第 <code>0</code> 个位置到第 <code>i</code> 个位置需要经过的最小跳转次数。然后循环变量原始数组，针对当前元素能跳转的距离，更新其能到达距离范围内的元素的最小跳转次数。最后返回 <code>step[length - 1]</code> 即是从第一个位置到最后一个位置所经过的最小跳转次数。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// steps[i] 表示从 0 到 i 位置需要经过的最小跳转次数</span></span><br><span class="line">        <span class="type">int</span>[] steps = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt;= i + nums[i] &amp;&amp; j &lt; length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (steps[j] == <span class="number">0</span> || steps[j] &gt; steps[i] + <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    steps[j] = steps[i] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> steps[length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此解法虽然可以通过，但是耗时较长，用了 <code>337 ms</code></p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>此解法参考 <a href="https://leetcode.com/problems/jump-game-ii/discuss/313805/java-Solution-with-comment-1ms-37.5mb-beat-100-both">https://leetcode.com/problems/jump-game-ii/discuss/313805/java-Solution-with-comment-1ms-37.5mb-beat-100-both</a>。主要是用<strong>每次都选择下一次跳转能到达的最远距离来选择本次跳转应该到达的位置</strong>的思想，这样就能使每次跳转都利益最大化从而达到最后的利益最大化。用一个变量来计数存储跳转的次数，该变量最后的值就是从第一个位置到最后一个位置跳转所需要的最小跳转次数。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">fastest</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> fastest;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; nums.length - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">1</span>; i &lt;= end; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + nums[i] &gt; fastest)</span><br><span class="line">                &#123;</span><br><span class="line">                    fastest = i + nums[i];</span><br><span class="line">                    start = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            end = fastest;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此解法性能比动态规划要好，耗时只有 <code>1 ms</code></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.com/problems/jump-game-ii/discuss/313805/java-Solution-with-comment-1ms-37.5mb-beat-100-both">https://leetcode.com/problems/jump-game-ii/discuss/313805/java-Solution-with-comment-1ms-37.5mb-beat-100-both</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-450:Delete Node in a BST</title>
    <url>/leetCode/leetCode-450/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个搜索二叉树和一个数值，要求将树中该数值所在的节点删除。题目链接：<a href="https://leetcode.com/problems/delete-node-in-a-bst"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3</p>
<p>输出：[5,4,6,2,null,null,7]</p>
<p>解释：树的形状如下</p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="删除节点树图"></p>
<p>注：删除后的树形状也可以是以下的结果，两种结果返回任何一种都可以</p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg"></p>
</blockquote>
<blockquote>
<p>输入：root &#x3D; [3], key &#x3D; 3</p>
<p>输出：[]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>按照搜索二叉树特性，先找到要删除的节点，然后将该节点的左子树的最右节点替换到要删除的节点即可。大体思路比较直观，只是在求解过程中需要考虑多种情况，如果节点是否为空。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.MAX_VALUE, root, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">targetNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLeft</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.val &gt; key) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current.left != <span class="literal">null</span> &amp;&amp; current.left.val == key) &#123;</span><br><span class="line">                    isLeft = <span class="literal">true</span>;</span><br><span class="line">                    targetNode = current.left;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.val &lt; key) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current.right != <span class="literal">null</span> &amp;&amp; current.right.val == key) &#123;</span><br><span class="line">                    isLeft = <span class="literal">false</span>;</span><br><span class="line">                    targetNode = current.right;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                current = current.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key 不存在树中，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (targetNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dummy.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (targetNode.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeft) &#123;</span><br><span class="line">                current.left = targetNode.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current.right = targetNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeft) &#123;</span><br><span class="line">                current.left = targetNode.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current.right = targetNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> targetNode.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">parent</span> <span class="operator">=</span> targetNode;</span><br><span class="line">            <span class="keyword">while</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                parent = temp;</span><br><span class="line">                temp = temp.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左节点不存在右节点的情况</span></span><br><span class="line">            <span class="keyword">if</span> (parent != targetNode) &#123;</span><br><span class="line">                parent.right = temp.left;</span><br><span class="line">                temp.left = targetNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            temp.right = targetNode.right;</span><br><span class="line">            <span class="keyword">if</span> (isLeft) &#123;</span><br><span class="line">                current.left = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current.right = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-451:Sort Characters By Frequency</title>
    <url>/leetCode/leetCode-451/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串，要求对字符串中的字符按出现次数大小进行排序。题目链接：<a href="https://leetcode.com/problems/sort-characters-by-frequency"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：s &#x3D; “tree”</p>
<p>输出：”eert”  或 “eetr”</p>
</blockquote>
<blockquote>
<p>输入：s &#x3D; “Aabb”</p>
<p>输出：”bbaA” 或 “bbAa”</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>先统计每个字符出现的次数，然后对字符按次数进行排序，最后输出排序后的字符（按数量输出）。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">frequencySort</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">            <span class="type">int</span> count;</span><br><span class="line">            <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">            Node(<span class="type">char</span> ch) &#123;</span><br><span class="line">                <span class="built_in">this</span>.ch = ch;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node[] nodes = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">62</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">62</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">26</span>) &#123;</span><br><span class="line">                nodes[i] = <span class="keyword">new</span> <span class="title class_">Node</span>((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">52</span>) &#123;</span><br><span class="line">                nodes[i] = <span class="keyword">new</span> <span class="title class_">Node</span>((<span class="type">char</span>) (<span class="string">&#x27;A&#x27;</span> + i - <span class="number">26</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nodes[i] = <span class="keyword">new</span> <span class="title class_">Node</span>((<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + i - <span class="number">52</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s.toCharArray()) &#123;</span><br><span class="line">            <span class="type">int</span> index;</span><br><span class="line">            <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                index = ch - <span class="string">&#x27;A&#x27;</span> + <span class="number">26</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index = ch - <span class="string">&#x27;0&#x27;</span> + <span class="number">52</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nodes[index].increase();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nodes, (x, y) -&gt; y.count - x.count);</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; node.count; i++) &#123;</span><br><span class="line">                sb.append(node.ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-452:Minimum Number of Arrows to Burst Balloons</title>
    <url>/leetCode/leetCode-452/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个区间列表，每个区间表示气球直径的水平起点和终点，气球垂直分布在空间中，假设在某个位置垂直向上发射一支箭，如果箭经过气球所在水平坐标区间，则气球会被戳破。要求找出将所有气球戳破时需要最少的箭的数量。题目链接：**<a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[10,16], [2,8], [1,6], [7,12]]</p>
<p>输出：2</p>
<p>解释：在 2 的位置发射一支箭，可以戳破水平区间 [2, 8]、[1, 6] 的气球，在 10 的位置发射另一支箭，可以戳破 [10, 16]、[7, 12] 的气球</p>
</blockquote>
<blockquote>
<p>输入：[[1, 2], [2, 3], [3, 4], [4, 5]]</p>
<p>输出：2</p>
<p>解释：在 2 和 4 的位置发射箭</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>将区间进行排序，然后遍历区间，取区间的交集。如果当前区间与上个交集的区间不存在交集的话，则说明需要另外发射一支箭，重新计算新的交集区间了。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (points == <span class="literal">null</span> || points.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(points, Comparator.comparingInt(point -&gt; point[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">prevEnd</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; points.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &lt; prevEnd)</span><br><span class="line">            &#123;</span><br><span class="line">                prevEnd = Math.min(prevEnd, points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; prevEnd)</span><br><span class="line">            &#123;</span><br><span class="line">                prevEnd = points[i][<span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-454:4Sum II</title>
    <url>/leetCode/leetCode-454/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定四个相同长度的整形数组，要求找出从每个数组中挑出一个数字，使得这四个数字的和为 0 的组合个数。题目链接：**<a href="https://leetcode.com/problems/4sum-ii">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：A &#x3D; [1, 2]， B &#x3D; [-2, -1]，C &#x3D; [-1, 2]，D &#x3D; [0, 2]</p>
<p>输出：2</p>
</blockquote>
<blockquote>
<p>输入：A &#x3D; [1], B &#x3D; [1], C &#x3D; [1], D &#x3D; [1]</p>
<p>输出：0</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题最直接简单的想法就是用四层 for 循环，但是这样会超时。另一种可取的方法就是：使用 map 存储其中两个元素的和及其出现的次数，再把另外两个元素相加，将得到的结果取相反数后与 map 中的数字进行比较，如果存在该数字，则将 map 中该数字出现的次数加到最终结果中。这样就只需要两次两层 for 循环，时间复杂度由 <code>O(n^4)</code> 降为 <code>O(n^2)</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span>[] B, <span class="type">int</span>[] C, <span class="type">int</span>[] D)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> A.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> A[i] + B[j];</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">                map.put(sum, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temSum</span> <span class="operator">=</span> C[i] + D[j];</span><br><span class="line">                total = total + map.getOrDefault(-temSum, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-47:Permutations II</title>
    <url>/leetCode/leetCode-47/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出一个整形数组，包含重复的数字，要求输出该数组数字的全排列，不能有全部相同的项出现。题目链接：**<a href="https://leetcode.com/problems/permutations-ii/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[2,2,1,1]</p>
<p>输出：[[2,2,1,1],[2,1,2,1],[2,1,1,2],[1,2,2,1],[1,2,1,2],[1,1,2,2]]</p>
</blockquote>
<blockquote>
<p>输入：[1,2,1]</p>
<p>输出：[[1,2,1],[1,1,2],[2,1,1]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="暴力查找"><a href="#暴力查找" class="headerlink" title="暴力查找"></a>暴力查找</h2><p>此题跟查找非重复数字的全排列类似，如果使用暴力查找的方式，可以先按照非重复数字的全排列的方式找出所有的组合，在找到每个组合后，判断是否已经有重复的存在，存在则不添加到列表中，否则添加到列表中。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">getList</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; result, <span class="type">int</span> startIndex, HashSet&lt;String&gt; set)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex == nums.length - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(Arrays.toString(nums)))</span><br><span class="line">            &#123;</span><br><span class="line">                set.add(Arrays.toString(nums));</span><br><span class="line">                result.add(getList(nums));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        permuteUnique(nums, result, startIndex + <span class="number">1</span>, set);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex + <span class="number">1</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums, startIndex, i);</span><br><span class="line">            permuteUnique(nums, result, startIndex + <span class="number">1</span>, set);</span><br><span class="line">            swap(nums, startIndex, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        permuteUnique(nums, result, <span class="number">0</span>, set);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剪枝查找"><a href="#剪枝查找" class="headerlink" title="剪枝查找"></a>剪枝查找</h2><p>暴力查找虽然能解法问题，但是效率太低了。问题在于对于重复数字，在第一次跟 i 元素交换后，其产生了一系列的组合，但是在后续遇到重复数字时，其仍会跟 i 进行交换，导致产生了一系列的重复组合。例如：对于[2,1,1]，在第一位数字2和第二位数字1交换后产生[1,2,1]，然后递归产生[1,1,2]，回溯后变回原先的组合[2,1,1]，此时如果将第一位数字2和第三为数字1交换，则会产生重复的组合[1,1,2]。因此在每次交换前先判断要交换的数字是否相同或之前已经交换过，如果交换的两个数字相同或者要交换的数字之前已经交换过，则不进行交换（因为这样会产生重复的组合），否则进行交换然后递归回溯。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">getList</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; result, <span class="type">int</span> startIndex)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex == nums.length - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(getList(nums));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        permuteUnique(nums, result, startIndex + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 存放交换过的数字，避免重复交换产生重复的结果</span></span><br><span class="line">        <span class="comment">// 只能放在每层函数调用里面，不能作为全局变量，否则影响外层函数的交换，导致最终少数据</span></span><br><span class="line">        Set&lt;Integer&gt; usedNums = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex + <span class="number">1</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果要交换的数字与当前数字相同，则不交换</span></span><br><span class="line">            <span class="comment">// 如果要交换的数字之前已经被交换过了，则不交换</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[startIndex] &amp;&amp; !usedNums.contains(nums[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums, startIndex, i);</span><br><span class="line">                permuteUnique(nums, result, startIndex + <span class="number">1</span>);</span><br><span class="line">                swap(nums, startIndex, i);</span><br><span class="line">                </span><br><span class="line">                usedNums.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        permuteUnique(nums, result, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-48:Rotate Image</title>
    <url>/leetCode/leetCode-48/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个矩阵，要求在不额外新增矩阵空间的情况下在原矩阵上将矩阵顺时针旋转 90 度。题目链接：**<a href="https://leetcode.com/problems/rotate-image/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>]</p>
<p>输出：<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p>
</blockquote>
<blockquote>
<p>输入：<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>]</p>
<p>输出：<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题要求在原有矩阵上进行变换，即不能新 new 一个矩阵然后将数字进行填充。因此，可以先将矩阵进行转置，然后再将矩阵向左翻转（以列为单位，首尾互换）。例如，对于以下的矩阵</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>求转置后矩阵如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,4,7],</span><br><span class="line">  [2,5,8],</span><br><span class="line">  [3,6,9]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>再向左翻转后，得到的矩阵如下，此时的矩阵就是最开始的矩阵顺时针旋转 90 度的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix[<span class="number">0</span>] == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix.length != matrix[<span class="number">0</span>].length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="comment">// 矩阵转置（行列变换）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向左翻转矩阵（以列为单位，首尾互换）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[i][n - j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-49:Group Anagrams</title>
    <url>/leetCode/leetCode-49/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串数组，要求将其进行分组，分组规则：同一个字符串所组成的字母相同则分为一组。题目链接：**<a href="https://leetcode.com/problems/group-anagrams/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]</p>
<p>输出：</p>
<p>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>首先用一个 map 来存储各个组别，其中 key 是组中的某个元素的字符排序得到的字符串，value 是组中的所有元素。然后遍历字符串数组，对每个字符串进行排序，将得到的结果放入 map 中对应的位置。最后将 map 中的所有 value 值取出构造成一个 list 对象返回。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span>[] chars = strs[i].toCharArray();</span><br><span class="line">            Arrays.sort(chars);</span><br><span class="line">            <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> String.valueOf(chars);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(newStr))</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;String&gt; anagrams = map.get(newStr);</span><br><span class="line">                anagrams.add(strs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;String&gt; anagrams = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">                anagrams.add(strs[i]);</span><br><span class="line">                map.put(newStr, anagrams);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(map.values()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-5:Longest Palindromic Substring</title>
    <url>/leetCode/leetCode-5/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串，要求找出这个字符串中最长回文子字符串，如果有多个相同最大长度的回文子字符串，输出其中一个即可。题目链接：**<a href="https://leetcode.com/problems/longest-palindromic-substring/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：”babad”</p>
<p>输出：”bab”    或者     “aba”</p>
</blockquote>
<blockquote>
<p>输入：”cbbd”</p>
<p>输出：”bb”</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此问题最简单的方式就是用暴力方法，即用两个 for 循环找出所有的子字符串，然后对每个字符串进行是否是回文字符串的判断。但是这样复杂度太高了，有 <code>O(n^3)</code>。因此需要采用其他的方法。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>用 <code>dp[i][j]</code> 表示由字符串的 <code>[i, j]</code> 位置构成的子字符的回文子字符串的长度。则可以得出以下的动态方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果 dp[i + 1][j - 1] != 0，即 dp[i + 1][j - 1] 是一个回文字符串，并且 s[i] == s[j]</span><br><span class="line">则   dp[i][j] = dp[i + 1][j - 1] + 2;</span><br><span class="line">否则 dp[i][j] = 0</span><br></pre></td></tr></table></figure>

<p>据此，可以写出如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// dp[i][j] 表示字符串的 [i, j] 范围组成的子字符串的回文字符串长度</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[length][length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> length - <span class="number">1</span>; j &gt;= i; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 用 dp[i + 1][j - 1] != 0 来判断当前字符串去除首尾两个字符所组成的字符串是回文串</span></span><br><span class="line">                <span class="comment">// 由于当 i 和 j 相邻时， dp[i + 1][j - 1] == 0；所以需要将 i + 1 == j 单独拿出来作为一个判断条件</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (i + <span class="number">1</span> == j || dp[i + <span class="number">1</span>][j - <span class="number">1</span>] != <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; maxLength)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxLength = dp[i][j];</span><br><span class="line">                    startIndex = i;</span><br><span class="line">                    endIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substring(startIndex, endIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中心点扩展法"><a href="#中心点扩展法" class="headerlink" title="中心点扩展法"></a>中心点扩展法</h2><p>动态规划需要<code>O(n^2)</code>的空间，为了降低空间复杂度，可以参照将字符由中心位置向两侧依次递增构造回文字符串的做法进行求解。此方法主要是用一层循环遍历字符串每个字符，然后以这个字符为中心（或以这个字符和这个字符的下个字符为中心。主要是考虑奇偶数的情况），依次想两侧递增相同的字符，从而构成回文字符串。</p>
<p>此解法主要参考：<a href="https://leetcode.com/articles/longest-palindromic-substring/">https://leetcode.com/articles/longest-palindromic-substring/</a></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> getMaxLengthOfPalindromicString(s, i, i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> getMaxLengthOfPalindromicString(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; maxLength)</span><br><span class="line">            &#123;</span><br><span class="line">                maxLength = len;</span><br><span class="line">                startIndex = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                endIndex = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substring(startIndex, endIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxLengthOfPalindromicString</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; length &amp;&amp; s.charAt(left) == s.charAt(right))</span><br><span class="line">        &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h2><p>此算法可以用<code>O(n)</code>的时间复杂度求解最长回文子字符串，解法主要参考：<a href="https://articles.leetcode.com/longest-palindromic-substring-part-ii/">https://articles.leetcode.com/longest-palindromic-substring-part-ii/</a></p>
<p>其主要过程如下：</p>
<ul>
<li>先将字符串进行转换，在每个字符的左右位置插入标记字符 <code>#</code>，如：<code>abbc</code> 变为 <code>#a#b#b#c#</code>，这样做法主要是规避奇偶数的问题</li>
<li>用一个数组表示以新字符串中的每个字符为中心，向两边扩展，构成最大的回文字符串的过程中需要扩展的长度。例如：<code>#a#b#b#c#</code> 字符串对应的数组中各元素的值为 <code>0, 1, 0, 1, 2, 1, 0, 0, 0</code>。假设 <code>centerPos</code> 表示字符串中某个回文子字符串的中心位置，<code>rightPos</code> 表示上述回文字符串的右边边界，<code>i</code> 表示当前循环中指向字符位置，<code>minorI</code> 表示 <code>i</code> 关于 <code>centerPos</code> 的中心对称的位置。在计算数组元素值的过程中，主要有两个判断：<ul>
<li>如果 <code>i &lt;= rightPos</code> 即 <code>i</code> 在当前回文子字符串中，且 <code>a[minorI] &lt; rightPos - i </code>，即以 <code>minorI</code> 为中心构成的回文字符串在当前的回文子字符串中，那么回文串左右对称的特点可以得出以下结论：以 <code>i</code> 为中心构成的回文字符串与以 <code>minorI</code> 为中心构成的回文字符串相同，且一定在当前的回文子字符串中。因此 <code>a[i] == a[minorI]</code></li>
<li>如果不满足上述条件，那么则需要以当前位置为中心，依次向两边扩展，找到最大的回文字符串。</li>
</ul>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getReplaceString</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;#&quot;</span>).append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">newString</span> <span class="operator">=</span> getReplaceString(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> newString.length();</span><br><span class="line">        <span class="type">int</span>[] lens = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">centerPos</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightPos</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mirrorI</span> <span class="operator">=</span> centerPos - (i - centerPos);</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= rightPos &amp;&amp; lens[mirrorI] &lt; rightPos - i)</span><br><span class="line">            &#123;</span><br><span class="line">                lens[i] = lens[mirrorI];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">tempLen</span> <span class="operator">=</span> rightPos - i;</span><br><span class="line">            <span class="keyword">if</span> (tempLen &lt; <span class="number">0</span>)  <span class="comment">// rightPos &lt; i</span></span><br><span class="line">            &#123;</span><br><span class="line">                tempLen = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i + tempLen + <span class="number">1</span> &lt; length &amp;&amp; i - tempLen - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; newString.charAt(i + tempLen + <span class="number">1</span>) == newString.charAt(i - tempLen - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                tempLen++;</span><br><span class="line">            &#125;</span><br><span class="line">            lens[i] = tempLen;</span><br><span class="line">            centerPos = i;</span><br><span class="line">            rightPos = centerPos + lens[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (lens[i] &gt; maxLength)</span><br><span class="line">            &#123;</span><br><span class="line">                maxLength = lens[i];</span><br><span class="line">                startIndex = (i - maxLength) / <span class="number">2</span>;</span><br><span class="line">                endIndex = (i + maxLength) / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(startIndex, endIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://leetcode.com/articles/longest-palindromic-substring/">https://leetcode.com/articles/longest-palindromic-substring/</a></li>
<li><a href="https://articles.leetcode.com/longest-palindromic-substring-part-ii/">https://articles.leetcode.com/longest-palindromic-substring-part-ii/</a></li>
</ol>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-51:N-Queens</title>
    <url>/leetCode/leetCode-51/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数字 <code>n</code>，要求在 <code>n * n</code> 的棋盘上摆放 <code>n</code> 个皇后，使得各个皇后间不会互相攻击。输出所有可能的结果。题目链接：**<a href="https://leetcode.com/problems/n-queens/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：1</p>
<p>输出：[[Q]]</p>
</blockquote>
<blockquote>
<p>输入：4</p>
<p>输出：[<br>[“.Q..”,  &#x2F;&#x2F; Solution 1<br>“…Q”,<br>“Q…”,<br>“..Q.”],</p>
<p>[“..Q.”,  &#x2F;&#x2F; Solution 2<br>“Q…”,<br>“…Q”,<br>“.Q..”]<br>]</p>
<p>Q 表示皇后，. 表示空白</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>N 皇后问题，用回溯算法求解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dx = &#123;-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dy = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] occupy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[][] grid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cellNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        init(n);</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        searchQueen(<span class="number">0</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">searchQueen</span><span class="params">(<span class="type">int</span> num, List&lt;List&lt;String&gt;&gt; result)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cellNum == num)</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(getGridValueAsList());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cellNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (occupy[num][i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[num][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                handleOccupy(num, i, <span class="number">1</span>);</span><br><span class="line">                searchQueen(num + <span class="number">1</span>, result);</span><br><span class="line">                grid[num][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                handleOccupy(num, i, -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">getGridValueAsList</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cellNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cellNum; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.append(grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleOccupy</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> step)</span></span><br><span class="line">    &#123;</span><br><span class="line">        occupy[row][col] += step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dx.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextX</span> <span class="operator">=</span> row + dx[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextY</span> <span class="operator">=</span> col + dy[i];</span><br><span class="line">            <span class="keyword">while</span> (isInBoundary(nextX, nextY))</span><br><span class="line">            &#123;</span><br><span class="line">                occupy[nextX][nextY] += step;</span><br><span class="line">                nextX = nextX + dx[i];</span><br><span class="line">                nextY = nextY + dy[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isInBoundary</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; cellNum &amp;&amp; col &gt;=<span class="number">0</span> &amp;&amp; col &lt; cellNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cellNum = n;</span><br><span class="line">        grid = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        occupy = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-52:N-Queens II</title>
    <url>/leetCode/leetCode-52/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数字 <code>n</code>，要求在 <code>n * n</code> 的棋盘上摆放 <code>n</code> 个皇后，使得各个皇后间不会互相攻击，输出所有可能的结果的总数。题目链接：**<a href="https://leetcode.com/problems/n-queens-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：4</p>
<p>输出：2</p>
</blockquote>
<blockquote>
<p>输入：12</p>
<p>输出： 14200 </p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题跟 <a href="https://guozhchun.github.io/leetCode/leetCode-51/">LeetCode-51</a> 题目类似，只不过是把结果集合换成了结果数量，因此可以在其基础上进行修改，将结果集变成数量。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dx = &#123;-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dy = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] occupy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[][] grid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cellNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        init(n);</span><br><span class="line">        <span class="keyword">return</span> searchQueen(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">searchQueen</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> total)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cellNum == num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> total + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cellNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (occupy[num][i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[num][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                handleOccupy(num, i, <span class="number">1</span>);</span><br><span class="line">                total = searchQueen(num + <span class="number">1</span>, total);</span><br><span class="line">                grid[num][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                handleOccupy(num, i, -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleOccupy</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> step)</span></span><br><span class="line">    &#123;</span><br><span class="line">        occupy[row][col] += step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dx.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextX</span> <span class="operator">=</span> row + dx[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextY</span> <span class="operator">=</span> col + dy[i];</span><br><span class="line">            <span class="keyword">while</span> (isInBoundary(nextX, nextY))</span><br><span class="line">            &#123;</span><br><span class="line">                occupy[nextX][nextY] += step;</span><br><span class="line">                nextX = nextX + dx[i];</span><br><span class="line">                nextY = nextY + dy[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isInBoundary</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; cellNum &amp;&amp; col &gt;=<span class="number">0</span> &amp;&amp; col &lt; cellNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cellNum = n;</span><br><span class="line">        grid = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        occupy = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="另一种解法"><a href="#另一种解法" class="headerlink" title="另一种解法"></a>另一种解法</h2><p>上面的解法是在每次放置皇后完成后，立即处理棋盘，设置棋盘上不能放置皇后的位置。另一种做法是放置皇后完成后不做处理，将判断是否能放置皇后的计算步骤延后（提前）处理。由于不用棋盘的放置结果，因此可以不用存储棋盘的信息。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> searchQueen(n, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">searchQueen</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> total, List&lt;Integer&gt; queenCols)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> queenCols.size();</span><br><span class="line">        <span class="keyword">if</span> (n == row)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> total + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (canPlace(queenCols, row, i))</span><br><span class="line">            &#123;</span><br><span class="line">                queenCols.add(i);</span><br><span class="line">                total = searchQueen(n, total, queenCols);</span><br><span class="line">                queenCols.remove(queenCols.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canPlace</span><span class="params">(List&lt;Integer&gt; queenCols, <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queenCols.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (queenCols.get(i) == col)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">dx</span> <span class="operator">=</span> Math.abs(i - row);</span><br><span class="line">            <span class="type">int</span> <span class="variable">dy</span> <span class="operator">=</span> Math.abs(queenCols.get(i) - col);</span><br><span class="line">            <span class="keyword">if</span> (dx == dy)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-53:Maximum Subarray</title>
    <url>/leetCode/leetCode-53/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，要求找出其连续子数组的最大和。题目链接：**<a href="https://leetcode.com/problems/maximum-subarray/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[-2,1,-3,4,-1,2,1,-5,4]</p>
<p>输出：6</p>
<p>解释：对应子数组为：[4,-1,2,1]</p>
</blockquote>
<blockquote>
<p>输入：[1]</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>遍历数组，取累计数和与当前结果值的最大值作为本轮更新后的结果值。同时判断当前累计数的和，如果是正数，则将当前数放入累计和里，如果是负数，说明当前数是一个比较大的负数，则将当前累计和清零，方便下一轮比较。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result = Math.max(sum + nums[i], result);</span><br><span class="line">            <span class="keyword">if</span> (sum + nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = sum + nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-54:Spiral Matrix</title>
    <url>/leetCode/leetCode-54/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数的二维数组（矩阵），要求将其数字按照螺旋式顺时针方向放入 List 列表中并返回该结果列表。题目链接：**<a href="https://leetcode.com/problems/spiral-matrix/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[1, 2, 3], [4, 5, 6]]</p>
<p>输出：[1, 2, 3, 6, 5, 4]</p>
</blockquote>
<blockquote>
<p>输入：[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]</p>
<p>输出：[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>直接按照题目要求模拟元素的走法，每次将遍历的元素放入列表中，最后返回列表即可。</p>
<p>分别用一个变量表示上、下、左、右的边界，当元素移动时，用元素的下标和这个边界值进行比较，避免将同一位置的元素重复放入结果列表中。每次移动元素到达相应的边界时（遍历完一行或者一列），更新对应的边界值。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> matrix.length * matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">topBound</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bottomBound</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBound</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBound</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(total);</span><br><span class="line">        <span class="keyword">while</span> (result.size() &lt; total)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (result.size() &lt; total &amp;&amp; j &lt; rightBound)</span><br><span class="line">            &#123;</span><br><span class="line">                result.add(matrix[i][j]);</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> == rightBound)</span><br><span class="line">                &#123;</span><br><span class="line">                    topBound++;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (result.size() &lt; total &amp;&amp; i &lt; bottomBound)</span><br><span class="line">            &#123;</span><br><span class="line">                result.add(matrix[i][j]);</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> == bottomBound)</span><br><span class="line">                &#123;</span><br><span class="line">                    rightBound--;</span><br><span class="line">                    j--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (result.size() &lt; total &amp;&amp; j &gt;= leftBound)</span><br><span class="line">            &#123;</span><br><span class="line">                result.add(matrix[i][j]);</span><br><span class="line">                <span class="keyword">if</span> (j == leftBound)</span><br><span class="line">                &#123;</span><br><span class="line">                    bottomBound--;</span><br><span class="line">                    i--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (result.size() &lt; total &amp;&amp; i &gt;= topBound)</span><br><span class="line">            &#123;</span><br><span class="line">                result.add(matrix[i][j]);</span><br><span class="line">                <span class="keyword">if</span> (i == topBound)</span><br><span class="line">                &#123;</span><br><span class="line">                    leftBound++;</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;                    </span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-547:Friend Circles</title>
    <url>/leetCode/leetCode-547/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个 n * n 的二维数组，用来表示班级成员的朋友关系。如果 <code>M[i][j]</code> 值为 1，表示第 <code>i</code> 人和第 <code>j</code> 人是朋友关系，如果值为 0，表示第 <code>i</code> 人和第 <code>j</code> 人不是朋友关系。朋友关系具有传递性，如 a 和 b 是朋友，b 和 c 是朋友，则 a 和 c 也是朋友。要求找出有班级中多少个朋友圈。题目链接：**<a href="https://leetcode.com/problems/friend-circles">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入： [[1,1,0],[1,1,1],[0,1,1]] </p>
<p>输出：1</p>
</blockquote>
<blockquote>
<p>输入： [[1,1,0],[1,1,0],[0,0,1]] </p>
<p>输出：2</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用并查集算法进行解答。假设每个人都有一个上层的朋友，如果该成员没有任何朋友，则其上层的朋友就是自己。首先，先初始化每个人的上层朋友，然后遍历二维数组，对每一对朋友关系，都分别找出这两个成员的最上层的朋友，如果值不相等，则将其合并，最后再遍历定义的上层朋友的数组，统计上层朋友是自己的成员个数，就是班级朋友圈的个数。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findRoot</span><span class="params">(<span class="type">int</span>[] friend, <span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (friend[i] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            i = friend[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] M)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> M.length;</span><br><span class="line">        <span class="type">int</span>[] friend = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            friend[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">iRoot</span> <span class="operator">=</span> findRoot(friend, i);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">jRoot</span> <span class="operator">=</span> findRoot(friend, j);</span><br><span class="line">                    <span class="keyword">if</span> (iRoot != jRoot)</span><br><span class="line">                    &#123;</span><br><span class="line">                        friend[iRoot] = jRoot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (friend[i] == i)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-55:Jump Game</title>
    <url>/leetCode/leetCode-55/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出一个非负整数的数组，每个元素代表当前位置向右移动的最大距离，要求判断给出的数组中是否能从第一个元素走到最后一个元素，如果可以，返回 true，否则返回 false。题目链接：**<a href="https://leetcode.com/problems/jump-game/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[2,3,1,1,4]</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：[3,2,1,0,4]</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题可以用一个变量来表示从第一位到数组中当前某个元素中能达到的最大距离，然后遍历数组，实时更新这个最大距离，当发现这个距离小于数组下标（即不能从第一个元素到达当前元素）时，返回 false，否则继续循环直到结束。最后判断其最大长度是否超过数组长度，如果是，返回 true，否则返回 false。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxJumpLength</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxJumpLength &lt; i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt; maxJumpLength)</span><br><span class="line">            &#123;</span><br><span class="line">                maxJumpLength = i + nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxJumpLength + <span class="number">1</span> &gt;= length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-56:Merge Intervals</title>
    <url>/leetCode/leetCode-56/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个包含多个区间的列表，要求将将重叠的区间进行合并，返回合并后的区间列表。题目链接：**<a href="https://leetcode.com/problems/merge-intervals/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[1,3],[2,6],[8,10],[15,18]]</p>
<p>输出：[[1,6],[8,10],[15,18]]</p>
<p>解释：[1,3] 这个区间，结束的位置 3 在区间 [2, 6] 之间，因此可以把 [1, 3] 和 [2, 6] 两个区间合并成一个区间 [1, 6]</p>
</blockquote>
<blockquote>
<p>输入：[[1,4],[4,5]]</p>
<p>输出：[[1,5]]</p>
<p>解释：[1,4] 这个区间，结束的位置 4 在区间 [4, 5] 开始处，因此可以把 [1, 4] 和 [4, 5] 两个区间合并成一个区间 [1, 5]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>如果将所有的区间在直线上画出来进行表示，那么进行区间合并就会很直观，也很简单。按照此思路，可以先对列表中的所有区间进行排序，区间起始数小的排在前面。然后依次遍历排序后的区间列表，对相邻的区间进行合并，合并的原则是前一个区间的结束数字在后一个区间之间（包含区间的起始位置），则更新区间的结束位置。具体实现代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;Interval&gt; intervals)</span></span><br><span class="line">    &#123;</span><br><span class="line">        intervals.sort((Interval a, Interval b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.start &lt; b.start)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (a.start &gt; b.start)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> a.end - b.end;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;Interval&gt; <span class="title function_">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="literal">null</span> || intervals.size() &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sort(intervals);</span><br><span class="line">        List&lt;Interval&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Interval</span> <span class="variable">current</span> <span class="operator">=</span> intervals.get(<span class="number">0</span>);</span><br><span class="line">        result.add(current);</span><br><span class="line">        <span class="keyword">for</span> (Interval interval : intervals)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.end &lt; interval.start)</span><br><span class="line">            &#123;</span><br><span class="line">                current = interval;</span><br><span class="line">                result.add(current);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (current.end &gt; interval.end)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            current.end = interval.end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-57:Insert Interval</title>
    <url>/leetCode/leetCode-57/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二维数组，表示区间的集合。数组中已经根据区间的起始下标从小到大排序，而且各个区间没有重叠部分。另外给定一个区间，要求将这个区间合并到原先的区间集合中。题目链接：**<a href="https://leetcode.com/problems/insert-interval/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[1,3],[6,9]]          [2,5]</p>
<p>输出：[[1,5],[6,9]]</p>
</blockquote>
<blockquote>
<p>输入：[[1,2],[3,5],[6,7],[8,10],[12,16]]                 [4,8]</p>
<p>输出：[[1,2],[3,10],[12,16]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>循环遍历原有的区间集合，对每个区间做如下判断</p>
<ul>
<li>如果区间在合入的区间左侧，则保留此区间</li>
<li>如果区间与合入的区间左相交，则更新合入的区间的起始下标为当前区间的起始下标</li>
<li>如果区间包含要合入的区间，则返回原先的区间集合</li>
<li>如果区间在合入的区间内部，则跳过此区间，不做任何操作</li>
<li>如果区间与合入的区间右相交，则更新合入的区间的结束下标为当前区间的结束下标</li>
<li>如果区间在合入区间的右侧，则将合入的区间加入区间集合中，同时保留此区间及后续的区间，并结束循环</li>
</ul>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;newInterval&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (newInterval.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] tempIntervals = <span class="keyword">new</span> <span class="title class_">int</span>[length + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span>[] interval = intervals[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// the interval before the newInterval</span></span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tempIntervals[index] = interval;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &lt;= newInterval[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// interval outer newInterval</span></span><br><span class="line">                <span class="keyword">if</span> (interval[<span class="number">1</span>] &gt;= newInterval[<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> intervals;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// interval left cross newInterval</span></span><br><span class="line">                newInterval[<span class="number">0</span>] = interval[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// interval inner newInterval</span></span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; newInterval[<span class="number">0</span>] &amp;&amp; interval[<span class="number">1</span>] &lt;= newInterval[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                newInterval[<span class="number">1</span>] = interval[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            tempIntervals[index] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;newInterval[<span class="number">0</span>], newInterval[<span class="number">1</span>]&#125;;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == length)</span><br><span class="line">        &#123;</span><br><span class="line">            tempIntervals[index] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;newInterval[<span class="number">0</span>], newInterval[<span class="number">1</span>]&#125;;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] result = <span class="keyword">new</span> <span class="title class_">int</span>[length - i + index][<span class="number">2</span>];</span><br><span class="line">        System.arraycopy(tempIntervals, <span class="number">0</span>, result, <span class="number">0</span>, index);</span><br><span class="line">        System.arraycopy(intervals, i, result, index, length - i);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-58:Length of Last Word</title>
    <url>/leetCode/leetCode-58/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个由空格和字母组成的字符串，要求找出最后一个单词的长度。题目链接：**<a href="https://leetcode.com/problems/length-of-last-word/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：”Hello World”</p>
<p>输出：5</p>
</blockquote>
<blockquote>
<p>输入：”   fly me   to   the moon  “</p>
<p>输出：4</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，直接拆分单词计算长度即可。代如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        String[] words = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> words.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (words[i].length() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> words[i].length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-59:Spiral Matrix II</title>
    <url>/leetCode/leetCode-59/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个正整数 n，要求将数字 1 到 n<em>n 按顺时针方向螺旋排列成 n * n 的矩阵。题目链接：</em><em><a href="https://leetcode.com/problems/spiral-matrix-ii/">点我</a></em>*</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：3</p>
<p>输出：[[1,2,3],[8,9,4],[7,6,5]]</p>
</blockquote>
<blockquote>
<p>输入：4</p>
<p>输出：[[1,2,3,4],[12,13,14,5],[11,16,15,6],[10,9,8,7]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题跟 <a href="https://leetcode.com/problems/spiral-matrix">leetCode-54</a> 有点类似，直接模拟规则填充数组即可。</p>
<p>为了简化代码，此处分别用 <code>rowSteps</code> 和 <code>colSteps</code> 表示由当前位置移动到下一个位置的行下标和列下标应该变化的值的列表，两个数组中的元素一一对应，由 <code>nextStepIndex</code> 控制应该取数组中的哪个元素。比如 <code>rowSteps[0] = 0</code>、<code>colSteps[0] = 1</code> 表示由当前位置移动到下一个位置，是行坐标保持不变，列坐标加<code>1</code>，再比如 <code>rowSteps[2] = -1</code>、<code>colSteps[2] = 0</code> ，表示由当前位置移动到下一个位置，是行坐标减 <code>1</code>，列坐标保持不变。通过这种方式，可以避免用四个循环来模拟「从左到右」、「从上到下」、「从右到左」、「从下到上」这一个圈，从而减少代码。</p>
<p>至于判断是否要改变方向（即 <code>nextStepIndex</code> 的值是否要变动），则根据行列的下标是否达到数组的边界以及是否会覆盖之前填充的数字来判断。如果达到数组的边界或者会覆盖之前填充的数字，则需要改变方向（ <code>nextStepIndex</code> 的值加一）。由于数组初始化后所有元素的值都是 0，并且填充的数字永远大于 0，所以可以根据数组的元素值是否为 0 判断该位置是否已经被填充过。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断是否需要改变方向获取下一个元素，比如由“从左到右”变成“从上到下”</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">needChangeDirection</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> nextRowIndex, <span class="type">int</span> nextColIndex)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 下标越界，需要改变方向</span></span><br><span class="line">        <span class="keyword">if</span> (nextRowIndex &lt; <span class="number">0</span> || nextRowIndex &gt;= matrix.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下标越界，需要改变方向</span></span><br><span class="line">        <span class="keyword">if</span> (nextColIndex &lt; <span class="number">0</span> || nextColIndex &gt;= matrix.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下一个元素已经被填充过，需要改变当前指针移动方向</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[nextRowIndex][nextColIndex] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalNum</span> <span class="operator">=</span> n * n;</span><br><span class="line">        <span class="comment">// 由当前元素移动到下一个元素需要的列下标的移动距离，与 rowSteps 的元素一一对应</span></span><br><span class="line">        <span class="type">int</span>[] colSteps = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;; </span><br><span class="line">        <span class="comment">// 由当前元素移动到下一个元素需要的行下标的移动距离，与 colSteps 的元素一一对应</span></span><br><span class="line">        <span class="type">int</span>[] rowSteps = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;; </span><br><span class="line">        <span class="type">int</span> <span class="variable">currentRowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentColIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextStepIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= totalNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix[currentRowIndex][currentColIndex] = i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempNextRowIndex</span> <span class="operator">=</span> currentRowIndex + rowSteps[nextStepIndex];</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempNextColIndex</span> <span class="operator">=</span> currentColIndex + colSteps[nextStepIndex];</span><br><span class="line">            <span class="keyword">if</span> (needChangeDirection(matrix, tempNextRowIndex, tempNextColIndex))</span><br><span class="line">            &#123;</span><br><span class="line">                nextStepIndex = (nextStepIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                tempNextRowIndex = currentRowIndex + rowSteps[nextStepIndex];</span><br><span class="line">                tempNextColIndex = currentColIndex + colSteps[nextStepIndex];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            currentRowIndex = tempNextRowIndex;</span><br><span class="line">            currentColIndex = tempNextColIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-6:ZigZag Conversion</title>
    <url>/leetCode/leetCode-6/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串和数字 n ，要求将字符串按照 n 竖行 “Z”  字行分布后，将分布后的字符按照从上到下，从左到右的顺序构成的新字符串输出。题目链接：**<a href="https://leetcode.com/problems/zigzag-conversion/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：PAYPALISHIRING      3<br>输出：PAHNAPLSIIGYIR<br>解释： 3 竖行 Z 字形排序后的图形如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>输入：PAYPALISHIRING    4<br>输出：PINALSIGYAHRPI<br>解释：4 竖行 Z 字形排序后的图形如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题就是模拟题，要找题目要求模拟输出即可。最直观的做法就是定义二维数组，然后按照 Z 形走法将原字符串填充到数组中，然后再遍历输出进行输出。但是这样稍微麻烦了点，所以寻找另一种做法：通过观察转换后的图形，可以得出以下规律：假设行数为 n</p>
<ul>
<li>对于第一行，每两个字符之间的间隔是 2 * (n - 1)</li>
<li>对于第二行，令 k 为奇数，则 k + 1 为其相邻的偶数，则第 k 个字符与第 k + 1 个字符之间的间隔是 2 * (n - 2)，第 k + 1 个字符和第 k + 2 个字符之间的间隔是 2 * 1</li>
<li>对于第三行，令 k 为奇数，则 k + 1 为其相邻的偶数，则第 k 个字符与第 k + 1 个字符之间的间隔是 2 * (n - 3)，第 k + 1 个字符和第 k + 2 个字符之间的间隔是 2 * 2</li>
<li>…….</li>
<li>对于最后一行，每两个字符之间的间隔是 2 * (n - 1)</li>
</ul>
<p>根据以上规律，可以写出代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span> || length &lt;= numRows || numRows &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i + <span class="number">2</span> * (numRows - i - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 最后一行，计算下一个字符，否则进入循环后会重复添加</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == numRows)</span><br><span class="line">            &#123;</span><br><span class="line">                index = i + <span class="number">2</span> * i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (index &lt; length)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.append(s.charAt(index));</span><br><span class="line">                <span class="comment">// 首行和尾行每次循环只有一个重复的字符，单独处理</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || i + <span class="number">1</span> == numRows)</span><br><span class="line">                &#123;</span><br><span class="line">                    index = index + <span class="number">2</span> * (numRows - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 除去首尾两行的其他中间行，每个循环，两个字符为一组</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> index + <span class="number">2</span> * i;</span><br><span class="line">                <span class="keyword">if</span> (nextIndex &lt; length)</span><br><span class="line">                &#123;</span><br><span class="line">                    sb.append(s.charAt(nextIndex));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                index = nextIndex + <span class="number">2</span> * (numRows - i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-60:Permutation Sequence</title>
    <url>/leetCode/leetCode-60/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个数字n和k，要求找出[1,2,3,…,n]的全排列的组合中的的第k个组合，题目链接：**<a href="https://leetcode.com/problems/permutation-sequence/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：3 2</p>
<p>输出：”132”</p>
<p>解释：3的全排列如下</p>
<ol>
<li>123</li>
<li>132</li>
<li>213</li>
<li>231</li>
<li>312</li>
<li>321</li>
</ol>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题最简单粗暴的做法从第一个开始找全排列的组合，直到找到第k个全排列组合结束。但是如果k很大时，很容易超时。所以应该换一种方式思考。</p>
<p>从给出的样例中可以看出，对n的全排列组合，是先将1放在第1位，然后将剩下的数字（除了1之外的数字）做全排列，然后将2放在第1位，将剩下的数字（除了2之外的数字）做全排列，再将3放在第1位，将剩下的数字（除了3之外的数字）做全排列…最后将n放在第1位，将剩下的数字（除了n之外的数字）做全排列。</p>
<p>因此，我们可以将第一位数字单独拿出来，将剩下的数字的全排列组合的数量计算出来，然后与k进行比较，看第一位的数字应该放哪个数字合适，此时确定完第一位数字后，就已经完成了m个全排列组合的查找，剩下的k - m个全排列组合在除第一位数字外的剩下的数字的全排列组合中重复上述过程查找。从中可以看出，这是一个递归过程。程序代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 0 ~ 9 的阶乘</span></span><br><span class="line">    <span class="type">int</span>[] factorialNums = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Character&gt; <span class="title function_">getNums</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Character&gt; nums = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.add(Character.valueOf((<span class="type">char</span>)(i + <span class="string">&#x27;1&#x27;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findPermutation</span><span class="params">(List&lt;Character&gt; remainNums, <span class="type">int</span> k, List&lt;Character&gt; result)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.addAll(remainNums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">remainNumsSize</span> <span class="operator">=</span> remainNums.size();</span><br><span class="line">        <span class="comment">// k - 1是为了避免 k % factorialNums[remainNumsSize - 1] == 0的情况</span></span><br><span class="line">        <span class="comment">// 此种情况表示剩下的remainNumsSize - 1的数的所有全排列组合中的最后一个组合</span></span><br><span class="line">        <span class="comment">// 此时，不需要更换现在的第一个数字的值</span></span><br><span class="line">        <span class="comment">// 例如remianNums = [1,2,3],k = 4,此时factorialNums[remainNumsSize - 1] = 2</span></span><br><span class="line">        <span class="comment">// 1作为首位的全排列组合数是2，2作为首位的全排列组合数是2，此时k = 4刚好落在2作为首位时，</span></span><br><span class="line">        <span class="comment">// 剩下的数字[1,3]全排列组合的最后一个组合[3,1]，此时并不需要更换首位的数字2变成3</span></span><br><span class="line">        <span class="comment">// 也就是说，更换的次数只有1次（由1变成2）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fistNumChangetimes</span> <span class="operator">=</span> (k - <span class="number">1</span>) / factorialNums[remainNumsSize - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainK</span> <span class="operator">=</span> k - fistNumChangetimes * factorialNums[remainNumsSize - <span class="number">1</span>];</span><br><span class="line">        result.add(remainNums.get(fistNumChangetimes));</span><br><span class="line">        remainNums.remove(fistNumChangetimes);</span><br><span class="line">        </span><br><span class="line">        findPermutation(remainNums, remainK, result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getResultString</span><span class="params">(List&lt;Character&gt; characters)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (Character ch : characters)</span><br><span class="line">        &#123;</span><br><span class="line">            result.append(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Character&gt; nums = getNums(n);</span><br><span class="line">        List&lt;Character&gt; resultList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        findPermutation(nums, k, resultList);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> getResultString(resultList);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-61:Rotate List</title>
    <url>/leetCode/leetCode-61/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表和一个数字 k，要求将链表旋转 k 次（从最右端向最左端进行旋转）。题目链接：**<a href="https://leetcode.com/problems/rotate-list/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2</p>
<p>输出：4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
<p>解释：</p>
<p>第一次旋转后的结果：5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</p>
<p>第二次旋转后的结果：4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
</blockquote>
<blockquote>
<p>输入：0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4</p>
<p>输出：2-&gt;0-&gt;1-&gt;NULL</p>
<p>解释：</p>
<p>第一次旋转后的结果：2-&gt;0-&gt;1-&gt;NULL</p>
<p>第二次旋转后的结果：1-&gt;2-&gt;0-&gt;NULL</p>
<p>第三次旋转后的结果：0-&gt;1-&gt;2-&gt;NULL</p>
<p>第四次旋转后的结果：2-&gt;0-&gt;1-&gt;NULL</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>由于输入的整数 k 可能大于链表的长度，因此需要先求出链表的长度，对 k 进行取余，得出链表截断的地方，即旋转后的头指针的位置，然后根据此位置变换链表头指针和尾指针即可得到答案。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> length - k % length;</span><br><span class="line">        <span class="keyword">if</span> (step == length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pSecond</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; step; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pSecond = pSecond.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p.next = head;</span><br><span class="line">        head = pSecond.next;</span><br><span class="line">        pSecond.next = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-62:Unique Paths</title>
    <url>/leetCode/leetCode-62/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个矩阵，一个机器人在矩阵左上角，目标在矩阵右下角，机器人每次只能向右或向下走一步，要求找出机器人从左上角走到右下角共有多少种走法。题目链接：**<a href="https://leetcode.com/problems/unique-paths/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：3  7</p>
<p>输出：28</p>
</blockquote>
<blockquote>
<p>输入：51 9</p>
<p>输出：1916797311</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题是数学中的组合题，直接运用组合进行求解即可。需要注意的是求解组合的方法，不能直接使用阶乘，否则大数的阶乘会超过 int 和 long 的存储范围导致错误。</p>
<p>还有一点需要额外注意：题目中说 m 和 n 最多只有 100，但是如果 m 和 n 是 100 的话，结果是 22750883079422934966181954039568885395604168260154104734000，这远远超出 int 的存储范围，但是题目中给出的函数返回值是 int 类型，所以<strong>此处假设，输入的值计算得到的结果不会超过 int 类型的存储范围。</strong></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算组合C(n,m)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 组合的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m 组合的上标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> n!/m!(n-m)!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcCombination</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 m 值太大，利用 C(n, m) = C(n, n - m)的关系，将 m 值降下来</span></span><br><span class="line">        <span class="comment">// 既可以避免多次计算，也可以避免计算结果太大无法存储</span></span><br><span class="line">        <span class="keyword">if</span> (m * <span class="number">2</span> &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            m = n - m;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为了使计算结果能够存储，此处用 long 类型而不是 int 类型</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a *= n - i;</span><br><span class="line">            b *= i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a % b == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a = a / b;</span><br><span class="line">                b = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (a / b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 确保 C(n, m) 中，n 比 m 大</span></span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> m;</span><br><span class="line">            m = n;</span><br><span class="line">            n = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> calcCombination(m + n - <span class="number">2</span>, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-63:Unique Paths II</title>
    <url>/leetCode/leetCode-63/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个矩阵，矩阵上的元素是 0 或 1，1 表示这是一个障碍物，机器人不能通过，0 表示机器人可以通过。一个机器人在矩阵左上角，目标在矩阵右下角，机器人每次只能向右或向下走一步，要求找出机器人从左上角走到右下角共有多少种走法。题目链接：**<a href="https://leetcode.com/problems/unique-paths-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[0, 0, 0], [0, 1, 0], [0, 0, 0]]</p>
<p>输出：2</p>
</blockquote>
<blockquote>
<p>输入：[[1], [0], [0]]</p>
<p>输出：0 </p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h2><p>此题最直观的做法就是直接用深搜进行暴力搜索，虽然简单直观，但是<strong>超时</strong>了。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPathCount</span><span class="params">(<span class="type">int</span>[][] obstacleGrid, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> count)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前位置是障碍点，则不能达到终点</span></span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 到达终点</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> == obstacleGrid.length &amp;&amp; j + <span class="number">1</span> == obstacleGrid[<span class="number">0</span>].length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向下</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; obstacleGrid.length &amp;&amp; obstacleGrid[i + <span class="number">1</span>][j] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count = getPathCount(obstacleGrid, i + <span class="number">1</span>, j, count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向右</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; obstacleGrid[<span class="number">0</span>].length &amp;&amp; obstacleGrid[i][j + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count = getPathCount(obstacleGrid, i, j + <span class="number">1</span>, count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> getPathCount(obstacleGrid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>暴力搜索有很多重复的搜索过程，比如某一次搜索能达到终点，后面另一次搜索经过之前搜索过的能到达终点的路径上的某个节点时，就不必继续往下搜索了，因为这很明确是能到达终点的。而且，如果能记录某个位置达到终点的路径数量，那么后续搜索到达此位置时，就可以直接将其结果返回，不必往下继续搜索了。因此可以使用动态规划来解决。</p>
<p>使用二维数组 <code>dp[i][j]</code> 来表示位置 (i, j) 到达终点的路径数量，则动态方程为 <code>dp[i][j] = dp[i][j + 1] + dp[i + 1][j]</code>，最终结果就是 <code>dp[0][0]</code></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowCount</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">colCount</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[rowCount][colCount];</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[rowCount - <span class="number">1</span>][colCount - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[rowCount - <span class="number">1</span>][colCount - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> rowCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> colCount - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 当前位置是障碍物时，到达终点的路径是 0</span></span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; colCount &amp;&amp; obstacleGrid[i][j + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] += dp[i][j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; rowCount &amp;&amp; obstacleGrid[i + <span class="number">1</span>][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] += dp[i + <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-64:Minimum Path Sum</title>
    <url>/leetCode/leetCode-64/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个矩阵，要求找出一个从左上角到右下角的路径，使其和最小并输出该值。其中，每次只能向下或向右移动一个单位。题目链接：**<a href="https://leetcode.com/problems/minimum-path-sum/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[1,3,1],[1,5,1],[4,2,1]]</p>
<p>输出：7</p>
</blockquote>
<blockquote>
<p>输入：[[1,2,3]]</p>
<p>输出：6</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题同 <a href="https://guozhchun.github.io/2018/12/02/leetCode/leetCode-63/">LeetCode-63</a> 类似，都可以用动态规划来解决。假设用 <code>dp[i][j]</code> 来表示从左上角到 <code>[i][j]</code> 位置经过的路径中的最短路径的和，根据题意可知，其上一个位置要么在左侧要么在上方，因此只需比较这两个位置，取其最小值，加上本位置的数字就能得到最终结果。动态方程为：<code>dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]</code>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">1</span> || col == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-65:Valid Number</title>
    <url>/leetCode/leetCode-65/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串，判断这个字符串是否是数字（包括小数和指数）。题目没有明确说明什么情况下该字符串是合法的，需要靠自己猜测。大致的规则如下：</p>
<ul>
<li>只能包含 <code>0~9</code>、<code>.</code>、<code>+</code>、<code>-</code>、<code>e</code>、<code>E</code></li>
<li>首尾可以允许有空格，但是中间不允许有空格</li>
<li>只能出现一个小数点，且小数点在 e&#x2F;E 的前面</li>
<li>只能出现一个 e&#x2F;E，并且不能出现在第一位和最后一位</li>
<li>+&#x2F;- 只能出现在第一位或者 e&#x2F;E 的后一位，后面必须有数字或小数点</li>
<li>允许小数点前没有数字，也允许小数点后没有数字，但是小数点前或后这两个位置至少要有一个位置有数字</li>
</ul>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：”   0.1   “</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：”+.1”</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：”3.”</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：”.”</p>
<p>输出：false</p>
</blockquote>
<blockquote>
<p>输入：”+E3”</p>
<p>输出：false</p>
</blockquote>
<blockquote>
<p>输入：”-3.e-2”</p>
<p>输出：true</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="使用正则"><a href="#使用正则" class="headerlink" title="使用正则"></a>使用正则</h2><p>此题是要判断输入的字符串是否是一个数字，因此可以直接使用正则表达式进行全匹配。正则表达式为：<code>\\s*[-+]&#123;0,1&#125;((\\d*\\.)&#123;0,1&#125;\\d+|\\d+\\.)([eE][-+]&#123;0,1&#125;\\d+)&#123;0,1&#125;\\s*</code>。其中，前后两个 <code>\\s*</code> 是为了匹配前后的空格，<code>[-+]&#123;0,1&#125;</code> 用于匹配正负符号，<code>((\\d*\\.)&#123;0,1&#125;\\d+|\\d+\\.)</code> 用于匹配整数和小数部分，<code>([eE][-+]&#123;0,1&#125;\\d+)&#123;0,1&#125;</code> 用于匹配指数部分。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 前后两个 \\s* 是去除前后的空格</span></span><br><span class="line">        <span class="comment">// ((\\d*\\.)&#123;0,1&#125;\\d+|\\d+\\.) 匹配 3 或 3.3 或  3. 或  .3 的不带指数（e）的小数或整数</span></span><br><span class="line">        <span class="comment">// ([eE][-+]&#123;0,1&#125;\\d+)&#123;0,1&#125; 匹配指数(e)部分的数字</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\s*[-+]&#123;0,1&#125;((\\d*\\.)&#123;0,1&#125;\\d+|\\d+\\.)([eE][-+]&#123;0,1&#125;\\d+)&#123;0,1&#125;\\s*&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(s);</span><br><span class="line">        <span class="keyword">return</span> matcher.matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h2><p>使用正则表达式进行求解虽然直观简洁，但是其速度比较慢。因此可以使用遍历字符串的方式，在遍历的过程中，对每个字符进行判断，遇到不符合规则的返回 false 结束遍历。此方式可以提供效率，但是其却比较复杂啰嗦，也很容易遗漏一些情况。其代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断字符是否是 0 ~ 9 的数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isCharNumber</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.trim();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span> || (length == <span class="number">1</span> &amp;&amp; str.charAt(<span class="number">0</span>) == <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">decimalIndex</span> <span class="operator">=</span> -<span class="number">1</span>;     <span class="comment">// 小数点的位置下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">exponentialIndex</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// e/E 的位置下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (isCharNumber(ch))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 小数点只能出现一次，且必须在 e 的前面</span></span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span> &amp;&amp; decimalIndex == -<span class="number">1</span> &amp;&amp; exponentialIndex == -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 小数点前或后至少要有一个数字</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; !isCharNumber(str.charAt(i + <span class="number">1</span>)))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (i == length - <span class="number">1</span> &amp;&amp; !isCharNumber(str.charAt(i - <span class="number">1</span>)))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> ((i != <span class="number">0</span> &amp;&amp; !isCharNumber(str.charAt(i - <span class="number">1</span>))) &amp;&amp; (i != length - <span class="number">1</span> &amp;&amp; !isCharNumber(str.charAt(i + <span class="number">1</span>))))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                decimalIndex = i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 符号只能出现在第一位或 e 的后面一位，且不能是最后一位</span></span><br><span class="line">            <span class="comment">// 由于初始化 exponentialIndex = -1，因此当出现在第一位时，exponentialIndex + 1 == 0 也能成立</span></span><br><span class="line">            <span class="keyword">if</span> ((ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; exponentialIndex + <span class="number">1</span> == i &amp;&amp; i != length - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// + - 后面必须有数字或小数点</span></span><br><span class="line">                <span class="comment">// 前面已经判断了 i != length - 1，此处不用再判断</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">nextChar</span> <span class="operator">=</span> str.charAt(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!isCharNumber(nextChar) &amp;&amp; nextChar != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// e 只能出现一次，并且不能出现在第一位和最后一位</span></span><br><span class="line">            <span class="keyword">if</span> ((ch == <span class="string">&#x27;e&#x27;</span> || ch == <span class="string">&#x27;E&#x27;</span>) &amp;&amp; exponentialIndex == -<span class="number">1</span> &amp;&amp; i != <span class="number">0</span> &amp;&amp; i != length -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                exponentialIndex = i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-66:Plus One</title>
    <url>/leetCode/leetCode-66/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，用数组中的数字从小到大表示数字的从左到有，要求求出大数加一后的结果。题目链接：**<a href="https://leetcode.com/problems/plus-one/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3]</p>
<p>输出：[1,2,4]</p>
</blockquote>
<blockquote>
<p>输入：[9,9,9]</p>
<p>输出：[1,0,0,0]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，直接模拟数字相加即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] plusOne(<span class="type">int</span>[] digits)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[digits.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[i] = (digits[i] + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (digits[i] + carry) / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[temp.length + <span class="number">1</span>];</span><br><span class="line">        result[<span class="number">0</span>] = carry;</span><br><span class="line">        System.arraycopy(temp, <span class="number">0</span>, result, <span class="number">1</span>, temp.length);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-684:Redundant Connection</title>
    <url>/leetCode/leetCode-684/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二维数组表示边的集合，每条边表示从某个低数字的节点到高数字的节点的连线，这些边连接后构成一个无向连通图，其中存在一条边，使得这个无向连通图存在一个环，要求将这条边找出并剔除，使得剩下的图不存在环结构，同时仍然保持是一个无向的连通图。如果存在多条边，则返回最后出现的那条边。题目链接：**<a href="https://leetcode.com/problems/redundant-connection/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[1,2], [1,3], [2,3]]</p>
<p>输出：[2,3]</p>
</blockquote>
<blockquote>
<p>输入：[[1,2], [2,3], [3,4], [1,4], [1,5]]</p>
<p>输出：[1,4]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用并查集算法，对输入的边的节点分别查找其根节点，如果相同，则说明这是一条多余的边，否则合并当前的边。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] parents = <span class="keyword">new</span> <span class="title class_">int</span>[edges.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parents.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">uParent</span> <span class="operator">=</span> findParent(parents, edge[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">vParent</span> <span class="operator">=</span> findParent(parents, edge[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (uParent != vParent)</span><br><span class="line">            &#123;</span><br><span class="line">                parents[uParent] = vParent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;edge[<span class="number">0</span>], edge[<span class="number">1</span>]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findParent</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == parents[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> findParent(parents, parents[i]);</span><br><span class="line">        parents[i] = root;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-67:Add Binary</title>
    <url>/leetCode/leetCode-67/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个二进制字符串，要求求出它们的和。题目链接：**<a href="https://leetcode.com/problems/add-binary/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：a &#x3D; “11”, b &#x3D; “1”</p>
<p>输出：”100”</p>
</blockquote>
<blockquote>
<p>输入：a &#x3D; “1010”, b &#x3D; “1011”</p>
<p>输出：”10101”</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题类似大数相加，直接模拟加法求解过程即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> b.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> a.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> b.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (carry + first + second) % <span class="number">2</span>;</span><br><span class="line">            carry = (carry + first + second) / <span class="number">2</span>;</span><br><span class="line">            sb.append(num);</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (carry + temp) % <span class="number">2</span>;</span><br><span class="line">            carry = (carry + temp) / <span class="number">2</span>;</span><br><span class="line">            sb.append(num);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (carry + temp) % <span class="number">2</span>;</span><br><span class="line">            carry = (carry + temp) / <span class="number">2</span>;</span><br><span class="line">            sb.append(num);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-68:Text Justification</title>
    <url>/leetCode/leetCode-68/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个由单词组成的数组和一个数字 <code>maxWidth</code>，要求将单词数组中的单词进行格式化输出，规则如下：</p>
<ul>
<li>每一行只能包括单词和空格，单词之间用空格分隔，行的长度为 <code>maxWidth</code></li>
<li>采用贪心策略，每一行要尽可能多的放置单词</li>
<li>空格的分布需要尽可能的均匀，如果空格不能均匀分布，则将空格放在单词左边而不是单词的右边</li>
<li>对于最后一行，单词间用一个空格分隔，剩余的长度用空格补充在最后一个单词后面。</li>
<li>对于一行只有一个单词，则剩余的长度用空格补充在单词后面</li>
</ul>
<p>题目链接：**<a href="https://leetcode.com/problems/text-justification">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：words &#x3D; [“This”, “is”, “an”, “example”, “of”, “text”, “justification.”]    maxWidth &#x3D; 16</p>
<p>输出：</p>
<p>[<br>   “This    is    an”,<br>   “example  of text”,<br>   “justification.  “<br>]</p>
</blockquote>
<blockquote>
<p>输入：words &#x3D; [“What”,”must”,”be”,”acknowledgment”,”shall”,”be”]     maxWidth &#x3D; 16</p>
<p>输出：</p>
<p>[<br>  “What   must   be”,<br>  “acknowledgment  “,<br>  “shall be        “<br>]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>直接按照规则进行格式化即可，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">fullJustify</span><span class="params">(String[] words, <span class="type">int</span> maxWidth)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; resultList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; words.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentWidth + words[end].length() &lt;= maxWidth)</span><br><span class="line">            &#123;</span><br><span class="line">                currentWidth = currentWidth + words[end].length() + <span class="number">1</span>;</span><br><span class="line">                end++;</span><br><span class="line">                <span class="keyword">if</span> (end == words.length)</span><br><span class="line">                &#123;</span><br><span class="line">                    resultList.add(getWordLine(words, maxWidth, begin, end));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                resultList.add(getWordLine(words, maxWidth, begin, end));</span><br><span class="line">                begin = end;</span><br><span class="line">                currentWidth = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getWordLine</span><span class="params">(String[] words, <span class="type">int</span> maxWidth, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">line</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the last line, or the line has only one word</span></span><br><span class="line">        <span class="keyword">if</span> (end == words.length || end == begin + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            line.append(words[begin]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin + <span class="number">1</span>; i &lt; end; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                line.append(<span class="string">&quot; &quot;</span>).append(words[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            appendSpace(line, maxWidth - line.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wordWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; end; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                wordWidth += words[i].length();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">totalSpace</span> <span class="operator">=</span> maxWidth - wordWidth;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wordSpace</span> <span class="operator">=</span> totalSpace / (end - begin - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">remainSpace</span> <span class="operator">=</span> totalSpace % (end - begin - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; end - <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                line.append(words[i]);</span><br><span class="line">                appendSpace(line, wordSpace);</span><br><span class="line">                <span class="keyword">if</span> (remainSpace &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    line.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                    remainSpace--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            line.append(words[end - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> line.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">appendSpace</span><span class="params">(StringBuilder line, <span class="type">int</span> num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            line.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-685:Redundant Connection II</title>
    <url>/leetCode/leetCode-685/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二维数组表示边 <code>[u, v]</code> 的集合，每条边表示 <code>u</code> 到 <code>v</code> 有一条连线，且 <code>u</code> 是 <code>v</code> 的父节点，这些边连接后构成一个有向连通图，其中存在一条多余的边，要求将这条边找出并剔除，使得剩下的图不存在环结构，同时仍然保持是一个有向的连通图。如果存在多条边，则返回最后出现的那条边。题目链接：**<a href="https://leetcode.com/problems/redundant-connection-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[1,2], [2,3], [3,4], [4,1], [1,5]]</p>
<p>输出：[4,1]</p>
</blockquote>
<blockquote>
<p>输入：[[2,1], [3,1], [4,2], [1,4]]</p>
<p>输出：[2,1]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题跟 <a href="https://guozhchun.github.io/leetCode/leetCode-684/">LeetCode-684</a> 类似，不同的是 LeetCode-684 是无向图，而这题是有向图。针对此题，仍然可以使用并查集进行求解，不同的是不能单纯的判断是否存在环，否则对于输入<code>[[2,1], [3,1], [4,2], [1,4]]</code> 得到的结果是 <code>[1,4]</code> 而不是 <code>[2,1]</code>。针对此问题，观察得知，可能存在某个节点的入度为 <code>2</code>，即某个节点拥有两个父节点，这两条边必然需要去除一条边。所以，可以在排除这两条边的情况下运用并查集构建图，然后依次加入这两条边，如果加入某条边时构成了环，说明这条边是多余的，需要去除。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantDirectedConnection(<span class="type">int</span>[][] edges)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] parents = <span class="keyword">new</span> <span class="title class_">int</span>[edges.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">boolean</span>[] isUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[edges.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">duplicateNode</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isUsed[edge[<span class="number">1</span>]])</span><br><span class="line">            &#123;</span><br><span class="line">                duplicateNode = edge[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            isUsed[edge[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; remainEdgeList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[<span class="number">1</span>] != duplicateNode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (isFindEdge(parents, edge))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> edge;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                remainEdgeList.add(edge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : remainEdgeList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFindEdge(parents, edge))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFindEdge</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span>[] edge)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">uParent</span> <span class="operator">=</span> findParent(parents, edge[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">vParent</span> <span class="operator">=</span> findParent(parents, edge[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (uParent == vParent)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parents[vParent] = uParent;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findParent</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (parents[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> findParent(parents, parents[i]);</span><br><span class="line">        parents[i] = root;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-69:Sqrt(x)</title>
    <url>/leetCode/leetCode-69/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个非负整数，要求在不使用编程语言自带的库函数的前提下找出这个整数的正数平方根（如果是小数，则向下取整）。题目链接：**<a href="https://leetcode.com/problems/sqrtx/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：4</p>
<p>输出：2</p>
</blockquote>
<blockquote>
<p>输入：8</p>
<p>输出：2</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>一般情况下，求平方根可以使用 <code>Math.sqrt</code> 函数进行求解，但是题目已经明确要求不能使用库函数。那简单一点的做法就是遍历整数，判断其平方是否是小于等于目标树的最大整数，如果是，当前这个数字就是求解的答案。再优化点的做法是使用二分查找进行求解，从而将时间复杂度从 <code>O(n)</code> 降低到 <code>O(log n)</code> 。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> x / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (x / middle &gt;= middle) &#123;</span><br><span class="line">                start = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> start - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-7:Reverse Integer</title>
    <url>/leetCode/leetCode-7/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数，范围是<code>-2^31 ~ 2^32-1</code>，要求返回这个整数的逆序整数。如果得到的逆序整数超过整形的范围<code>-2^31 ~ 2^32-1</code>，则返回0。题目链接：**<a href="https://leetcode.com/problems/reverse-integer/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：123</p>
<p>输出：321</p>
</blockquote>
<blockquote>
<p>输入：-123</p>
<p>输出：-321</p>
</blockquote>
<blockquote>
<p>输入：-1200</p>
<p>输出：-21</p>
</blockquote>
<blockquote>
<p>输入：1234567899</p>
<p>输出：0</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="使用StringBuilder-reverse函数"><a href="#使用StringBuilder-reverse函数" class="headerlink" title="使用StringBuilder.reverse函数"></a>使用StringBuilder.reverse函数</h2><p>java类库中给我们提供了很多的函数方便我们使用，其中<code>StringBuilder.reverse</code>函数是将字符串按顺序倒置，与这道题类似。因此可以将输入的整数转成StringBuilder，再使用reverse函数完成逆序，再转成int类型即可。</p>
<p><em>注意：在转成 int 类型时，可能会超出 int 类型的范围而抛出异常，此时需要捕获异常并将值置为 0</em></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; Integer.MIN_VALUE || x &gt; Integer.MAX_VALUE) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> x &gt; <span class="number">0</span> ? x : -x;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(String.valueOf(num));</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = Integer.valueOf(s.reverse().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NumberFormatException e) </span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result = x &gt; <span class="number">0</span> ? result : -result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分拆数字逆序"><a href="#分拆数字逆序" class="headerlink" title="分拆数字逆序"></a>分拆数字逆序</h2><p>上面使用try-catch来处理转换后的数字超过整形范围的情况，这类似于使用try-catch来代替 if 语句处理业务逻辑，这是不建议的。而且，上面使用库函数虽然比较方便，但是效率上却有点低，我们可以使用另外一种方式来提高一下效率。首先，将整数的每个数字取出放在数组中，然后将数字逆序拼接成新的整数，在拼接的过程中判断是否会超出整形范围，超出则返回0。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取非负整数的逆序数组，返回10位数组（2 ^ 31 - 1 = 2147483647，10位数组足够），不足10位时补0</span></span><br><span class="line"><span class="comment">     * 前置条件：输入的数为非负整数</span></span><br><span class="line"><span class="comment">     * 例如：输入：0</span></span><br><span class="line"><span class="comment">     *     输出：[0,0,0,0,0,0,0,0,0,0]</span></span><br><span class="line"><span class="comment">     *     输入：123</span></span><br><span class="line"><span class="comment">     *     输出：[3,2,1,0,0,0,0,0,0,0]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 非负整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 10位长度的数组，表示x的逆序，不足10位时补0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] getReverseNums(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[index] = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; Integer.MIN_VALUE || x &gt; Integer.MAX_VALUE) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> x &gt; <span class="number">0</span> ? x : -x;</span><br><span class="line">        <span class="type">int</span>[] nums = getReverseNums(num);</span><br><span class="line">        <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// find the end index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                endIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= endIndex; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 先判断转成整数是否超出范围，否则溢出时数据发生改变</span></span><br><span class="line">            <span class="comment">// 虽然 -Integer.MIN_VALUE 比  Integer.MAX_VALUE 大 1，</span></span><br><span class="line">            <span class="comment">// 但是无法构造出result * 10 + nums[i] = 2147483648的值</span></span><br><span class="line">            <span class="comment">// 因为这样要求输入的值是-8463847412，超出了整形范围，在函数刚开始时就会进行判断返回0</span></span><br><span class="line">            <span class="comment">// 从另一个角度讲，逆序数无法达到整形的边界，因此此处可以直接用整形最大值进行判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span> (result &gt; (Integer.MAX_VALUE - nums[i]) / <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            result = result * <span class="number">10</span> + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = x &gt; <span class="number">0</span> ? result : -result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-70:Climbing Stairs</title>
    <url>/leetCode/leetCode-70/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个数字（1 &lt;&#x3D; n &lt;&#x3D; 45）表达楼梯的层数，一个人在楼梯底部，每次只能向上走一步或两步，要求找出从楼梯底部到目标楼梯总共有多少种不同的走法。题目链接：**<a href="https://leetcode.com/problems/climbing-stairs/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：2</p>
<p>输出：2</p>
<p>说明：两种，分别是 1 + 1 或 2</p>
</blockquote>
<blockquote>
<p>输入：3</p>
<p>输出：3</p>
<p>说明：三种，分别是 1 + 1 +1 或 1 + 2 或 2 + 1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题是斐波拉契数列的一种应用，直接用斐波拉契数列的解法进行求解即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            current = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = current;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-71:Simplify Path</title>
    <url>/leetCode/leetCode-71/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串表示 unix 系统下的绝对路径，要求将其转成最简单的等价路径。路径不能以 <code>/</code> 结尾（只有<code>/</code>的例外）。题目链接：**<a href="https://leetcode.com/problems/simplify-path/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：<code>/home/</code></p>
<p>输出：<code>/home</code></p>
</blockquote>
<blockquote>
<p>输入：<code>/a/../../b/../c//.//</code></p>
<p>输出：<code>/c</code></p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>根据 <code>/</code> 将输入的路径进行分割，用一个新的数组存储最终路径的每个目录元素。遍历分割后的字符串数组，如果遇到 <code>..</code> 则将存储目录元素的数组中删掉一个元素，否则加入新的目录元素。最后将存在目录元素的字符串数组用 <code>/</code> 进行连接，即是最终的答案。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        String[] elements = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        String[] temp = <span class="keyword">new</span> <span class="title class_">String</span>[elements.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; elements.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;.&quot;</span>.equals(elements[i]) || <span class="string">&quot;&quot;</span>.equals(elements[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;..&quot;</span>.equals(elements[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    index = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp[index] = elements[i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;/&quot;</span>).append(temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sb.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-72:Edit Distance</title>
    <url>/leetCode/leetCode-72/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个字符串，要求计算出从第一个字符串到第二个字符串所需要的最小的操作次数。每次操作允许：在任何一个位置增加一个字符、删除任何一个字符、替换任何一个字符。题目链接：**<a href="https://leetcode.com/problems/edit-distance">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：word1 &#x3D; “horse”, word2 &#x3D; “ros”</p>
<p>输出：3</p>
</blockquote>
<blockquote>
<p>输入：word1 &#x3D; “intention”, word2 &#x3D; “execution”</p>
<p>输出：5</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用动态规划。用 <code>dp[i][j]</code> 表示第一个字符串的前 <code>i</code> 个字符组成的子字符串变换到第二个字符串前 <code>j</code> 个字符组成的子字符串所需要经过的最小操作次数。则动态转移方程为 <code>dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + (word1[i] == word2[j] ? 0 : 1))</code>。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> len2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (len2 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> len1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len1][len2];</span><br><span class="line">        <span class="keyword">if</span> (word1.charAt(<span class="number">0</span>) != word2.charAt(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(<span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; len2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (word2.charAt(j) == word1.charAt(<span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; len2; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j))</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = Math.min(temp, dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = Math.min(temp, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[len1 - <span class="number">1</span>][len2 - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p> <a href="https://blog.csdn.net/chichoxian/article/details/53944188">https://blog.csdn.net/chichoxian/article/details/53944188</a> </p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-73:Set Matrix Zeroes</title>
    <url>/leetCode/leetCode-73/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数矩阵，要求用 <code>O(1)</code> 的空间复杂度将矩阵中数字 0 所在的行和列的数字都变成 0。题目链接：**<a href="https://leetcode.com/problems/set-matrix-zeroes/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[1,1,1], [1,0,1], [1,1,1]]</p>
<p>输出：[[1,0,1], [0,0,0], [1,0,1]]</p>
</blockquote>
<blockquote>
<p>输入：[[0,1,2,0], [3,4,5,2], [1,3,1,5]]</p>
<p>输出：[[0,0,0,0], [0,4,5,0], [0,3,1,0]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>将第一行和第一列单独出来，先遍历第一行和第一列，看是否存在 0 的元素，如果存在，则说明该行或该列必为 0，此操作放在最后操作。从第二行第二列遍历矩阵，如果遇到元素为 0，则将该元素所在行的首元素和所在列的首元素标记为 0。待循环结束后，再次遍历矩阵，如果遇到元素所在行首元素或所在列首元素为 0，则将当前元素变为 0。最后，再根据首行和首列是否为 0 的标志位决定将首行或首列的元素变为 0。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowNum</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">colNum</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断矩阵首行是否应该设置为 0</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFirstRowZero</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colNum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                isFirstRowZero = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断矩阵首列是否应该设置为 0</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFirstColZero</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                isFirstColZero = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历矩阵，将值为 0 的元素所在的行首和所在的列首的元素设置为 0，方便后续操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; rowNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; colNum; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从第二行开始遍历矩阵的每一行，如果当前行的首元素是 0，则将当前行的所有元素值设置为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; rowNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colNum; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从第二列开始遍历矩阵的每一列，如果当前列的首元素是 0，则将当前列的所有元素值设置为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; colNum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowNum; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果矩阵首列应该设置为 0，则将当前列的所有元素设置为 0</span></span><br><span class="line">        <span class="keyword">if</span> (isFirstColZero)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowNum; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果矩阵首行应该设置为 0，则将当前行的所有元素设置为 0</span></span><br><span class="line">        <span class="keyword">if</span> (isFirstRowZero)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colNum; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-74:Search a 2D Matrix</title>
    <url>/leetCode/leetCode-74/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个矩阵，其中每一行的数字从左到右是递增的，每一行第一个数比前一行最后一个数大，要求判断给定的数字是否在矩阵中。题目链接：**<a href="https://leetcode.com/problems/search-a-2d-matrix">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]     3</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：[[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]     13</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此问题最简单是遍历，不过既然题目告诉矩阵的特征，说明有更好的算法。如果将组件每一行连接起来，就是一个递增的数组，就可以用二分搜索来算了。基于此思路，可以先对矩阵最后一列用二分搜索，找到特定的行，再对那行用二分搜索，以此可以找到目标数字是否在矩阵中。此算法的时间复杂度为 <code>O(lg(m * n))</code>，与 <code>m * n</code> 长度的数组二分查找时间复杂度相同。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (matrix[<span class="number">0</span>][<span class="number">0</span>] &gt; target || matrix[m - <span class="number">1</span>][n - <span class="number">1</span>] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[middle][n - <span class="number">1</span>] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (matrix[middle][n - <span class="number">1</span>] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                end = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                start = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> middle;</span><br><span class="line">        <span class="keyword">if</span> (matrix[middle][n - <span class="number">1</span>] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">        end = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][middle] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (matrix[row][middle] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                end = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                start = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-75:Sort Colors</title>
    <url>/leetCode/leetCode-75/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个只包括 <code>0、1、2</code> 三种数字的的数组，要求用一次循环迭代，使用常量空间对数组进行升序排序。题目链接：**<a href="https://leetcode.com/problems/sort-colors/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[2,0,2,1,1,0]</p>
<p>输出：[0,0,1,1,2,2]</p>
</blockquote>
<blockquote>
<p>输入：[2,0,1]</p>
<p>输出：[0,1,2]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>对于排序，如果采用常规做法，要么需要 <code>O(nlgn)</code> 的时间复杂度配合 <code>O(1)</code>的空间复杂度，要么需要 <code>O(1)</code> 的时间复杂度配合 <code>O(n)</code> 的空间复杂度，这都不满足题目的要求。鉴于排序中只有 <code>0、1、2</code> 三中数字，因此可以采用取巧的做法：用一个左指针指向数组从左到右第一个非 0 元素，用一个右指针指向数组从右到左第一个非 2 元素，从左到右遍历数组，如果当前元素是 0，则与左指针的元素交换值，并向右移动左指针，如果当前位置比右指针的值大，则交换这两个值，并移动右指针。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= right &amp;&amp; left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; left)</span><br><span class="line">                &#123;</span><br><span class="line">                    i = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[right] == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[left];</span><br><span class="line">                nums[left] = temp;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; nums[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[right];</span><br><span class="line">                nums[right] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-76:Minimum Window Substring</title>
    <url>/leetCode/leetCode-76/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个字符串 <code>s</code> 和 <code>t</code>，要求在 <code>s</code> 的连续子字符串列表中找出包含 <code>t</code> 字符串中的所有字符的最小连续子字符串。题目链接：**<a href="https://leetcode.com/problems/minimum-window-substring">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入： S &#x3D; “ADOBECODEBANC”, T &#x3D; “ABC”</p>
<p>输出：”BANC”</p>
</blockquote>
<blockquote>
<p>输入：S &#x3D; “AA”, T &#x3D; “AA”</p>
<p>输出：”AA”</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用一个 map 存储 <code>t</code> 的字符以及字符出现的次数。再用两个指针分别指向 <code>s</code> 字符串，右边指针遍历 <code>s</code> 字符串，直到这两个指针围成的字符串包含了 <code>t</code> 中所有的字符，此时计算并更新字符串的长度及开始位置。然后移动左边的指针，依次缩小范围，看是否有更小的满足要求的字符串，如果有则更新结果。待左边指针紧靠右边指针时，继续移动右边指针，重复上述查找过程。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; tmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : t.toCharArray())</span><br><span class="line">        &#123;</span><br><span class="line">            putCharacter(tmap, ch);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">windowStartIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (end &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Character</span> <span class="variable">character</span> <span class="operator">=</span> s.charAt(end);</span><br><span class="line">            <span class="keyword">if</span> (tmap.containsKey(character))</span><br><span class="line">            &#123;</span><br><span class="line">                putCharacter(map, character);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 判断 map 中是否包含 tmap</span></span><br><span class="line">                <span class="comment">// 判断依据：map 包含 tmap 中所有的 key，并且每个key对应的value值，map不小于tmap</span></span><br><span class="line">                <span class="keyword">if</span> (isContaions(map, tmap))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span> (begin &lt; end &amp;&amp; needMove(map, tmap, s.charAt(begin)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        map.computeIfPresent(s.charAt(begin), (k, v) -&gt; v - <span class="number">1</span>);</span><br><span class="line">                        begin++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (minLength == -<span class="number">1</span> || (end - begin + <span class="number">1</span>) &lt; minLength)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minLength = end - begin + <span class="number">1</span>;</span><br><span class="line">                        windowStartIndex = begin;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (minLength &gt; <span class="number">0</span> &amp;&amp; end - begin + <span class="number">1</span> &gt; minLength)</span><br><span class="line">                &#123;</span><br><span class="line">                    reduceCharacter(map, s.charAt(begin));</span><br><span class="line">                    begin++;</span><br><span class="line">                    <span class="keyword">while</span> (begin &lt; end &amp;&amp; needMove(map, tmap, s.charAt(begin)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        map.computeIfPresent(s.charAt(begin), (k, v) -&gt; v - <span class="number">1</span>);</span><br><span class="line">                        begin++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (minLength == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s.substring(windowStartIndex, windowStartIndex + minLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断 sMap 是否包含 tMap</span></span><br><span class="line">    <span class="comment">// 判断依据： sMap中包含tMap中所有key，并且对于每个key，sMap的value值大于等于tMap的value值 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isContaions</span><span class="params">(Map&lt;Character, Integer&gt; sMap, Map&lt;Character, Integer&gt; tMap)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : tMap.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sMap.containsKey(entry.getKey()))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (sMap.get(entry.getKey()) &lt; tMap.get(entry.getKey()))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否要移动当前指针，如果 sMap 或者 tMap 中不包含当前字符，或者 sMap 中对应 value 值大于 tMap，则需要移动当前指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">needMove</span><span class="params">(Map&lt;Character, Integer&gt; sMap, Map&lt;Character, Integer&gt; tMap, Character character)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tMap.containsKey(character))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!sMap.containsKey(character))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sMap.get(character) &gt; tMap.get(character);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加当前字符计数，如果 map 中存在字符，则计数加一，否则当字符放入 map 中并设置 value 值为 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">putCharacter</span><span class="params">(Map&lt;Character, Integer&gt; map, Character character)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(character))</span><br><span class="line">        &#123;</span><br><span class="line">            map.compute(character, (k, v) -&gt; v + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            map.put(character, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 减少当前字符计数，如果 map 中存在当前字符并且对应的 value 值为 1，则移除当前字符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reduceCharacter</span><span class="params">(Map&lt;Character, Integer&gt; map, Character character)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(character))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> map.get(character);</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                map.remove(character);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                map.put(character, num - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码可以通过所有用例，但是耗时比较长，达到 200+ ms，我想主要是判断当前子字符串是否包含 <code>t</code> 中所有字符的操作（<code>isContaions</code> 循环比较 map，并且多次进行调用这个函数）比较耗时。针对此，可以优化判断条件，增加一个参数记录当前已经满足要求的字符的个数，用这个参数与 <code>t</code> 中不同的字符个数进行比较，可以避免多次循环。另一个优化点，是针对 <code>sMap</code>，不再判断当前字符在 <code>t</code> 中才放入 <code>map</code>，而是对所有的字符都直接放入 <code>map</code> 中，这样可以减少判断。此中做法主要参考： <a href="https://leetcode.com/articles/minimum-window-substring/">https://leetcode.com/articles/minimum-window-substring/</a> ，耗时 20+ ms。代码如下，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; tMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Character</span> <span class="variable">character</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> tMap.getOrDefault(character, <span class="number">0</span>);</span><br><span class="line">            tMap.put(character, num + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Character, Integer&gt; sMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">windowBeginIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">// 记录 [begin, end] 围起来的字符串中满足 t 中的非重复字符的个数</span></span><br><span class="line">        <span class="keyword">while</span> (end &lt; s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Character</span> <span class="variable">currentChar</span> <span class="operator">=</span> s.charAt(end);</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sMap.getOrDefault(currentChar, <span class="number">0</span>);</span><br><span class="line">            sMap.put(currentChar, num + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 注意：map.get() 获取的是 Integer，必须手动拆装成 int 进行数值的比较</span></span><br><span class="line">            <span class="comment">// 否则两个 Integer 进行 == 比较，可能会出现错误</span></span><br><span class="line">            <span class="keyword">if</span> (tMap.containsKey(currentChar) &amp;&amp; tMap.get(currentChar).intValue() == sMap.get(currentChar).intValue())</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (begin &lt;= end &amp;&amp; count == tMap.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (minLength == -<span class="number">1</span> || (end - begin + <span class="number">1</span>) &lt; minLength)</span><br><span class="line">                &#123;</span><br><span class="line">                    minLength = end - begin + <span class="number">1</span>;</span><br><span class="line">                    windowBeginIndex = begin;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="type">Character</span> <span class="variable">beginChar</span> <span class="operator">=</span> s.charAt(begin);</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> sMap.getOrDefault(beginChar, <span class="number">0</span>);</span><br><span class="line">                sMap.put(beginChar, temp - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (tMap.containsKey(beginChar) &amp;&amp; tMap.get(beginChar).intValue() &gt; sMap.get(beginChar).intValue())</span><br><span class="line">                &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (minLength == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s.substring(windowBeginIndex, windowBeginIndex + minLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p> <a href="https://leetcode.com/articles/minimum-window-substring/">https://leetcode.com/articles/minimum-window-substring/</a> </p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-77:Combinations</title>
    <url>/leetCode/leetCode-77/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出数字 n 和数字 k，要求在数字1…n中找出 k 个数字的组合。题目链接：**<a href="https://leetcode.com/problems/combinations/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：n &#x3D; 4, k &#x3D; 2</p>
<p>输出：[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题主要使用回溯算法进行求解。需要用 k 轮迭代来获取 k 个数字的值，在每轮迭代中，依次遍历数字 i<del>n （第一轮：遍历1</del>n，第二轮遍历2<del>n，第三轮遍历3</del>n，…），对每个数字加进列表中，如果列表中的个数刚好是k，则将这个列表放如结果集中。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start, List&lt;Integer&gt; items, List&lt;List&lt;Integer&gt;&gt; result)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (items.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Integer&gt; tempItems = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(items);</span><br><span class="line">            result.add(tempItems);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            items.add(i);</span><br><span class="line">            helper(n, k, i + <span class="number">1</span>, items, result);</span><br><span class="line">            items.remove(items.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        helper(n, k, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-78:Subsets</title>
    <url>/leetCode/leetCode-78/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>  给出一个不包含重复数字的整形数组，要求找出这个数组的所有子集合（幂集）。题目链接：**<a href="https://leetcode.com/problems/subsets/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,2,3]</p>
<p>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此问题可以转换成以下的解法：求出[1,2,3,…n-1]的所有子集合，对这每个子集合都加上[n]这个数得到新的包含[n]的集合，将这些集合合并就是[1,2,3,…n]的所有子集合。从这个过程来看，是一个递归的过程，但是可以将其转成递推，主要做法是先放入一个空集合，然后对数组中的每个数，都取出数组前面的数的所有子集合，然后加上这个数得到新的集合，再将这些集合合并得到截至数组目前这个数的所有子集合。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> result.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;Integer&gt; multiNumList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(result.get(j));</span><br><span class="line">                multiNumList.add(nums[i]);</span><br><span class="line">                result.add(multiNumList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-8:String to Integer (atoi)</title>
    <url>/leetCode/leetCode-8/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串，将其转换成整数。转换规则如下：</p>
<ul>
<li>整数第一个字符必须是 <code>-</code> 或 <code>+</code> 或 <code>0-9</code> 的数字</li>
<li>整数前面允许有空格，但是不允许有其他的字符出现，如果出现其他字符，表明这个字符串无法转成整数，返回数字 0</li>
<li>在由一连串数字构成的整数后面，如果出现其他字符，则不用继续转换，只取第一个转换的整数返回即可</li>
<li>如果在转换的过程中，整数的范围超过 <code>Integer.MIN_VALUE ~ Integer.MAX_VALUE</code> ，则负数返回 <code>Integer_MIN_VALUE</code>，正数返回 <code>Integer_MAX_VALUE</code></li>
</ul>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：”     -42abc”</p>
<p>输出：-42</p>
</blockquote>
<blockquote>
<p>输入：”-123456789012345”</p>
<p>输出：-2147483648</p>
</blockquote>
<blockquote>
<p>输入：”abc 1123”</p>
<p>输出：0</p>
</blockquote>
<blockquote>
<p>输入：”123”</p>
<p>输出：123</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="使用正则"><a href="#使用正则" class="headerlink" title="使用正则"></a>使用正则</h2><p>使用正则表达式先将数字查找出来，然后使用 <code>Integer.parseInt</code> 函数将字符串转成数字，在转换的过程中，如果超过范围，则会抛出<code>NumberFormatException</code>，因此，只需要捕获 <code>NumberFormatException</code> 异常，并在异常处理中判断是返回最小值还是最大值即可。</p>
<p>此种方法相对而言比较简单，看起来也很清晰，不过在将字符串转成整形的过程中，使用了异常代码块进行正常业务逻辑的处理，这不太好。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String str)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">nums</span> <span class="operator">=</span> str.trim();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length();</span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;[-+]&#123;0,1&#125;\\d+&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(nums);</span><br><span class="line">        <span class="keyword">if</span> (!matcher.find())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> matcher.group();</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> matcher.start();</span><br><span class="line">        <span class="keyword">if</span> (startIndex != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = Integer.parseInt(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NumberFormatException e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result = Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h2><p>使用正则虽然简单明了，但是却比较耗时，因此可以直接使用最原始的方法：遍历字符串。在遍历字符串的过程中同时将其转成整形。此种方法相对而言比较繁琐一点，但是耗时更少。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String str)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">beginIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sign = -<span class="number">1</span>;</span><br><span class="line">                beginIndex = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                beginIndex = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                beginIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> beginIndex; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (sign == -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((Integer.MIN_VALUE + ch - <span class="string">&#x27;0&#x27;</span>) / <span class="number">10</span> &gt; result)</span><br><span class="line">                &#123;</span><br><span class="line">                    result = Integer.MIN_VALUE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((Integer.MAX_VALUE - (ch - <span class="string">&#x27;0&#x27;</span>)) / <span class="number">10</span> &lt; result)</span><br><span class="line">                &#123;</span><br><span class="line">                    result = Integer.MAX_VALUE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result * <span class="number">10</span> + sign * (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-80:Remove Duplicates from Sorted Array II</title>
    <url>/leetCode/leetCode-80/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组，数组中的元素非递减排序。要求去除数组中的重复元素，使得每个元素最多出现两次，且仍然保持非递减的顺序。要求空间复杂度为 <code>O(1)</code>。题目链接：**<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,1,1,2,2,3]</p>
<p>输出：5, nums &#x3D; [1,1,2,2,3,_]</p>
<p>解释：返回有 5 个数据，数组中前 5 个数据是剔除后的结果，数组中后面的数据的值并不重要，可以是任意的值</p>
</blockquote>
<blockquote>
<p>输入：[0,0,1,1,1,1,2,3,3]</p>
<p>输出：7, nums &#x3D; [0,0,1,1,2,3,3, _ , _ ,_]</p>
<p>解释：返回有 7 个数据，数组中前 7 个数据是剔除后的结果，数组中后面的数据的值并不重要，可以是任意的值</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>本题如果不限制空间复杂度的话，最简单的方式就是新建一个数组来存储结果值，然后遍历原数组进行判断，将符合的值放入新数组中。但是这中做法需要 <code>O(n)</code> 的时间复杂度，并不满足要求。所以需要换种做法。由于数组中可能存在多于的元素，因此先从左到右将不满足条件（有多于 2 个的重复元素）的元素位置找到，然后用另一个指针遍历，将一或者两个重复元素赋值给前一个指针，每次赋值后都将前面的一个指针向后移动一位，最后前面指针的位置就是结果数组中的有效长度。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; nums.length &amp;&amp; nums[i] == nums[j])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; nums.length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-81:Search in Rotated Sorted Array II</title>
    <url>/leetCode/leetCode-81/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个包含重复元素的旋转升序数组，要求用 <code>O(log n)</code> 的时间复杂度查找某个元素是否在数组中。题目链接：**<a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[4,5,6,7,0,1,2]   0</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：[4,5,6,7,0,1,2]   9</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>要求在  <code>O(log n)</code> 的时间复杂度查找某个元素是否在数组中，很明显需要用二分查找。当前数组是剔除了重复元素，就是一个简单旋转升序数组中查找元素的解法。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] == target || nums[start] == target || nums[end] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 剔除重复元素</span></span><br><span class="line">            <span class="keyword">if</span> (end &gt; middle &amp;&amp; nums[end] == nums[end - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (end &gt; middle &amp;&amp; nums[end] == nums[end - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    end--;</span><br><span class="line">                &#125;</span><br><span class="line">                end--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (start &lt; middle &amp;&amp; nums[start] == nums[start + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (start &lt; middle &amp;&amp; nums[start] == nums[start + <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[start] == nums[end] &amp;&amp; start &lt; end)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (nums[start] == nums[end] &amp;&amp; start &lt; end)</span><br><span class="line">                &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                    end--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 二分查找</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[end] &lt; target)</span><br><span class="line">                &#123;</span><br><span class="line">                    end = middle - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    start = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[start] &lt; target)</span><br><span class="line">                &#123;</span><br><span class="line">                    end = middle - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    start = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-82:Remove Duplicates from Sorted List II</title>
    <url>/leetCode/leetCode-82/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个有序链表，要求将链表中的所有重复节点（包括自己）全部删除。题目链接：**<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：1-&gt;2-&gt;2-&gt;2-&gt;3</p>
<p>输出：1-&gt;3</p>
</blockquote>
<blockquote>
<p>输入：1-&gt;1-&gt;1-&gt;2</p>
<p>输出：2</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，直接遍历判断删除即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> p.next;</span><br><span class="line">            <span class="keyword">while</span> (next.next != <span class="literal">null</span> &amp;&amp; next.val == next.next.val)</span><br><span class="line">            &#123;</span><br><span class="line">                next = next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (p.next != next)</span><br><span class="line">            &#123;</span><br><span class="line">                p.next = next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-83:Remove Duplicates from Sorted List</title>
    <url>/leetCode/leetCode-83/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个有序链表，要求将链表中的重复节点删除。题目链接：**<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：1-&gt;1-&gt;2</p>
<p>输出：1-&gt;2</p>
</blockquote>
<blockquote>
<p>输入：1-&gt;1-&gt;2-&gt;3-&gt;3</p>
<p>输出：1-&gt;2-&gt;3</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题比较简单，直接遍历判断删除即可。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (prev.next != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> prev.next;</span><br><span class="line">            <span class="keyword">if</span> (prev.val == current.val)</span><br><span class="line">            &#123;</span><br><span class="line">                prev.next = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                prev = prev.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-84:Largest Rectangle in Histogram</title>
    <url>/leetCode/leetCode-84/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个非负整数的数组，每个数字代表直方图的高度，每个直方图的宽度都是 1，要求找出又这些直方图所能构成的矩形的最大面积。题目链接：**<a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[2, 1, 5, 6, 2, 3]</p>
<p>输出：10</p>
</blockquote>
<blockquote>
<p>输入：[5, 4, 0, 1]</p>
<p>输出：8</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解法一：动态规划（空间复杂度不满足）"><a href="#解法一：动态规划（空间复杂度不满足）" class="headerlink" title="解法一：动态规划（空间复杂度不满足）"></a>解法一：动态规划（空间复杂度不满足）</h2><p>主要是遍历数组，找出所有任意两个直方图围起来的矩形面积，对其进行比较找出最大面积。观察矩形可知，矩形的宽度可以由左右两个边界值计算得出，矩形的高度是构成矩形的直方图中的最小高度。因此可以用 <code>dp[i][j]</code> 表示 <code>[i, j]</code> 区间内的直方图的最小高度，转移方程为：<code>dp[i][j] = min&#123;dp[i + 1][j - 1], a[i], a[j]&#125;</code>，通过 <code>(j - i + 1) * dp[i][j]</code> 可以计算出 <code>[i, j]</code> 区间的直方图构成的矩形面积。在计算 <code>dp</code> 数组的过程中更新最大矩形的面积。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (heights == <span class="literal">null</span> || heights.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span>[][] minHeights = <span class="keyword">new</span> <span class="title class_">int</span>[length][length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            minHeights[i][i] = heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> heights[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; length; right++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt;= right; left++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (left + <span class="number">1</span> &gt; right - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    minHeights[left][right] = Math.min(heights[left], heights[right]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    minHeights[left][right] = Math.min(Math.min(heights[left], heights[right]), minHeights[left + <span class="number">1</span>][right - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                maxArea = Math.max(maxArea, minHeights[left][right] * (right - left + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：递推"><a href="#解法二：递推" class="headerlink" title="解法二：递推"></a>解法二：递推</h2><p>由于解法一使用动态规划，需要用 <code>n*n</code> 的数组来保存状态，消耗空间比较多，也不满足要求。仔细分析上述思路，可以优化如下：用外层 for 循环遍历数组，再用里层 for 循环从外层的指针出开始向左遍历，因此求出直方图最小高度和矩形宽度，计算并更新最大的矩形面积。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (heights == <span class="literal">null</span> || heights.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> heights[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; length; right++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minHeight</span> <span class="operator">=</span> heights[right];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> right; left &gt;= <span class="number">0</span>; left--)</span><br><span class="line">            &#123;</span><br><span class="line">                minHeight = Math.min(minHeight, heights[left]);</span><br><span class="line">                maxArea = Math.max(maxArea, minHeight * (right - left + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法三：栈"><a href="#解法三：栈" class="headerlink" title="解法三：栈"></a>解法三：栈</h2><p>方法二虽然解决了空间复杂度的问题，但是其时间复杂度是 <code>O(n*n)</code>，<a href="https://www.youtube.com/watch?v=KkJrGxuQtYo">网上</a>有更好的解法，是借助栈来完成的。其思想是用栈来存储递增的直方图，遇到比当前直方图高度小的，则可以确定以栈顶元素对应的直方图的高度构成的矩形，其右边界是当前数组的元素直方图，左边界是栈顶元素下一个元素，据此可以算出矩形的宽度，如果栈顶元素下一个元素为空，则矩形宽度为当前数组下标。其具体做法是：遍历数组，如果栈为空或当前栈顶元素对应的数字小于等于当前数组元素，则将当前数组下标压如栈中；如果栈顶元素对应的数字大于当前数组元素，则弹出栈顶的元素，获取其对应的高度，然后计算矩形的宽度，宽度等于当前数组下标减去栈顶元素下标再减去一（如果栈为空，则宽度为当前数组下标）。此种做法的时间复杂度为 <code>O(n)</code></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (heights == <span class="literal">null</span> || heights.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> heights[<span class="number">0</span>];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 让 i &lt;= length，是为了避免出现 [1, 2, 3] 这样纯递增的数组导致最后没有计算矩形面积的情况</span></span><br><span class="line">        <span class="comment">// 当 i == length 时，让获取的数组元素为 0，即可保证所有的元素均参与了计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentHeight</span> <span class="operator">=</span> i == length ? <span class="number">0</span> : heights[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.empty() &amp;&amp; heights[stack.peek()] &gt; currentHeight)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> stack.isEmpty() ? i : i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                maxArea = Math.max(maxArea, width * heights[index]);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.youtube.com/watch?v=KkJrGxuQtYo">https://www.youtube.com/watch?v=KkJrGxuQtYo</a></p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-86:Partition List</title>
    <url>/leetCode/leetCode-86/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表和一个整数，要求将链表中节点值小于该整数的节点移动到链表中第一个节点值大于或等于该整数的节点前面去。在移动的过程中，要求移动的节点保持原有的相对顺序。题目链接：**<a href="https://leetcode.com/problems/partition-list/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2,     x &#x3D; 3</p>
<p>输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>
<p>解释：第一个大于等于 3 的节点是 4，因此将两个 2 的节点移动到 4 之前</p>
</blockquote>
<blockquote>
<p>输入：head &#x3D; 5-&gt;4-&gt;3-&gt;2-&gt;1,   x &#x3D; 3</p>
<p>输出：2-&gt;1-&gt;5-&gt;4-&gt;3</p>
<p>解释：第一个大于等于 3 的节点是 5，因此将 2 和 1 两个节点移动到 5 前面，并且保持原先的顺序</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>先用一个循环，找到第一个大于或等于输入的整数的节点，此时该节点前即为待插入节点的区域。继续遍历链表，将后续每个小于该整数的节点从链表中移除，插入到前面找到的待插入节点区域中。为方便操作，不单独考虑首节点大于或等于输入整数的情况，可以新建一个头节点放在链表的前面，并将值设置为比原先链表头节点值小，这样可以直接进行循环判断，不用对头节点进行额外的考虑。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || x == Integer.MIN_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mockHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(x - <span class="number">1</span>);</span><br><span class="line">        mockHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">insertNode</span> <span class="operator">=</span> mockHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> mockHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (current.next != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.next.val &gt;= x)</span><br><span class="line">            &#123;</span><br><span class="line">                insertNode = current;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (current.next != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.next.val &lt; x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> current.next;</span><br><span class="line">                current.next = next.next;</span><br><span class="line">                next.next = insertNode.next;</span><br><span class="line">                insertNode.next = next;</span><br><span class="line">                insertNode = insertNode.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mockHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-85:Maximal Rectangle</title>
    <url>/leetCode/leetCode-85/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个只包含数字 0 和 1 的矩阵，要求找出其中只包含 1 构成的矩形的最大面积。题目链接：**<a href="https://leetcode.com/problems/maximal-rectangle/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]</p>
<p>输出：6</p>
</blockquote>
<blockquote>
<p>输入：[[“1”], [“0”], [“1”]]</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="解法一：栈"><a href="#解法一：栈" class="headerlink" title="解法一：栈"></a>解法一：栈</h2><p>将此题转换成<a href="https://leetcode.com/problems/largest-rectangle-in-histogram">leetCode84:Largest Rectangle in Histogram</a>直方图来求解。分别以矩阵的每一行为基准，以该行上方的数据构造成 leetCode84 题中的直方图，求解出该直方图的最大矩形。当遍历完矩阵每一行求出每个直方图的最大面积后，将这些最大面积进行比较返回其中的最大值即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || matrix[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + (matrix[i][j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxArea = Math.max(maxArea, maxRectangleArea(dp[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">maxRectangleArea</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> i == nums.length ? <span class="number">0</span> : nums[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.empty() &amp;&amp; nums[stack.peek()] &gt; h)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> stack.empty() ? i : i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                maxArea = Math.max(maxArea, nums[index] * width);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h2><p>此题解法主要是参考网上的做法。同样是遍历矩阵每一行，以该行为基准，求出该行上方构成的图形中的最大矩形面积。具体做法是：定义 <code>height[j]</code> 表示该行 <code>j</code> 列所能到达的高度，<code>left[j]</code> 表示该行 <code>j</code> 位置的高度所能延伸到左边的最左下标，<code>right[j]</code> 表示该行 <code>j</code> 位置的高度所能延伸到右边的最右下标。考虑到后续计算的方便，如果当前位置是 <code>0</code>，则 <code>left[j] = 0, right[j] = colNum - 1</code>，此时 <code>height[j] = 0</code>，对于计算以该位置的柱子向左右延伸构成的矩形面积并不会发生改变，都是 <code>0</code>，这是一步取巧的做法。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">colNum</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[colNum];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[colNum];</span><br><span class="line">        <span class="type">int</span>[] height = <span class="keyword">new</span> <span class="title class_">int</span>[colNum];</span><br><span class="line">        Arrays.fill(right, colNum - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colNum; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    height[j] = height[j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    height[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">currentLeft</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colNum; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    left[j] = Math.max(left[j], currentLeft);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    currentLeft = j + <span class="number">1</span>;</span><br><span class="line">                    left[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">currentRight</span> <span class="operator">=</span> colNum - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> colNum - <span class="number">1</span>; j &gt;=<span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    right[j] = Math.min(right[j], currentRight);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    currentRight = j - <span class="number">1</span>;</span><br><span class="line">                    right[j] = colNum - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colNum; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                maxArea = Math.max(maxArea, height[j] * (right[j] - left[j] + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-87:Scramble String</title>
    <url>/leetCode/leetCode-87/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>将一个字符串递归分割，可以用一棵二叉树来表示。将这颗树上非叶子节点的两节点进行交换得到一颗新的二叉树（也是一个新的字符串）。现在给出两个字符串，要求判断第一个字符串是否能经过上述变化（允许多次或者递归变化）得到第二个字符串。题目链接：**<a href="https://leetcode-cn.com/problems/scramble-string/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：s1 &#x3D; “great”, s2 &#x3D; “rgeat”</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：”abcde”, s2 &#x3D; “caebd”</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>仔细观察分析，可以确定，如果 <code>s1</code> 和 <code>s2</code> 可以相互转换，那么必然存在一个分割点将两个字符串切开，假设 <code>s1</code> 切割为 <code>s11</code> 和 <code>s12</code>， <code>s2</code> 切割为 <code>s21</code> 和 <code>s22</code>，使得 <code>s11</code> 和 <code>s21</code>、<code>s12</code> 和 <code>s22</code> 可以相互转换，或者 <code>s11</code> 和 <code>s22</code>、<code>s12</code> 和 <code>s21</code> 可以相互转换。</p>
<p>因此，可以用动态规划进行求解。假设 <code>dp[i][j][k]</code> 表示 <code>s1</code> 字符串中从 <code>i</code> 位置开始 <code>k</code> 个字符构成的字符串与 <code>s2</code> 字符串中从 <code>j</code> 位置开始 <code>k</code> 个字符构成的字符串两者的转换结果（true 或者 false，能相互转换为 true，否则为 false），则动态转移方程为：<code>dp[i][j][k] = (dp[i][j][m] &amp;&amp; dp[i + m][j + m][k - m]) || (dp[i][j + k - m][m] &amp;&amp; dp[i + m][j][k - m]) (1 &lt;= m &lt; k)</code>。<code>dp[0][0][length]</code> 的结果就是最终的结果。为了使动态转移方程在计算过程中能够获取到表达式中每个计算项的值（确保表达式中每个计算项在本次计算之前已经得到相应的结果），<code>i、j</code> 的循环需要从后往前，<code>k</code> 的循环从前往后。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isScramble</span><span class="params">(String s1, String s2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() != s2.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s1.length();</span><br><span class="line">        <span class="type">boolean</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len][len + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> len - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= len - j &amp;&amp; k &lt;= len - i; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j][k] = s1.substring(i, i + k).equals(s2.substring(j, j + k));</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>; m &lt; k; m++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">temp</span> <span class="operator">=</span> dp[i][j][m] &amp;&amp; dp[i + m][j + m][k - m];</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">temp2</span> <span class="operator">=</span> dp[i][j + k - m][m] &amp;&amp; dp[i + m][j][k - m];</span><br><span class="line">                        dp[i][j][k] = dp[i][j][k] || temp || temp2;</span><br><span class="line">                        <span class="keyword">if</span> (dp[i][j][k])</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-88:Merge Sorted Array</title>
    <url>/leetCode/leetCode-88/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p> 给定两个有序数组 <code>nums1</code> 和 <code>nums2</code>，其中 <code>nums1</code> 的有效数字个数为 <code>m</code>， <code>nums2</code> 的有效数字个数为 <code>n</code>，<code>nums1</code> 的长度大小为 <code>m + n</code>，即 <code>nums1</code> 数组能存放 <code>nums1</code> 和 <code>nums2</code> 的所有有效数字。要求将数组 <code>nums2</code> 合并到 <code>nums1</code> 上，并且合并后的数组保持有序。题目链接：**<a href="https://leetcode.com/problems/merge-sorted-array/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3</p>
<p>输出：[1,2,2,3,5,6]</p>
</blockquote>
<blockquote>
<p>输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0</p>
<p>输出：[1]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题最简单的做法是把 <code>nums2</code> 的元素直接补到 <code>nums1</code> 后面，然后直接调用 <code>Arrays.sort</code> 对 <code>nums1</code> 进行排序。但是这样时间复杂度为 <code>O(nlogn)</code>，同时也没利用上数组有序的特点。因此可以考虑归并排序的做法，为了避免不停的挪动数组，可以从数组的末尾往前逐渐比较放置元素。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m + n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (first &gt;= <span class="number">0</span> &amp;&amp; second &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[first] &gt; nums2[second])</span><br><span class="line">                &#123;</span><br><span class="line">                    nums1[i] = nums1[first];</span><br><span class="line">                    first--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nums1[i] = nums2[second];</span><br><span class="line">                    second--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (first &gt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nums1[i] = nums1[first];</span><br><span class="line">                    first--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nums1[i] = nums2[second];</span><br><span class="line">                    second--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-89:Gray Code</title>
    <url>/leetCode/leetCode-89/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个非负整数 n ，要求输出该整数的二进制对应的格雷码序列（对于某个二进制数，改变其中一位数字，将其变成另一个全新的数字，这个数字在之前没出现过，由这些数字构成的序列称为格雷码序列），其中第一个数字必须以 0 开头。题目链接：**<a href="https://leetcode.com/problems/gray-code/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：2</p>
<p>输出：[0,1,3,2]</p>
<p>解释：其过程如下</p>
<p>00</p>
<p>01</p>
<p>11</p>
<p>10</p>
<p>也可以输出：[0,2,3,1]，其构造过程如下</p>
<p>00</p>
<p>10</p>
<p>11</p>
<p>01</p>
</blockquote>
<blockquote>
<p>输入：0</p>
<p>输出：[0]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><h2 id="暴力破解法"><a href="#暴力破解法" class="headerlink" title="暴力破解法"></a>暴力破解法</h2><p>此方法主要是将上一个产生的数字对应的二进制数，从左到右，依次改变其中一位的数字（由 0 变成 1，或由 1 变成 0），然后判断这新产生的数字是否在已经产生的数字的集合中，如果该数字存在集合中，则恢复改变当前位置的数字，改变下一个位置的数字，再次进行判断，如果不在则加入该集合，并将这个新产生的数字作为上一个产生的数字进行下一轮循环，直到找到所有的数字为止。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">grayCode</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(count);</span><br><span class="line">        nums.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                reverseBitNumber(bits, j);</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> getNum(bits);</span><br><span class="line">                <span class="keyword">if</span> (!nums.contains(num))</span><br><span class="line">                &#123;</span><br><span class="line">                    nums.add(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                reverseBitNumber(bits, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将二进制数字转成十进制数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(<span class="type">int</span>[] bits)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> bits.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num = (bits[i] &lt;&lt; (length - i - <span class="number">1</span>)) | num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 翻转数组中某位的元素，由 0 变成 1，由 1 变成 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseBitNumber</span><span class="params">(<span class="type">int</span>[] bits, <span class="type">int</span> index)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bits[index] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bits[index] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            bits[index] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高位01对半增加法"><a href="#高位01对半增加法" class="headerlink" title="高位01对半增加法"></a>高位01对半增加法</h2><p>此做法主要参考<a href="https://leetcode.com/problems/gray-code/discuss/29891/Share-my-solution">https://leetcode.com/problems/gray-code/discuss/29891/Share-my-solution</a>。主要思想是：先构造 n - 1 的格雷码序列，然后将这个序列翻转产生另一个序列（这两个序列是关于某条直线对称的），然后在前一个序列的每个数字的前面补 0 构成数字 n 的格雷码序列的前半部分，在后一个序列的每个数字的前面补 1 构成数字 n 的格雷码序列的后半部分。</p>
<p>例如：对于数字 3，要想产生 3 的格雷码序列，需要先产生 2 的格雷码序列，要想产生 2 的格雷码序列，需要先产生 1 的格雷码序列，那么产生的顺序如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 的格雷码序列：</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">2 的格雷码序列：</span><br><span class="line">00</span><br><span class="line">01</span><br><span class="line">------ 分割线，如果将上部分的最高为的 0 去掉，将下部分的最高位的 1 去到，那么上下两部分是关于这条线对称的，而且上半部分去掉最高位的 0 之后，剩下的内容就是数字 1 的格雷码序列</span><br><span class="line">11</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">3 的格雷码序列：</span><br><span class="line">000</span><br><span class="line">001</span><br><span class="line">011</span><br><span class="line">010</span><br><span class="line">------ 分割线，如果将上部分的最高为的 0 去掉，将下部分的最高位的 1 去到，那么上下两部分是关于这条线对称的，而且上半部分去掉最高位的 0 之后，剩下的内容就是数字 2 的格雷码序列</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">101</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">grayCode</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        nums.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">nextNum</span> <span class="operator">=</span> nums.get(j) | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                nums.add(nextNum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://leetcode.com/problems/gray-code/discuss/29891/Share-my-solution">https://leetcode.com/problems/gray-code/discuss/29891/Share-my-solution</a></li>
</ol>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-90:Subsets II</title>
    <url>/leetCode/leetCode-90/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给出一个包含重复数字的整形数组，要求找出数组组成的集合的所有子集合（幂集），并且所有子集中不能包含相同的子集。题目链接：**<a href="https://leetcode.com/problems/subsets-ii/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h1><blockquote>
<p>输入：[4,4,4,1,4]</p>
<p>输出：[[],[1],[4],[4,4],[4,4,4],[4,4,4,4],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4]]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题跟<a href="https://leetcode.com/problems/subsets/description/">78:Subsets</a>类似，只不过这里输入的数组是包含重复数字的，需要过滤掉重复数字避免产生重复的子集合。具体做法也类似，只是在遍历数组的过程中判断每个数字的重复次数，对重复数字的增加，只需取出已有的子集合，然后对每个子集合放入重复的数字1次得到新的子集合，再对原先的每个子集合放入重复的数字2次得到新的子集合，…，再对原先的每个子集合放入重复的数字n次得到新的子集合，最后将这些子集合合并得到截止到当前数字组成的集合的所有子集合。具体过程如下：</p>
<ul>
<li>对数组进行排序</li>
<li>遍历数组的每个数字，找出连续的相同的数字的个数 k<ul>
<li>让 j 从 1开始循环到 k<ul>
<li>取出原先已有的每个子集合，增加 j 个当前的数字到该子集合中，产生新集合</li>
<li>将产生的新集合添加到结果集中</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例如：输入[2,1,2]，其过程如下</p>
<ul>
<li>首先产生空集合[]，此时结果集中是[]</li>
<li>对数组排序，产生新数组[1,2,2]</li>
<li>遍历数组<ul>
<li>第一个数字1，只有一个重复数字，此时取出原有的结果集[]，增加1次当前数字1产生新的子集合[1]，增加到结果集中，此时结果集[],[1]</li>
<li>第二个数字2，有两个重复数字，此时取出原有的结果集[],[1]<ul>
<li>对原有的结果集中的每个集合，增加1次当前数字2产生新的子集合[2],[1,2]</li>
<li>对原有的结果集中的每个集合，增加2此当前数字2产生新的子集合[2,2],[1,2,2]</li>
<li>将新产生的集合增加到结果集中，此时结果集[],[1],[2],[1,2],[2,2],[1,2,2]</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算出连续的重复数字个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">duplicateCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                duplicateCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将重复的数字与之前得到的子集合并得到新的子集</span></span><br><span class="line">            <span class="comment">// 将这两个子集合并得到截止到目前位置的集合的所有子集</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> result.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;Integer&gt; tempList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(result.get(j));</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; duplicateCount; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    List&lt;Integer&gt; newNumList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(tempList);</span><br><span class="line">                    newNumList.add(nums[i]);</span><br><span class="line">                    result.add(newNumList);</span><br><span class="line">                    tempList = newNumList;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-91:Decode Ways</title>
    <url>/leetCode/leetCode-91/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>用数字1<del>26代表大写字母A</del>Z，输入一个非空的数字字符串，要求输出这个数字字符串转成大写字母时有多少种转换的方式。题目链接：**<a href="https://leetcode.com/problems/decode-ways/description/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：”12”</p>
<p>输出：2</p>
</blockquote>
<blockquote>
<p>输入：”226”</p>
<p>输出：3</p>
</blockquote>
<blockquote>
<p>输入：”302”</p>
<p>输出：0</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题可以转换为已知一个字符串的的转换方式数，求当加入一个新的字符组成一个新的字符串时的转换方式数。这很明显可以使用递归或动态规划解法。此处用动态规划进行求解。假设用 f(n) 表示前 n 个数的转换方式数，则可以得出以下的动态规划方程</p>
<ul>
<li>如果第 n 个数是0<ul>
<li>如果第 n - 1个数是1或者2，则 f(n) &#x3D; f(n - 2)，因为只能把最后两个数一起转换</li>
<li>否则，f(n) &#x3D; 0，此时没有任何转换方式满足</li>
</ul>
</li>
<li>如果第 n 个数不是 0，第 n - 1个数是 0，则 f(n) &#x3D; f(n - 1)，因为最后一个数必须单独进行转换</li>
<li>如果第 n 个数和第 n - 1个数都不是0<ul>
<li>如果第 n - 1个数和第n - 2个数构成的数字小于等于26，则 f(n) &#x3D; f(n - 1) + f(n - 2)，因为此时可以将最后两个数一起转换，也可以将最后一个数单独转换，如果是最后两个数一起转换，则转换方式有 f(n - 2)，如果是将最后一个数单独转换，则转换方式有 f(n - 1)</li>
<li>如果第 n - 1个数和第n - 2个数构成的数字大于26，则 f(n) &#x3D; f(n - 1)，因为此时只能将最后一个数单独转换</li>
</ul>
</li>
</ul>
<p>初始化时，f(0) &#x3D; 1, f(1) &#x3D; 0(当前位是0，前一位大于2)，或 f(1) &#x3D; 1(当前位是0，前一位是1或2，或当前位不是0且与前一位构成数字大于26)，或 f(1) &#x3D; 2(当前位不是0，且与前一位构成的数字小于等于26)</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span> || s.startsWith(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// a[i] 表示截止到i位置的拆分数</span></span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(<span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(<span class="number">0</span>) != <span class="string">&#x27;1&#x27;</span> &amp;&amp; s.charAt(<span class="number">0</span>) != <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Integer.parseInt(s.substring(<span class="number">0</span>, <span class="number">2</span>)) &lt;= <span class="number">26</span> &amp;&amp; s.charAt(<span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前位是0，需要检查是否可以和前一位构成10或者20</span></span><br><span class="line">            <span class="comment">// 如果可以，则拆分的数等于截止到前两个数的拆分数</span></span><br><span class="line">            <span class="comment">// 否则，拆分数为0</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[i] = a[i - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    a[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前位不等于0，则判断前一位是否是0</span></span><br><span class="line">            <span class="comment">// 如果是0，则拆分数等于截止前一位的拆分数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i] = a[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前位和前一位都不等于0，需要判断是否和前一位构成的数小于等于26</span></span><br><span class="line">            <span class="comment">// 如果小于等于26，则拆分数为截止到前一个数的拆分数加上截止到前两个数的拆分数</span></span><br><span class="line">            <span class="comment">// 否则，拆分数为截止到前一个数的拆分数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Integer.parseInt(s.substring(i - <span class="number">1</span>, i + <span class="number">1</span>)) &lt;= <span class="number">26</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i] = a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                a[i] = a[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> a[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-92:Reverse Linked List II</title>
    <url>/leetCode/leetCode-92/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个链表和两个数字 <code>left</code>、<code>right</code>，其中<code>1 &lt;= left &lt;= right &lt;= 链表节点数</code>，要求将 <code>[left, right]</code> 区间内的节点进行翻转。题目链接：**<a href="https://leetcode.com/problems/reverse-linked-list-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：head &#x3D; [1,3,5,7,9], left &#x3D; 2, right &#x3D; 4</p>
<p>输出：[1,7,5,3,9]</p>
</blockquote>
<blockquote>
<p>输入：head &#x3D; [5], left &#x3D; 1, right &#x3D; 1</p>
<p>输出：[5]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>先遍历节点找到开始的地方，然后运用 <a href="https://guozhchun.github.io/leetCode/leetCode-206/">LeetCode-206</a> 翻转链表的解法对区间内的节点进行翻转。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prev = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1000</span>, head);</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> prev.next;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; left)</span><br><span class="line">        &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (count &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> prev.next;</span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line">            prev.next.next = temp;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-924:Minimize Malware Spread</title>
    <url>/leetCode/leetCode-924/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二维矩阵，表示网络中的各个节点的连通性，<code>graph[i][j] = 1</code>  表示 <code>i</code> 和 <code>j</code> 是连通的，<code>graph[i][j] = 0 </code> 表示 <code>i</code>、<code>j</code> 不连通。给定一个 <code>initial</code> 数组，数组元素表示网络中被病毒感染的节点，病毒感染具有传播性。要求从 <code>initial</code> 数组中删除某个节点，使网络中被病毒感染的节点数最少。如果存在多个节点，则返回数字最小的节点。题目链接：**<a href="https://leetcode.com/problems/minimize-malware-spread">点我</a>** </p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：graph &#x3D; [[1,1,0],[1,1,0],[0,0,1]], initial &#x3D; [0,1]</p>
<p>输出：0</p>
</blockquote>
<blockquote>
<p>输入：graph &#x3D; [[1,1,1],[1,1,1],[1,1,1]], initial &#x3D; [1,2]</p>
<p>输出：1</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>使用并查集算法，找出网络中有多少个隔离的集群，分别计算每个集群中的节点数。遍历 <code>initial</code> 数组，剔除同一个集群下的元素，对剩下的元素，分别获取其所在集群的节点数，取其最大值，此时对应的元素就是要剔除的节点。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMalwareSpread</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span>[] initial)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="type">int</span>[] parents = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parents.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用并查集找出网络中隔离的集群</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">iParent</span> <span class="operator">=</span> findParent(parents, i);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">jParent</span> <span class="operator">=</span> findParent(parents, j);</span><br><span class="line">                    <span class="keyword">if</span> (iParent != jParent)</span><br><span class="line">                    &#123;</span><br><span class="line">                        parents[iParent] = jParent;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算网络中隔离的集群每个集群的节点数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; childrenCountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parents.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> findParent(parents, parents[i]);</span><br><span class="line">            childrenCountMap.put(root, childrenCountMap.getOrDefault(root, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出 initial 中处于同个集群的节点</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; duplicateMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; initial.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> findParent(parents, initial[i]);</span><br><span class="line">            duplicateMap.put(root, duplicateMap.getOrDefault(root, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出 initial 中元素所在的集群中拥有最多节点数的集群</span></span><br><span class="line">        Arrays.sort(initial);</span><br><span class="line">        <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> initial[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; initial.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> findParent(parents, initial[i]);</span><br><span class="line">            <span class="keyword">if</span> (duplicateMap.get(root) == <span class="number">1</span> &amp;&amp; childrenCountMap.get(root) &gt; maxNum)</span><br><span class="line">            &#123;</span><br><span class="line">                maxNum = childrenCountMap.get(root);</span><br><span class="line">                node = initial[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findParent</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (parents[i] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            i = parents[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-93:Restore IP Addresses</title>
    <url>/leetCode/leetCode-93/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个只包含数字的字符串，要求找出这个字符串可以表示的 IP 的列表。题目链接：**<a href="https://leetcode.com/problems/restore-ip-addresses/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：25525511135</p>
<p>输出：[“255.255.11.135”, “255.255.111.35”]</p>
</blockquote>
<blockquote>
<p>输入：10100</p>
<p>输出：[“1.0.10.0”, “10.1.0.0”]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>直接使用回溯算法，将原有的字符串拆分成四个子字符串，然后对这四个子字符串进行判断，如果能组成 IP，则将其拼接成 IP 放在结果集中。需要注意的是，为了防止输入的字符串长度过长导致递归超时，需要在进行递归前判断字符串长度是否有可能拆分成 IP。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isNumsValid</span><span class="params">(List&lt;String&gt; nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (String num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num.length() &gt; <span class="number">3</span> || (num.length() &gt; <span class="number">1</span> &amp;&amp; num.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (Integer.parseInt(num) &gt; <span class="number">255</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">restoreIpAddresses</span><span class="params">(List&lt;String&gt; result, String str, <span class="type">int</span> index, List&lt;String&gt; nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">lastNum</span> <span class="operator">=</span> str.substring(index);</span><br><span class="line">            nums.add(lastNum);</span><br><span class="line">            <span class="keyword">if</span> (isNumsValid(nums))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> nums.get(<span class="number">0</span>) + <span class="string">&quot;.&quot;</span> + nums.get(<span class="number">1</span>) + <span class="string">&quot;.&quot;</span> + nums.get(<span class="number">2</span>) + <span class="string">&quot;.&quot;</span> + nums.get(<span class="number">3</span>);</span><br><span class="line">                result.add(ip);</span><br><span class="line">            &#125;</span><br><span class="line">            nums.remove(<span class="number">3</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> index + i;</span><br><span class="line">            <span class="keyword">if</span> (endIndex &gt;= str.length())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> str.substring(index, endIndex);</span><br><span class="line">            nums.add(num);</span><br><span class="line">            restoreIpAddresses(result, str, endIndex, nums);</span><br><span class="line">            nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; <span class="number">4</span> || s.length() &gt; <span class="number">12</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        restoreIpAddresses(result, s, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-934:Shortest Bridge</title>
    <url>/leetCode/leetCode-934/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个由 <code>0</code> 和 <code>1</code>  组成的二维矩阵，其中由 <code>1</code> 组成的连续区块表示一个小岛（用 <code>0</code> 隔开），题目明确有两个小岛，要求找出连接两个小岛之间的最短桥梁距离（通过将 <code>0</code> 变成 <code>1</code> 表示建桥梁）。题目链接：**<a href="https://leetcode.com/problems/shortest-bridge/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h1><blockquote>
<p>输入：[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]</p>
<p>输出：1</p>
</blockquote>
<blockquote>
<p>输入：[[0,1,0],[0,0,0],[0,0,1]]</p>
<p>输出：2</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>先用深搜找出一个小岛，将其每个节点放入队列中，然后用广搜查找这个小岛到另一个小岛的距离。队列中最先达到另一个小岛的节点距离就是两个小岛中的最短距离。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dy = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">searchFirstIsland</span><span class="params">(<span class="type">int</span>[][] matrix, Queue&lt;Node&gt; queue, <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isValid(x, y, matrix) || matrix[x][y] != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(x, y));</span><br><span class="line">        matrix[x][y] = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            searchFirstIsland(matrix, queue, x + dx[i], y + dy[i]);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">getFirstNode</span><span class="params">(<span class="type">int</span>[][] matrix)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>[][] matrix)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;=<span class="number">0</span> &amp;&amp; x &lt; matrix.length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestBridge</span><span class="params">(<span class="type">int</span>[][] A)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> getFirstNode(A);</span><br><span class="line">        searchFirstIsland(A, queue, node.x, node.y);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> current.x + dx[k];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> current.y + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (!isValid(x, y, A))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (A[x][y] == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (A[x][y] == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(x, y));</span><br><span class="line">                        A[x][y] = -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-95:Unique Binary Search Trees II</title>
    <url>/leetCode/leetCode-95/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数 <code>n</code>，要求找出以数字 <code>1 ~ n</code> 构成的不同结构的二叉搜索树。题目链接：**<a href="https://leetcode.com/problems/unique-binary-search-trees-ii/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：3</p>
<p>输出： [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] </p>
<p>说明：输出代表以下 5 颗二叉搜索树</p>
<p><img src="https://guozhchun.github.io/images/leetcode95.png" alt="二叉搜索树"></p>
</blockquote>
<blockquote>
<p>输入：0</p>
<p>输出：[]</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>对从 <code>1 ~ n</code> 中的每个数字，分别将其作为根节点进行划分，可以划分出左右两个子树，用递归方式对子树进行类似的构造获得左右子树的二叉搜索树列表，然后将其分别拼装到根节点上即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;TreeNode&gt; treeNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            treeNodes.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> treeNodes;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (start == end)</span><br><span class="line">        &#123;</span><br><span class="line">            treeNodes.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(start));</span><br><span class="line">            <span class="keyword">return</span> treeNodes; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; rightTrees = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">for</span> (TreeNode leftTree : leftTrees)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode rightTree : rightTrees)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                    root.left = leftTree;</span><br><span class="line">                    root.right = rightTree;</span><br><span class="line">                    treeNodes.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> treeNodes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-96:Unique Binary Search Trees</title>
    <url>/leetCode/leetCode-96/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个正整数 <code>n</code>，要求找出以数字 <code>1 ~ n</code> 构成的不同结构的二叉搜索树的数量。题目链接：**<a href="https://leetcode.com/problems/unique-binary-search-trees/">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：3</p>
<p>输出：5</p>
</blockquote>
<blockquote>
<p>输入：4</p>
<p>输出：14</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>对数字 <code>1 ~ n</code> 中的每个数字，分别以其作为树的根节点，可以将剩下的数字分成两堆，小于根节点数字的和大于根节点数字的，只要将左子树的数量和右子树的数量相乘，就能得到以当前数字作为根节点时其二叉搜索树的数量，将每个数字作为根节点时的二叉搜索树的数量相加就是最终的结果。对于左子树和右子树，其构成的二叉搜索树的数量的算法与计算总体二叉搜索树的数量算法相同，因此可以用递归来解决，其计算公式为：<code>numTrees(n) = numTrees(0) * numTrees(n - 1) + numTrees(1) * numTress(n - 2) + numTrees(2) * numTrees(n - 3) + ... + numTrees(n - 1) * numTrees(0)</code>。由于这中间存在大量的重复计算，因此可以用一个数组来保存已经计算过的数值，提高计算效率。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> numTrees(n, dp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] dp)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[n] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[n];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[n] += numTrees(i - <span class="number">1</span>, dp) * numTrees(n - i, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-97:Interleaving String</title>
    <url>/leetCode/leetCode-97/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，要求判断 <code>s3</code> 是否能由 <code>s1</code> 和 <code>s2</code> 中的字符按顺序组成。题目链接：**<a href="https://leetcode.com/problems/interleaving-string">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：s1 &#x3D; “aabcc”, s2 &#x3D; “dbbca”, s3 &#x3D; “aadbbcbcac”</p>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>输入：s1 &#x3D; “aabcc”, s2 &#x3D; “dbbca”, s3 &#x3D; “aadbbbaccc”</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用深搜算法对 <code>s1</code>、<code>s2</code>、<code>s3</code> 的子字符串进行判断，为了避免中间大量的重复计算，用一个 <code>map</code> 来保存中间计算的结果。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> isInterleave(s1, s2, s3, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3, Map&lt;String, Boolean&gt; calcMap)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> s1 + <span class="string">&quot;#&quot;</span> + s2;</span><br><span class="line">        <span class="keyword">if</span> (calcMap.containsKey(temp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> calcMap.get(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result = s2.equals(s3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s2.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result = s1.equals(s3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s1.charAt(<span class="number">0</span>) == s2.charAt(<span class="number">0</span>) &amp;&amp; s1.charAt(<span class="number">0</span>) == s3.charAt(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            result = isInterleave(s1.substring(<span class="number">1</span>), s2, s3.substring(<span class="number">1</span>), calcMap) || isInterleave(s1, s2.substring(<span class="number">1</span>), s3.substring(<span class="number">1</span>), calcMap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s1.charAt(<span class="number">0</span>) == s3.charAt(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            result = isInterleave(s1.substring(<span class="number">1</span>), s2, s3.substring(<span class="number">1</span>), calcMap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s2.charAt(<span class="number">0</span>) == s3.charAt(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            result = isInterleave(s1, s2.substring(<span class="number">1</span>), s3.substring(<span class="number">1</span>), calcMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        calcMap.put(temp, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-99:Recover Binary Search Tree</title>
    <url>/leetCode/leetCode-99/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个二叉搜索树，其中有两个数字位置错了，要求在不改变树结构的前提下，将这两个数字交换，恢复成正常的二叉搜索树。题目链接：**<a href="https://leetcode.com/problems/recover-binary-search-tree">点我</a>**</p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：[1,3,null,null,2]</p>
<p>说明：树结构如下</p>
<p>  1</p>
<p>&#x2F;</p>
<p>3</p>
<p>  \</p>
<p>​    2</p>
<p>输出：[3,1,null,null,2]</p>
<p>说明：树结构如下</p>
<p>​    3</p>
<p>  &#x2F;</p>
<p>1</p>
<p>  \</p>
<p>​    2</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>对于二叉搜索树，使用中序遍历时，会得到一个升序的序列，现在给出的树中，有两个数字位置错误，因此，只需要使用中序遍历二叉树，每次遍历时判断当前节点是否比上一个节点小，如果小，则说明上一个节点或当前节点的数字是错的。待遍历结束后，将这两个节点的数字进行交换，就能在不改变树结构的情况下恢复正常的二叉搜索树。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">second</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverTree</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        findTargetNode(root);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> first.val;</span><br><span class="line">        first.val = second.val;</span><br><span class="line">        second.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findTargetNode</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        findTargetNode(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.val &gt;= root.val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                first = prev;</span><br><span class="line">            &#125;</span><br><span class="line">            second = root;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = root;</span><br><span class="line">        </span><br><span class="line">        findTargetNode(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-331:Verify Preorder Serialization of a Binary Tree</title>
    <url>/leetCode/leetCode-331/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串，字符串是用 <code>,</code> 分割的数字和 <code>#</code>，判断该字符串是否一个二叉树的前序遍历字符串（前序遍历过程中遇到空节点输出 <code>#</code>），要求在判断过程中不能将字符串转换为二叉树。题目链接：<a href="https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：preorder &#x3D; “9,3,4,#,#,1,#,#,2,#,6,#,#”</p>
<p>输出：true</p>
<p>解释：该字符串代表的树形状如下</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg"></p>
</blockquote>
<blockquote>
<p>输入：preorder &#x3D; “9,#,#,1”</p>
<p>输出：false</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>用栈来模拟树的遍历过程，如果遇到 <code>#</code> ，则判断当前栈顶元素是否“暴露”了两次，如果是，说明当前节点的子节点已经遍历完成，将其出栈。最后判断栈中是否为空，如果为空，则说明是一个二叉树，否则不是。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSerialization</span><span class="params">(String preorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.equals(<span class="string">&quot;#&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] items = preorder.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">101</span>];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> items[i];</span><br><span class="line">            <span class="keyword">if</span> (item.equals(<span class="string">&quot;#&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                counts[stack.peek()]++;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 可能存在重复的数字，所以用2的倍数来判断</span></span><br><span class="line">                <span class="keyword">while</span> (counts[stack.peek()] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果遍历过程中栈为空，还有剩余元素没入栈，说明这不是一棵二叉树</span></span><br><span class="line">                    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> i == items.length - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    counts[stack.peek()]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(Integer.parseInt(item));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode-421:Maximum XOR of Two Numbers in an Array</title>
    <url>/leetCode/leetCode-421/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个非负整数的数组，要求找出数组中两个元素的异或值的最大值。题目链接：<a href="https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array"><strong>点我</strong></a></p>
<span id="more"></span>

<h1 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h1><blockquote>
<p>输入：nums &#x3D; [3,10,5,25,2,8]</p>
<p>输出：28</p>
<p>解释：最大值是 <code>5 XOR 25 = 28</code></p>
</blockquote>
<blockquote>
<p>输入：nums &#x3D; [14,70,53,83,49,91,36,80,92,51,66,70]</p>
<p>输出：127</p>
</blockquote>
<h1 id="问题解法"><a href="#问题解法" class="headerlink" title="问题解法"></a>问题解法</h1><p>此题最简单的做法就是两层循环分别对两个数字进行异或求解，但是这样时间复杂度是 <code>O(n ^ 2)</code>，会超时。优化的做法是将数组元素的二进制数构造字典树，然后依次取数组中元素，判断每个二进制位，从字典数中取出与其数字（<code>0</code> 对应 <code>1</code>, <code>1</code> 对应 <code>0</code>）相反的分支，如果不存在此分支则走另外的分支（不存在 <code>0</code> 的分支则走 <code>1</code> 的分支，不存在 <code>1</code> 的分支则走 <code>0</code> 的分支）。需要注意的是构造字典树需要从元素高位构造，从高位进行匹配，因为异或为 <code>1</code> 时，高位的 <code>1</code> 比低位的 <code>1</code> 代表的数值会更大。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TOTAL_DIGITS</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node[] children = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaximumXOR</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> buildTree(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempResult</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> TOTAL_DIGITS; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (~bit) &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (current.children[index] != <span class="literal">null</span>) &#123;</span><br><span class="line">                    current = current.children[index];</span><br><span class="line">                    tempResult = (<span class="number">1</span> &lt;&lt; i) | tempResult;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    current = current.children[bit];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, tempResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> TOTAL_DIGITS; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (current.children[bit] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    current.children[bit] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                current = current.children[bit];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
</search>
